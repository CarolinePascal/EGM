<?xml version="1.0"?>
<doc>
  <assembly>
    <name>QuickGraph</name>
  </assembly>
  <members>
    <member name="T:QuickGraph.AdjacencyGraph`2">
      <summary>
            A mutable directed graph data structure efficient for sparse
            graph representation where out-edge need to be enumerated only.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <invariant>this.edgeCount &gt;= 0</invariant>
    </member>
    <member name="P:QuickGraph.AdjacencyGraph`2.IsEdgesEmpty">
      <summary>
            Gets a value indicating whether this instance is edges empty.
            </summary>
      <value>
        <c>true</c> if this instance is edges empty; otherwise, <c>false</c>.
            </value>
      <getter>
        <pure />
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.EdgeCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.EdgeCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.EdgeCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.AdjacencyGraph`2.EdgeCount">
      <summary>
            Gets the edge count.
            </summary>
      <value>The edge count.</value>
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Edges); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Edges); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Edges); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.AdjacencyGraph`2.Edges">
      <summary>
            Gets the edges.
            </summary>
      <value>The edges.</value>
      <getter>
        <pure />
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        push Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;();
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))();
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__5_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__5_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push result;
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})">
      <summary>
            Adds a range of edges to the graph
            </summary>
      <param name="edges" />
      <returns>the count edges that were added</returns>
      <requires inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return edges != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return edges &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return edges != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__1_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__1_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()" vb="(() =&gt; {
    If Not System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType Then
    push edges;
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__1_0;
    If dup = Nothing Then
    pop
    push (edge As TEdge) =&gt; ((Object)edge) &lt;&gt; Nothing;
    &lt;&gt;9__1_0 = dup
    push System.Linq.Enumerable.All(pop, pop);
    else    push 1;
    return pop &lt;&gt; 0; })()">(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__1_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__1_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + Contract.Result&lt;int&gt;()" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + Contract.Result(Of Integer )()">this.EdgeCount == old(this.EdgeCount) + result</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.AddEdge(`1)">
      <summary>
            Adds the edge to the graph
            </summary>
      <param name="e">the edge to add</param>
      <returns>true if the edge was added; false if it was already part of the graph</returns>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.ContainsVertex(edge.Source)" vb="Me.ContainsVertex(edge.Source)">this.ContainsVertex(edge.Source)</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.ContainsVertex(edge.Target)" vb="Me.ContainsVertex(edge.Target)">this.ContainsVertex(edge.Target)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.ContainsEdge(edge)" vb="Me.ContainsEdge(edge)">this.ContainsEdge(edge)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.Old(!this.ContainsEdge(edge))" vb="Me.AllowParallelEdges OrElse Contract.Result(Of Boolean )() = Contract.Old(Not Me.ContainsEdge(edge))">this.AllowParallelEdges || result == old(!this.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + (Contract.Result(Of Boolean )() ? 1 : 0)">this.EdgeCount == old(this.EdgeCount) + (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmBase`1.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,`0)">
      <summary>
            Creates a new algorithm with an (optional) host.
            </summary>
      <param name="host">if null, host is set to the this reference</param>
      <param name="visitedGraph" />
      <requires csharp="(object)visitedGraph != null" vb="((Object)visitedGraph) &lt;&gt; Nothing">(object)visitedGraph != null</requires>
    </member>
    <member name="T:QuickGraph.Algorithms.AlgorithmExtensions">
      <summary>
            Various extension methods to build algorithms
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.GetIndexer``2(System.Collections.Generic.Dictionary{``0,``1})">
      <summary>
            Returns the method that implement the access indexer.
            </summary>
      <typeparam name="TKey" />
      <typeparam name="TValue" />
      <param name="dictionary" />
      <returns />
      <requires csharp="new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass0_0&lt;TKey, TValue&gt;(){
    dictionary = dictionary, 
}.dictionary != null" vb="(() =&gt; {
    QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass0_0&lt;TKey, TValue&gt; local_0_prime = New QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass0_0(Of TKey, TValue)();
    (local_0_prime.dictionary = dictionary)
    return local_0_prime; })().dictionary &lt;&gt; Nothing">new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass0_0&lt;TKey, TValue&gt;(){
    dictionary = dictionary, 
}.dictionary != null</requires>
      <ensures csharp="Contract.Result&lt;System.Func&lt;TKey, TValue&gt;&gt;() != null" vb="Contract.Result(Of System.Func(Of TKey, TValue))() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.GetVertexIdentity``1(QuickGraph.IVertexSet{``0})">
      <summary>
            Gets the vertex identity.
            </summary>
      <remarks>
            Returns more efficient methods for primitive types,
            otherwise builds a dictionary
            </remarks>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <param name="graph">The graph.</param>
      <returns />
      <requires csharp="(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass1_0&lt;TVertex&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass1_0&lt;TVertex&gt;();
    }
    return graph != null; })()" vb="(() =&gt; {
    QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass1_0&lt;TVertex&gt; local_0 = New QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass1_0(Of TVertex)();
    return graph &lt;&gt; Nothing; })()">(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass1_0&lt;TVertex&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass1_0&lt;TVertex&gt;();
    }
    return graph != null; })()</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.GetEdgeIdentity``2(QuickGraph.IEdgeSet{``0,``1})">
      <summary>
            Gets the edge identity.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="graph">The graph.</param>
      <returns />
      <requires csharp="(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass2_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass2_0&lt;TVertex, TEdge&gt;();
    }
    return graph != null; })()" vb="(() =&gt; {
    QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass2_0&lt;TVertex, TEdge&gt; local_0 = New QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass2_0(Of TVertex, TEdge)();
    return graph &lt;&gt; Nothing; })()">(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass2_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass2_0&lt;TVertex, TEdge&gt;();
    }
    return graph != null; })()</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.TreeDepthFirstSearch``2(QuickGraph.IVertexListGraph{``0,``1},``0)">
      <summary>
            Computes a depth first tree.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="visitedGraph">The visited graph.</param>
      <param name="root">The root.</param>
      <returns />
      <requires csharp="(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass4_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass4_0&lt;TVertex, TEdge&gt;();
    }
    return visitedGraph != null; })()" vb="(() =&gt; {
    QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass4_0&lt;TVertex, TEdge&gt; local_0 = New QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass4_0(Of TVertex, TEdge)();
    return visitedGraph &lt;&gt; Nothing; })()">(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass4_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass4_0&lt;TVertex, TEdge&gt;();
    }
    return visitedGraph != null; })()</requires>
      <requires csharp="(object)root != null" vb="((Object)root) &lt;&gt; Nothing">(object)root != null</requires>
      <requires csharp="visitedGraph.ContainsVertex(root)" vb="visitedGraph.ContainsVertex(root)">visitedGraph.ContainsVertex(root)</requires>
      <ensures csharp="Contract.Result&lt;QuickGraph.TryFunc&lt;TVertex, System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;&gt;() != null" vb="Contract.Result(Of QuickGraph.TryFunc(Of TVertex, System.Collections.Generic.IEnumerable(Of TEdge)))() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.RankedShortestPathHoffmanPavley``2(QuickGraph.IBidirectionalGraph{``0,``1},System.Func{``1,System.Double},``0,``0,System.Int32)">
      <summary>
            Computes the k-shortest path from <paramref name="source" /><paramref name="target" /> using Hoffman-Pavley algorithm.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <param name="edgeWeights" />
      <param name="source" />
      <param name="target" />
      <param name="pathCount" />
      <returns />
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
      <requires csharp="edgeWeights != null" vb="edgeWeights &lt;&gt; Nothing">edgeWeights != null</requires>
      <requires csharp="(object)source != default(object) &amp;&amp; visitedGraph.ContainsVertex(source)" vb="((Object)source) &lt;&gt; Nothing AndAlso visitedGraph.ContainsVertex(source)">(object)source != default(object) &amp;&amp; visitedGraph.ContainsVertex(source)</requires>
      <requires csharp="(object)target != default(object) &amp;&amp; visitedGraph.ContainsVertex(target)" vb="((Object)target) &lt;&gt; Nothing AndAlso visitedGraph.ContainsVertex(target)">(object)target != default(object) &amp;&amp; visitedGraph.ContainsVertex(target)</requires>
      <requires csharp="pathCount &gt; 1" vb="pathCount &gt; 1">pathCount &gt; 1</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.Sinks``2(QuickGraph.IVertexListGraph{``0,``1})">
      <summary>
            Gets the list of sink vertices
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <returns />
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.Roots``2(QuickGraph.IBidirectionalGraph{``0,``1})">
      <summary>
            Gets the list of root vertices
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <returns />
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.IsolatedVertices``2(QuickGraph.IBidirectionalGraph{``0,``1})">
      <summary>
            Gets the list of isolated vertices (no incoming or outcoming vertices)
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <returns />
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.Roots``2(QuickGraph.IVertexListGraph{``0,``1})">
      <summary>
            Gets the list of roots
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <returns />
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.TopologicalSort``2(QuickGraph.IUndirectedGraph{``0,``1})">
      <summary>
            Creates a topological sort of a undirected
            acyclic graph.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <returns />
      <exception cref="T:QuickGraph.NonAcyclicGraphException">the input graph
            has a cycle</exception>
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.TopologicalSort``2(QuickGraph.IUndirectedGraph{``0,``1},System.Collections.Generic.IList{``0})">
      <summary>
            Creates a topological sort of a undirected
            acyclic graph.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <param name="vertices" />
      <returns />
      <exception cref="T:QuickGraph.NonAcyclicGraphException">the input graph
            has a cycle</exception>
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
      <requires csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.TopologicalSort``2(QuickGraph.IVertexListGraph{``0,``1})">
      <summary>
            Creates a topological sort of a directed
            acyclic graph.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <returns />
      <exception cref="T:QuickGraph.NonAcyclicGraphException">the input graph
            has a cycle</exception>
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.TopologicalSort``2(QuickGraph.IVertexListGraph{``0,``1},System.Collections.Generic.IList{``0})">
      <summary>
            Creates a topological sort of a directed
            acyclic graph.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <param name="vertices" />
      <returns />
      <exception cref="T:QuickGraph.NonAcyclicGraphException">the input graph
            has a cycle</exception>
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
      <requires csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.ConnectedComponents``2(QuickGraph.IUndirectedGraph{``0,``1},System.Collections.Generic.IDictionary{``0,System.Int32})">
      <summary>
            Computes the connected components of a graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="g" />
      <param name="components" />
      <returns>number of components</returns>
      <requires csharp="g != null" vb="g &lt;&gt; Nothing">g != null</requires>
      <requires csharp="components != null" vb="components &lt;&gt; Nothing">components != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.IncrementalConnectedComponents``2(QuickGraph.IMutableVertexAndEdgeSet{``0,``1})">
      <summary>
            Computes the incremental connected components for a growing graph (edge added only).
            Each call to the delegate re-computes the component dictionary. The returned dictionary
            is shared accross multiple calls of the method.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="g" />
      <returns />
      <requires csharp="(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass28_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass28_0&lt;TVertex, TEdge&gt;();
    }
    return g != null; })()" vb="(() =&gt; {
    QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass28_0&lt;TVertex, TEdge&gt; local_0 = New QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass28_0(Of TVertex, TEdge)();
    return g &lt;&gt; Nothing; })()">(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass28_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass28_0&lt;TVertex, TEdge&gt;();
    }
    return g != null; })()</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.WeaklyConnectedComponents``2(QuickGraph.IVertexListGraph{``0,``1},System.Collections.Generic.IDictionary{``0,System.Int32})">
      <summary>
            Computes the weakly connected components of a graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="g" />
      <param name="components" />
      <returns>number of components</returns>
      <requires csharp="g != null" vb="g &lt;&gt; Nothing">g != null</requires>
      <requires csharp="components != null" vb="components &lt;&gt; Nothing">components != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.StronglyConnectedComponents``2(QuickGraph.IVertexListGraph{``0,``1},System.Collections.Generic.IDictionary{``0,System.Int32}@)">
      <summary>
            Computes the strongly connected components of a graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="g" />
      <param name="components" />
      <returns>number of components</returns>
      <requires csharp="g != null" vb="g &lt;&gt; Nothing">g != null</requires>
      <ensures csharp="components != null" vb="components &lt;&gt; Nothing">components != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.Clone``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1},System.Func{``0,``0},System.Func{``1,``0,``0,``1},QuickGraph.IMutableVertexAndEdgeSet{``0,``1})">
      <summary>
            Clones a graph to another graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="g" />
      <param name="vertexCloner" />
      <param name="edgeCloner" />
      <param name="clone" />
      <requires csharp="g != null" vb="g &lt;&gt; Nothing">g != null</requires>
      <requires csharp="vertexCloner != null" vb="vertexCloner &lt;&gt; Nothing">vertexCloner != null</requires>
      <requires csharp="edgeCloner != null" vb="edgeCloner &lt;&gt; Nothing">edgeCloner != null</requires>
      <requires csharp="clone != null" vb="clone &lt;&gt; Nothing">clone != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.CondensateStronglyConnected``3(QuickGraph.IVertexAndEdgeListGraph{``0,``1})">
      <summary>
            Condensates the strongly connected components of a directed graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <typeparam name="TGraph" />
      <param name="g" />
      <returns />
      <requires csharp="g != null" vb="g &lt;&gt; Nothing">g != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.CondensateWeaklyConnected``3(QuickGraph.IVertexAndEdgeListGraph{``0,``1})">
      <summary>
            Condensates the weakly connected components of a graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <typeparam name="TGraph" />
      <param name="g" />
      <returns />
      <requires csharp="g != null" vb="g &lt;&gt; Nothing">g != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.OddVertices``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1})">
      <summary>
            Create a collection of odd vertices
            </summary>
      <param name="g">graph to visit</param>
      <returns>colleciton of odd vertices</returns>
      <exception cref="T:System.ArgumentNullException">g is a null reference</exception>
      <requires csharp="g != null" vb="g &lt;&gt; Nothing">g != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.IsDirectedAcyclicGraph``2(QuickGraph.IVertexListGraph{``0,``1})">
      <summary>
            Gets a value indicating whether the graph is acyclic
            </summary>
      <remarks>
            Performs a depth first search to look for cycles.
            </remarks>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="g" />
      <returns />
      <requires csharp="g != null" vb="g &lt;&gt; Nothing">g != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.ComputePredecessorCost``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``1,System.Double},``0)">
      <summary>
            Given a edge cost map, computes 
            the predecessor cost.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="predecessors" />
      <param name="edgeCosts" />
      <param name="target" />
      <returns />
      <requires csharp="predecessors != null" vb="predecessors &lt;&gt; Nothing">predecessors != null</requires>
      <requires csharp="edgeCosts != null" vb="edgeCosts &lt;&gt; Nothing">edgeCosts != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.MinimumSpanningTreePrim``2(QuickGraph.IUndirectedGraph{``0,``1},System.Func{``1,System.Double})">
      <summary>
            Computes the minimum spanning tree using Prim's algorithm.
            Prim's algorithm is simply implemented by calling Dijkstra shortest path.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <param name="weights" />
      <returns />
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
      <requires csharp="weights != null" vb="weights &lt;&gt; Nothing">weights != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.MinimumSpanningTreeKruskal``2(QuickGraph.IUndirectedGraph{``0,``1},System.Func{``1,System.Double})">
      <summary>
            Computes the minimum spanning tree using Kruskal's algorithm.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <param name="weights" />
      <returns />
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
      <requires csharp="weights != null" vb="weights &lt;&gt; Nothing">weights != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.OfflineLeastCommonAncestorTarjan``2(QuickGraph.IVertexListGraph{``0,``1},``0,System.Collections.Generic.IEnumerable{QuickGraph.SEquatableEdge{``0}})">
      <summary>
            Computes the offline least common ancestor between pairs of vertices in a rooted tree
            using Tarjan algorithm.
            </summary>
      <remarks>
            Reference:
            Gabow, H. N. and Tarjan, R. E. 1983. A linear-time algorithm for a special case of disjoint set union. In Proceedings of the Fifteenth Annual ACM Symposium on theory of Computing STOC '83. ACM, New York, NY, 246-251. DOI= http://doi.acm.org/10.1145/800061.808753 
            </remarks>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <param name="root" />
      <param name="pairs" />
      <returns />
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
      <requires csharp="(object)root != null" vb="((Object)root) &lt;&gt; Nothing">(object)root != null</requires>
      <requires csharp="pairs != null" vb="pairs &lt;&gt; Nothing">pairs != null</requires>
      <requires csharp="visitedGraph.ContainsVertex(root)" vb="visitedGraph.ContainsVertex(root)">visitedGraph.ContainsVertex(root)</requires>
      <requires csharp="System.Linq.Enumerable.All&lt;QuickGraph.SEquatableEdge&lt;TVertex&gt;&gt;(pairs, (QuickGraph.SEquatableEdge&lt;TVertex&gt; p) =&gt; visitedGraph.ContainsVertex(p.Source))" vb="System.Linq.Enumerable.All(pairs, (p As QuickGraph.SEquatableEdge(Of TVertex)) =&gt; visitedGraph.ContainsVertex(p.Source))">System.Linq.Enumerable.All&lt;QuickGraph.SEquatableEdge&lt;TVertex&gt;&gt;(pairs, (QuickGraph.SEquatableEdge&lt;TVertex&gt; p) =&gt; visitedGraph.ContainsVertex(p.Source))</requires>
      <requires csharp="System.Linq.Enumerable.All&lt;QuickGraph.SEquatableEdge&lt;TVertex&gt;&gt;(pairs, (QuickGraph.SEquatableEdge&lt;TVertex&gt; p) =&gt; visitedGraph.ContainsVertex(p.Target))" vb="System.Linq.Enumerable.All(pairs, (p As QuickGraph.SEquatableEdge(Of TVertex)) =&gt; visitedGraph.ContainsVertex(p.Target))">System.Linq.Enumerable.All&lt;QuickGraph.SEquatableEdge&lt;TVertex&gt;&gt;(pairs, (QuickGraph.SEquatableEdge&lt;TVertex&gt; p) =&gt; visitedGraph.ContainsVertex(p.Target))</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.MaximumFlowEdmondsKarp``2(QuickGraph.IMutableVertexAndEdgeListGraph{``0,``1},System.Func{``1,System.Double},``0,``0,QuickGraph.TryFunc{``0,``1}@,QuickGraph.EdgeFactory{``0,``1})">
      <summary>
            Computes the Edmonds-Karp maximums flow 
            for a graph with positive capacities and
            flows.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="visitedGraph">The visited graph.</param>
      <param name="edgeCapacities">The edge capacities.</param>
      <param name="source">The source.</param>
      <param name="sink">The sink.</param>
      <param name="flowPredecessors">The flow predecessors.</param>
      <param name="edgeFactory">the edge factory</param>
      <returns />
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
      <requires csharp="edgeCapacities != null" vb="edgeCapacities &lt;&gt; Nothing">edgeCapacities != null</requires>
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
      <requires csharp="(object)sink != null" vb="((Object)sink) &lt;&gt; Nothing">(object)sink != null</requires>
      <requires csharp="!source.Equals((object)sink)" vb="Not source.Equals(((Object)sink))">!source.Equals((object)sink)</requires>
    </member>
    <member name="T:QuickGraph.Algorithms.ComputationState">
      <summary>
            The computation state of a graph algorithm
            </summary>
    </member>
    <member name="F:QuickGraph.Algorithms.ComputationState.NotRunning">
      <summary>
            The algorithm is not running
            </summary>
    </member>
    <member name="F:QuickGraph.Algorithms.ComputationState.Running">
      <summary>
            The algorithm is running
            </summary>
    </member>
    <member name="F:QuickGraph.Algorithms.ComputationState.PendingAbortion">
      <summary>
            An abort has been requested. The algorithm is still running and will cancel as soon as it checks
            the cancelation state
            </summary>
    </member>
    <member name="F:QuickGraph.Algorithms.ComputationState.Finished">
      <summary>
            The computation is finished succesfully.
            </summary>
    </member>
    <member name="F:QuickGraph.Algorithms.ComputationState.Aborted">
      <summary>
            The computation was aborted
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.ConnectedComponents.IncrementalConnectedComponentsAlgorithm`2.GetComponents">
      <summary>
            Gets a copy of the connected components. Key is the number of components,
            Value contains the vertex -&gt; component index map.
            </summary>
      <returns />
      <ensures csharp="Contract.Result&lt;System.Collections.Generic.KeyValuePair&lt;int, System.Collections.Generic.IDictionary&lt;TVertex, int&gt;&gt;&gt;().Key == this.ComponentCount" vb="Contract.Result(Of System.Collections.Generic.KeyValuePair(Of Integer, System.Collections.Generic.IDictionary(Of TVertex, Integer)))().Key = Me.ComponentCount">result.Key == this.ComponentCount</ensures>
      <ensures csharp="Contract.Result&lt;System.Collections.Generic.KeyValuePair&lt;int, System.Collections.Generic.IDictionary&lt;TVertex, int&gt;&gt;&gt;().Value.Count == this.VisitedGraph.VertexCount" vb="Contract.Result(Of System.Collections.Generic.KeyValuePair(Of Integer, System.Collections.Generic.IDictionary(Of TVertex, Integer)))().Value.Count = Me.VisitedGraph.VertexCount">result.Value.Count == this.VisitedGraph.VertexCount</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.ConnectedComponents.StronglyConnectedComponentsAlgorithm`2.FinishVertex(`0)">
      <summary>
            Used internally
            </summary>
    </member>
    <member name="T:QuickGraph.Algorithms.LengauerTarjanDominatorAlgorithm`2">
      <summary>
            Computes the dominator map of a directed graph
            </summary>
      <remarks>
            Thomas Lengauer and Robert Endre Tarjan
            A fast algorithm for finding dominators in a flowgraph
            ACM Transactions on Programming Language and Systems, 1(1):121-141, 1979. 
            </remarks>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.Algorithms.MaximumFlow.BipartiteToMaximumFlowGraphAugmentorAlgorithm`2">
      <summary>
            This algorithm modifies a bipartite graph into a related graph, where each Vertex in one partition is 
            connected to a newly added "SuperSource" and each Vertex in the other partition is connected to a newly added "SuperSink"
            When the maximum flow of this related graph is computed, the edges used for the flow are also those which make up
            the maximum match for the bipartite graph.
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="T:QuickGraph.Algorithms.MaximumFlow.EdmondsKarpMaximumFlowAlgorithm`2">
      <summary>
            Edmond and Karp maximum flow algorithm
            for directed graph with positive capacities and
            flows.
            </summary>
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.EdmondsKarpMaximumFlowAlgorithm`2.InternalCompute">
      <summary>
            Computes the maximum flow between Source and Sink.
            </summary>
      <returns />
    </member>
    <member name="T:QuickGraph.Algorithms.MaximumFlow.MaximumFlowAlgorithm`2">
      <summary>
            Abstract base class for maximum flow algorithms.
            </summary>
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.UndirectedVertexDistanceRecorderObserver`2">
      <summary>
            A distance recorder for undirected tree builder algorithms
            </summary>
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.UndirectedVertexPredecessorRecorderObserver`2">
      <summary />
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="boost" />
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.VertexPredecessorPathRecorderObserver`2">
      <summary />
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="boost" />
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.IObserver`1">
      <summary>
            An algorithm observer
            </summary>
      <typeparam name="TAlgorithm">type of the algorithm</typeparam>
      <reference-ref id="gof02designpatterns" />
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)">
      <summary>
            Attaches to the algorithm events
            and returns a disposable object that can be used
            to detach from the events
            </summary>
      <param name="algorithm" />
      <returns />
      <requires csharp="(object)algorithm != null" vb="((Object)algorithm) &lt;&gt; Nothing">(object)algorithm != null</requires>
      <ensures csharp="Contract.Result&lt;System.IDisposable&gt;() != null" vb="Contract.Result(Of System.IDisposable)() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.VertexRecorderObserver`2">
      <summary />
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="boost" />
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.VertexDistanceRecorderObserver`2">
      <summary>
            A distance recorder for directed tree builder algorithms
            </summary>
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.EdgePredecessorRecorderObserver`2">
      <summary />
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="boost" />
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.EdgeRecorderObserver`2">
      <summary />
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="boost" />
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.VertexPredecessorRecorderObserver`2">
      <summary />
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="boost" />
    </member>
    <member name="T:QuickGraph.Algorithms.Observers.VertexTimeStamperObserver`2">
      <summary />
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="boost" />
    </member>
    <member name="T:QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm`2">
      <summary>
            Hoffman and Pavley K-shortest path algorithm.
            </summary>
      <remarks>
            Reference:
            Hoffman, W. and Pavley, R. 1959. A Method for the Solution of the Nth Best Path Problem. 
            J. ACM 6, 4 (Oct. 1959), 506-514. DOI= http://doi.acm.org/10.1145/320998.321004
            </remarks>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.Algorithms.Search.BestFirstFrontierSearchAlgorithm`2">
      <summary>
            Best first frontier search
            </summary>
      <remarks>
            Algorithm from Frontier Search, Korkf, Zhand, Thayer, Hohwald.
            </remarks>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2">
      <summary>
            A depth first search algorithm for directed graph
            </summary>
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="gross98graphtheory" chapter="4.2" />
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.#ctor(QuickGraph.IUndirectedGraph{`0,`1})">
      <summary>
            Initializes a new instance of the algorithm.
            </summary>
      <param name="visitedGraph">visited graph</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.#ctor(QuickGraph.IUndirectedGraph{`0,`1},System.Collections.Generic.IDictionary{`0,QuickGraph.GraphColor})">
      <summary>
            Initializes a new instance of the algorithm.
            </summary>
      <param name="visitedGraph">visited graph</param>
      <param name="colors">vertex color map</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IUndirectedGraph{`0,`1},System.Collections.Generic.IDictionary{`0,QuickGraph.GraphColor})">
      <summary>
            Initializes a new instance of the algorithm.
            </summary>
      <param name="host">algorithm host</param>
      <param name="visitedGraph">visited graph</param>
      <param name="colors">vertex color map</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IUndirectedGraph{`0,`1},System.Collections.Generic.IDictionary{`0,QuickGraph.GraphColor},System.Func{System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`1}})">
      <summary>
            Initializes a new instance of the algorithm.
            </summary>
      <param name="host">algorithm host</param>
      <param name="visitedGraph">visited graph</param>
      <param name="colors">vertex color map</param>
      <param name="adjacentEdgeEnumerator">
            Delegate that takes the enumeration of out-edges and reorders
            them. All vertices passed to the method should be enumerated once and only once.
            May be null.
            </param>
      <requires csharp="colors != null" vb="colors &lt;&gt; Nothing">colors != null</requires>
      <requires csharp="adjacentEdgeEnumerator != null" vb="adjacentEdgeEnumerator &lt;&gt; Nothing">adjacentEdgeEnumerator != null</requires>
    </member>
    <member name="T:QuickGraph.Algorithms.Search.BidirectionalDepthFirstSearchAlgorithm`2">
      <summary>
            A depth and height first search algorithm for directed graphs
            </summary>
      <remarks>
            This is a modified version of the classic DFS algorithm
            where the search is performed both in depth and height.
            </remarks>
      <reference-ref idref="gross98graphtheory" chapter="4.2" />
    </member>
    <member name="T:QuickGraph.Algorithms.Search.BreadthFirstSearchAlgorithm`2">
      <summary>
            A breath first search algorithm for directed graphs
            </summary>
      <reference-ref idref="gross98graphtheory" chapter="4.2" />
    </member>
    <member name="T:QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm`2">
      <summary>
            A depth first search algorithm for directed graph
            </summary>
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="gross98graphtheory" chapter="4.2" />
      <invariant>this.MaxDepth &gt; 0</invariant>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm`2.#ctor(QuickGraph.IVertexListGraph{`0,`1})">
      <summary>
            Initializes a new instance of the algorithm.
            </summary>
      <param name="visitedGraph">visited graph</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm`2.#ctor(QuickGraph.IVertexListGraph{`0,`1},System.Collections.Generic.IDictionary{`0,QuickGraph.GraphColor})">
      <summary>
            Initializes a new instance of the algorithm.
            </summary>
      <param name="visitedGraph">visited graph</param>
      <param name="colors">vertex color map</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IVertexListGraph{`0,`1})">
      <summary>
            Initializes a new instance of the algorithm.
            </summary>
      <param name="host">algorithm host</param>
      <param name="visitedGraph">visited graph</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IVertexListGraph{`0,`1},System.Collections.Generic.IDictionary{`0,QuickGraph.GraphColor})">
      <summary>
            Initializes a new instance of the algorithm.
            </summary>
      <param name="host">algorithm host</param>
      <param name="visitedGraph">visited graph</param>
      <param name="colors">vertex color map</param>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IVertexListGraph{`0,`1},System.Collections.Generic.IDictionary{`0,QuickGraph.GraphColor},System.Func{System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`1}})">
      <summary>
            Initializes a new instance of the algorithm.
            </summary>
      <param name="host">algorithm host</param>
      <param name="visitedGraph">visited graph</param>
      <param name="colors">vertex color map</param>
      <param name="outEdgeEnumerator">
            Delegate that takes the enumeration of out-edges and reorders
            them. All vertices passed to the method should be enumerated once and only once.
            May be null.
            </param>
      <requires csharp="colors != null" vb="colors &lt;&gt; Nothing">colors != null</requires>
      <requires csharp="outEdgeEnumerator != null" vb="outEdgeEnumerator &lt;&gt; Nothing">outEdgeEnumerator != null</requires>
    </member>
    <member name="T:QuickGraph.Algorithms.Search.EdgeDepthFirstSearchAlgorithm`2">
      <summary>
            A edge depth first search algorithm for directed graphs
            </summary>
      <remarks>
            This is a variant of the classic DFS algorithm where the
            edges are color marked instead of the vertices.
            </remarks>
      <reference-ref idref="gross98graphtheory" chapter="4.2" />
    </member>
    <member name="T:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2">
      <summary>
            A depth first search algorithm for implicit directed graphs
            </summary>
      <reference-ref idref="gross98graphtheory" chapter="4.2" />
    </member>
    <member name="P:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.VertexColors">
      <summary>
            Gets the vertex color map
            </summary>
      <value>
            Vertex color (<see cref="T:QuickGraph.GraphColor" />) dictionary
            </value>
    </member>
    <member name="P:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.MaxDepth">
      <summary>
            Gets or sets the maximum exploration depth, from
            the start vertex.
            </summary>
      <remarks>
            Defaulted at <c>int.MaxValue</c>.
            </remarks>
      <value>
            Maximum exploration depth.
            </value>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.StartVertex">
      <summary>
            Invoked on the source vertex once before the start of the search. 
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.OnStartVertex(`0)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.StartVertex" /> event.
            </summary>
      <param name="v">vertex that raised the event</param>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.DiscoverVertex">
      <summary>
            Invoked when a vertex is encountered for the first time. 
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.OnDiscoverVertex(`0)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.DiscoverVertex" /> event.
            </summary>
      <param name="v">vertex that raised the event</param>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.ExamineEdge">
      <summary>
            Invoked on every out-edge of each vertex after it is discovered. 
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.OnExamineEdge(`1)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.ExamineEdge" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.TreeEdge">
      <summary>
            Invoked on each edge as it becomes a member of the edges that form 
            the search tree. If you wish to record predecessors, do so at this 
            event point. 
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.OnTreeEdge(`1)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.TreeEdge" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.BackEdge">
      <summary>
            Invoked on the back edges in the graph. 
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.OnBackEdge(`1)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.BackEdge" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.ForwardOrCrossEdge">
      <summary>
            Invoked on forward or cross edges in the graph. 
            (In an undirected graph this method is never called.) 
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.OnForwardOrCrossEdge(`1)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.ForwardOrCrossEdge" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.FinishVertex">
      <summary>
            Invoked on a vertex after all of its out edges have been added to 
            the search tree and all of the adjacent vertices have been 
            discovered (but before their out-edges have been examined). 
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.OnFinishVertex(`0)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.Search.ImplicitDepthFirstSearchAlgorithm`2.FinishVertex" /> event.
            </summary>
      <param name="v">vertex that raised the event</param>
    </member>
    <member name="T:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2">
      <summary>
            A edge depth first search algorithm for implicit directed graphs
            </summary>
      <remarks>
            This is a variant of the classic DFS where the edges are color
            marked.
            </remarks>
      <reference-ref idref="gross98graphtheory" chapter="4.2" />
    </member>
    <member name="P:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.EdgeColors">
      <summary>
            Gets the vertex color map
            </summary>
      <value>
            Vertex color (<see cref="T:QuickGraph.GraphColor" />) dictionary
            </value>
    </member>
    <member name="P:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.MaxDepth">
      <summary>
            Gets or sets the maximum exploration depth, from
            the start vertex.
            </summary>
      <remarks>
            Defaulted at <c>int.MaxValue</c>.
            </remarks>
      <value>
            Maximum exploration depth.
            </value>
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.StartVertex">
      <summary>
            Invoked on the source vertex once before the start of the search. 
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.OnStartVertex(`0)">
      <summary>
            Triggers the StartVertex event.
            </summary>
      <param name="v" />
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.StartEdge">
      <summary>
            Invoked on the first edge of a test case
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.OnStartEdge(`1)">
      <summary>
            Triggers the StartEdge event.
            </summary>
      <param name="e" />
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.DiscoverTreeEdge">
      <summary />
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.OnDiscoverTreeEdge(`1,`1)">
      <summary>
            Triggers DiscoverEdge event
            </summary>
      <param name="se" />
      <param name="e" />
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.TreeEdge">
      <summary>
            Invoked on each edge as it becomes a member of the edges that form 
            the search tree. If you wish to record predecessors, do so at this 
            event point. 
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.OnTreeEdge(`1)">
      <summary>
            Triggers the TreeEdge event.
            </summary>
      <param name="e" />
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.BackEdge">
      <summary>
            Invoked on the back edges in the graph. 
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.OnBackEdge(`1)">
      <summary>
            Triggers the BackEdge event.
            </summary>
      <param name="e" />
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.ForwardOrCrossEdge">
      <summary>
            Invoked on forward or cross edges in the graph. 
            (In an undirected graph this method is never called.) 
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.OnForwardOrCrossEdge(`1)">
      <summary>
            Triggers the ForwardOrCrossEdge event.
            </summary>
      <param name="e" />
    </member>
    <member name="E:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.FinishEdge">
      <summary>
            Invoked on a edge after all of its out edges have been added to 
            the search tree and all of the adjacent vertices have been 
            discovered (but before their out-edges have been examined). 
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.OnFinishEdge(`1)">
      <summary>
            Triggers the ForwardOrCrossEdge event.
            </summary>
      <param name="e" />
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.Visit(`1,System.Int32)">
      <summary>
            Does a depth first search on the vertex u
            </summary>
      <param name="se">edge to explore</param>
      <param name="depth">current exploration depth</param>
      <exception cref="T:System.ArgumentNullException">se cannot be null</exception>
      <requires csharp="(object)se != null" vb="((Object)se) &lt;&gt; Nothing">(object)se != null</requires>
      <requires csharp="depth &gt;= 0" vb="depth &gt;= 0">depth &gt;= 0</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.ImplicitEdgeDepthFirstSearchAlgorithm`2.Initialize">
      <summary>
            Initializes the algorithm before computation.
            </summary>
    </member>
    <member name="T:QuickGraph.Algorithms.Search.UndirectedBreadthFirstSearchAlgorithm`2">
      <summary>
            A breath first search algorithm for undirected graphs
            </summary>
      <reference-ref idref="gross98graphtheory" chapter="4.2" />
    </member>
    <member name="T:QuickGraph.Algorithms.Services.IAlgorithmServices">
      <summary>
            Common services available to algorithm instances
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.Services.ICancelManager.CancelRequested">
      <summary>
            Raised when the cancel method is called
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.Services.ICancelManager.Cancel">
      <summary>
            Requests the component to cancel its computation
            </summary>
    </member>
    <member name="P:QuickGraph.Algorithms.Services.ICancelManager.IsCancelling">
      <summary>
            Gets a value indicating if a cancellation request is pending.
            </summary>
      <returns />
    </member>
    <member name="E:QuickGraph.Algorithms.Services.ICancelManager.CancelReseted">
      <summary>
            Raised when the cancel state has been reseted
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.Services.ICancelManager.ResetCancel">
      <summary>
            Resets the cancel state
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.Services.CancelManager.CancelReseted">
      <summary>
            Raised when the cancel state has been reseted
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.Services.CancelManager.ResetCancel">
      <summary>
            Resets the cancel state
            </summary>
    </member>
    <member name="T:QuickGraph.Algorithms.Services.IService">
      <summary>
            Interface implemented by graph services
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IMutableVertexAndEdgeListGraph{`0,`1})">
      <summary>
            Construct an eulerian trail builder
            </summary>
      <param name="host" />
      <param name="visitedGraph" />
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.Visit">
      <summary>
            Looks for a new path to add to the current vertex.
            </summary>
      <returns>true if found a new path, false otherwize</returns>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.ComputeEulerianPathCount(QuickGraph.IVertexAndEdgeListGraph{`0,`1})">
      <summary>
            Computes the number of eulerian trail in the graph.
            </summary>
      <param name="g" />
      <returns>number of eulerian trails</returns>
      <requires csharp="g != null" vb="g &lt;&gt; Nothing">g != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.CircuitAugmentation">
      <summary>
            Merges the temporary circuit with the current circuit
            </summary>
      <returns>true if all the graph edges are in the circuit</returns>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.AddTemporaryEdges(QuickGraph.EdgeFactory{`0,`1})">
      <summary>
            Adds temporary edges to the graph to make all vertex even.
            </summary>
      <param name="edgeFactory" />
      <returns />
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.RemoveTemporaryEdges">
      <summary>
            Removes temporary edges
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.Trails">
      <summary>
            Computes the set of eulerian trails that traverse the edge set.
            </summary>
      <remarks>
            This method returns a set of disjoint eulerian trails. This set
            of trails spans the entire set of edges.
            </remarks>
      <returns>Eulerian trail set</returns>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.Trails(`0)">
      <summary>
            Computes a set of eulerian trail, starting at <paramref name="s" />
            that spans the entire graph.
            </summary>
      <remarks>
        <para>
            This method computes a set of eulerian trail starting at <paramref name="s" />
            that spans the entire graph.The algorithm outline is as follows:
            </para>
        <para>
            The algorithms iterates throught the Eulerian circuit of the augmented
            graph (the augmented graph is the graph with additional edges to make
            the number of odd vertices even).
            </para>
        <para>
            If the current edge is not temporary, it is added to the current trail.
            </para>
        <para>
            If the current edge is temporary, the current trail is finished and
            added to the trail collection. The shortest path between the 
            start vertex <paramref name="s" /> and the target vertex of the
            temporary edge is then used to start the new trail. This shortest
            path is computed using the BreadthFirstSearchAlgorithm.
            </para>
      </remarks>
      <param name="s">start vertex</param>
      <returns>eulerian trail set, all starting at s</returns>
      <exception cref="T:System.ArgumentNullException">s is a null reference.</exception>
      <exception cref="T:System.Exception">Eulerian trail not computed yet.</exception>
      <requires csharp="(object)s != null" vb="((Object)s) &lt;&gt; Nothing">(object)s != null</requires>
    </member>
    <member name="T:QuickGraph.Algorithms.RandomWalks.CyclePoppingRandomTreeAlgorithm`2">
      <summary>
            Wilson-Propp Cycle-Popping Algorithm for Random Tree Generation.
            </summary>
    </member>
    <member name="P:QuickGraph.Algorithms.RandomWalks.CyclePoppingRandomTreeAlgorithm`2.Rnd">
      <summary>
            Gets or sets the random number generator used in <c>RandomTree</c>.
            </summary>
      <value>
        <see cref="T:System.Random" /> number generator
            </value>
      <setter>
        <requires csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      </setter>
    </member>
    <member name="T:QuickGraph.Algorithms.IDistanceRecorderAlgorithm`2">
      <summary>
            An algorithm that exposes events to compute a distance map between vertices
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.Algorithms.ShortestPath.AStarShortestPathAlgorithm`2">
      <summary>
            A* single-source shortest path algorithm for directed graph
            with positive distance.
            </summary>
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="lawler01combinatorial" />
    </member>
    <member name="T:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2">
      <summary>
            Bellman Ford shortest path algorithm.
            </summary>
      <remarks>
        <para>
            The Bellman-Ford algorithm solves the single-source shortest paths 
            problem for a graph with both positive and negative edge weights. 
            </para>
        <para>
            If you only need to solve the shortest paths problem for positive 
            edge weights, Dijkstra's algorithm provides a more efficient 
            alternative. 
            </para>
        <para>
            If all the edge weights are all equal to one then breadth-first search 
            provides an even more efficient alternative. 
            </para>
      </remarks>
      <reference-ref idref="shi03datastructures" />
    </member>
    <member name="P:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.FoundNegativeCycle">
      <summary>
            Indicates if a negative cycle was found
            </summary>
    </member>
    <member name="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.InitializeVertex">
      <summary>
            Invoked on each vertex in the graph before the start of the 
            algorithm.
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.OnInitializeVertex(`0)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.InitializeVertex" /> event.
            </summary>
      <param name="v">vertex that raised the event</param>
    </member>
    <member name="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.ExamineEdge">
      <summary>
            Invoked on every edge in the graph |V| times.
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.OnExamineEdge(`1)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.ExamineEdge" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
    </member>
    <member name="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.EdgeNotRelaxed">
      <summary>
             Invoked if the distance label for the target vertex is not 
             decreased.
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.OnEdgeNotRelaxed(`1)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.EdgeNotRelaxed" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
    </member>
    <member name="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.EdgeMinimized">
      <summary>
             Invoked during the second stage of the algorithm, 
             during the test of whether each edge was minimized. 
             
             If the edge is minimized then this function is invoked.
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.OnEdgeMinimized(`1)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.EdgeMinimized" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
    </member>
    <member name="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.EdgeNotMinimized">
      <summary>
            Invoked during the second stage of the algorithm, 
            during the test of whether each edge was minimized. 
            
            If the edge was not minimized, this function is invoked. 
            This happens when there is a negative cycle in the graph. 
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.OnEdgeNotMinimized(`1)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.EdgeNotMinimized" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
    </member>
    <member name="P:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.Predecessors">
      <summary>
            Constructed predecessor map
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.BellmanFordShortestPathAlgorithm`2.InternalCompute">
      <summary>
            Applies the Bellman Ford algorithm
            </summary>
      <remarks>
            Does not initialize the predecessor and distance map.
            </remarks>
    </member>
    <member name="E:QuickGraph.Algorithms.ShortestPath.UndirectedShortestPathAlgorithmBase`2.TreeEdge">
      <summary>
            Invoked when the distance label for the target vertex is decreased. 
            The edge that participated in the last relaxation for vertex v is 
            an edge in the shortest paths tree.
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.UndirectedShortestPathAlgorithmBase`2.OnTreeEdge(`1,System.Boolean)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.ShortestPath.UndirectedShortestPathAlgorithmBase`2.TreeEdge" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
      <param name="reversed" />
    </member>
    <member name="T:QuickGraph.Algorithms.ShortestPath.DagShortestPathAlgorithm`2">
      <summary>
            A single-source shortest path algorithm for directed acyclic
            graph.
            </summary>
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref id="boost" />
    </member>
    <member name="T:QuickGraph.Algorithms.ShortestPath.DijkstraShortestPathAlgorithm`2">
      <summary>
            Dijkstra single-source shortest path algorithm for directed graph
            with positive distance.
            </summary>
      <typeparam name="TVertex">type of a vertex</typeparam>
      <typeparam name="TEdge">type of an edge</typeparam>
      <reference-ref idref="lawler01combinatorial" />
    </member>
    <member name="T:QuickGraph.Algorithms.ShortestPath.FloydWarshallAllShortestPathAlgorithm`2">
      <summary>
            Floyd-Warshall all shortest path algorith,
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="E:QuickGraph.Algorithms.ShortestPath.ShortestPathAlgorithmBase`3.TreeEdge">
      <summary>
            Invoked when the distance label for the target vertex is decreased. 
            The edge that participated in the last relaxation for vertex v is 
            an edge in the shortest paths tree.
            </summary>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.ShortestPathAlgorithmBase`3.OnTreeEdge(`1)">
      <summary>
            Raises the <see cref="E:QuickGraph.Algorithms.ShortestPath.ShortestPathAlgorithmBase`3.TreeEdge" /> event.
            </summary>
      <param name="e">edge that raised the event</param>
    </member>
    <member name="T:QuickGraph.Algorithms.ShortestPath.UndirectedDijkstraShortestPathAlgorithm`2">
      <summary>
            A single-source shortest path algorithm for undirected graph
            with positive distance.
            </summary>
      <reference-ref idref="lawler01combinatorial" />
    </member>
    <member name="T:QuickGraph.Algorithms.TarjanOfflineLeastCommonAncestorAlgorithm`2">
      <summary>
            Offline least common ancestor in a rooted tre
            </summary>
      <remarks>
            Reference:
            Gabow, H. N. and Tarjan, R. E. 1983. A linear-time algorithm for a special case 
            of disjoint set union. In Proceedings of the Fifteenth Annual ACM Symposium 
            on theory of Computing STOC '83. ACM, New York, NY, 246-251. 
            DOI= http://doi.acm.org/10.1145/800061.808753 
            </remarks>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.ArrayAdjacencyGraph`2">
      <summary>
            An immutable directed graph data structure efficient for large sparse
            graph representation where out-edge need to be enumerated only.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.Clone">
      <summary>
            Returns self since this class is immutable
            </summary>
      <returns />
    </member>
    <member name="T:QuickGraph.BidirectionAdapterGraph`2">
      <summary>
            Wraps a vertex list graph (out-edges only) and caches the in-edge dictionary.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.Collections.BinaryHeap`2">
      <summary>
            Binary heap
            </summary>
      <remarks>
            Indexing rules:
            
            parent index: index ¡ 1)/2
            left child: 2 * index + 1
            right child: 2 * index + 2
            
            Reference:
            http://dotnetslackers.com/Community/files/folders/data-structures-and-algorithms/entry28722.aspx
            </remarks>
      <typeparam name="TValue">type of the value</typeparam>
      <typeparam name="TPriority">type of the priority metric</typeparam>
    </member>
    <member name="T:QuickGraph.Collections.ForestDisjointSet`1">
      <summary>
            Disjoint-set implementation with path compression and union-by-rank optimizations.
            optimization
            </summary>
      <typeparam name="T" />
      <invariant>this.setCount &gt;= 0</invariant>
      <invariant>this.setCount &lt;= this.elements.Count</invariant>
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.MakeSet(`0)">
      <summary>
            Adds a new set
            </summary>
      <param name="value" />
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.MakeSet(`0)" inheritedFromTypeName="IDisjointSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)value != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)value) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)value != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.MakeSet(`0)" inheritedFromTypeName="IDisjointSet" csharp="!this.Contains(value)" vb="Not Me.Contains(value)">!this.Contains(value)</requires>
      <ensures inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.MakeSet(`0)" inheritedFromTypeName="IDisjointSet" csharp="this.Contains(value)" vb="Me.Contains(value)">this.Contains(value)</ensures>
      <ensures inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.MakeSet(`0)" inheritedFromTypeName="IDisjointSet" csharp="this.SetCount == Contract.Old(this.SetCount) + 1" vb="Me.SetCount = Contract.Old(Me.SetCount) + 1">this.SetCount == old(this.SetCount) + 1</ensures>
      <ensures inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.MakeSet(`0)" inheritedFromTypeName="IDisjointSet" csharp="this.ElementCount == Contract.Old(this.ElementCount) + 1" vb="Me.ElementCount = Contract.Old(Me.ElementCount) + 1">this.ElementCount == old(this.ElementCount) + 1</ensures>
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.Find(QuickGraph.Collections.ForestDisjointSet{`0}.Element)">
      <summary>
            Finds the parent element, and applies path compression
            </summary>
      <param name="element" />
      <returns />
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <ensures csharp="Contract.Result&lt;QuickGraph.Collections.ForestDisjointSet&lt;T&gt;.Element&gt;() != null" vb="Contract.Result(Of QuickGraph.Collections.ForestDisjointSet(Of T).Element)() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:QuickGraph.Collections.HeapDirection">
      <summary>
            Specifies the order in which a Heap will Dequeue items.
            </summary>
    </member>
    <member name="F:QuickGraph.Collections.HeapDirection.Increasing">
      <summary>
            Items are Dequeued in Increasing order from least to greatest.
            </summary>
    </member>
    <member name="F:QuickGraph.Collections.HeapDirection.Decreasing">
      <summary>
            Items are Dequeued in Decreasing order, from greatest to least.
            </summary>
    </member>
    <member name="M:QuickGraph.Collections.LambdaHelpers.ForEach``1(System.Collections.Generic.IList{``0},System.Action{``0})">
      <summary>
            Performs an action on each item in a list, used to shortcut a "foreach" loop
            </summary>
      <typeparam name="T">Type contained in List</typeparam>
      <param name="collection">List to enumerate over</param>
      <param name="action">Lambda Function to be performed on all elements in List</param>
    </member>
    <member name="M:QuickGraph.Collections.LambdaHelpers.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Performs an action on each item in a list, used to shortcut a "foreach" loop
            </summary>
      <typeparam name="T">Type contained in List</typeparam>
      <param name="collection">List to enumerate over</param>
      <param name="action">Lambda Function to be performed on all elements in List</param>
    </member>
    <member name="F:QuickGraph.Collections.FibonacciHeapCell`2.Marked">
      <summary>
            Determines of a Node has had a child cut from it before
            </summary>
    </member>
    <member name="F:QuickGraph.Collections.FibonacciHeapCell`2.Degree">
      <summary>
            Determines the depth of a node
            </summary>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeap`2.UpdateNodesDegree(QuickGraph.Collections.FibonacciHeapCell{`0,`1})">
      <summary>
            Updates the degree of a node, cascading to update the degree of the
            parents if nessecary
            </summary>
      <param name="parentNode" />
      <requires csharp="parentNode != null" vb="parentNode &lt;&gt; Nothing">parentNode != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeap`2.UpdateNext">
      <summary>
            Updates the Next pointer, maintaining the heap
            by folding duplicate heap degrees into eachother
            Takes O(lg(N)) time amortized
            </summary>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeap`2.ReduceNodes(QuickGraph.Collections.FibonacciHeapCell{`0,`1},QuickGraph.Collections.FibonacciHeapCell{`0,`1})">
      <summary>
            Given two nodes, adds the child node as a child of the parent node
            </summary>
      <param name="parentNode" />
      <param name="childNode" />
      <requires csharp="parentNode != null" vb="parentNode &lt;&gt; Nothing">parentNode != null</requires>
      <requires csharp="childNode != null" vb="childNode &lt;&gt; Nothing">childNode != null</requires>
    </member>
    <member name="T:QuickGraph.Collections.IDisjointSet`1">
      <summary>
            A disjoint-set data structure
            </summary>
      <typeparam name="T" />
    </member>
    <member name="P:QuickGraph.Collections.IDisjointSet`1.SetCount">
      <summary>
            Gets the current number of sets
            </summary>
    </member>
    <member name="P:QuickGraph.Collections.IDisjointSet`1.ElementCount">
      <summary>
            Gets the current number of elements.
            </summary>
    </member>
    <member name="M:QuickGraph.Collections.IDisjointSet`1.MakeSet(`0)">
      <summary>
            Creates a new set for the value
            </summary>
      <param name="value" />
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)value != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)value) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)value != null; })()</requires>
      <requires csharp="!this.Contains(value)" vb="Not Me.Contains(value)">!this.Contains(value)</requires>
      <ensures csharp="this.Contains(value)" vb="Me.Contains(value)">this.Contains(value)</ensures>
      <ensures csharp="this.SetCount == Contract.Old(this.SetCount) + 1" vb="Me.SetCount = Contract.Old(Me.SetCount) + 1">this.SetCount == old(this.SetCount) + 1</ensures>
      <ensures csharp="this.ElementCount == Contract.Old(this.ElementCount) + 1" vb="Me.ElementCount = Contract.Old(Me.ElementCount) + 1">this.ElementCount == old(this.ElementCount) + 1</ensures>
    </member>
    <member name="M:QuickGraph.Collections.IDisjointSet`1.FindSet(`0)">
      <summary>
            Finds the set containing the value
            </summary>
      <param name="value" />
      <returns />
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)value != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)value) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)value != null; })()</requires>
      <requires csharp="this.Contains(value)" vb="Me.Contains(value)">this.Contains(value)</requires>
    </member>
    <member name="M:QuickGraph.Collections.IDisjointSet`1.AreInSameSet(`0,`0)">
      <summary>
            Gets a value indicating if left and right are contained in the same set
            </summary>
      <param name="left" />
      <param name="right" />
      <returns />
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)left != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)left) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)left != null; })()</requires>
      <requires csharp="(object)right != null" vb="((Object)right) &lt;&gt; Nothing">(object)right != null</requires>
      <requires csharp="this.Contains(left)" vb="Me.Contains(left)">this.Contains(left)</requires>
      <requires csharp="this.Contains(right)" vb="Me.Contains(right)">this.Contains(right)</requires>
    </member>
    <member name="M:QuickGraph.Collections.IDisjointSet`1.Union(`0,`0)">
      <summary>
            Merges the sets from the two values
            </summary>
      <param name="left" />
      <param name="right" />
      <returns>true if left and right were unioned, false if they already belong to the same set</returns>
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)left != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)left) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)left != null; })()</requires>
      <requires csharp="this.Contains(left)" vb="Me.Contains(left)">this.Contains(left)</requires>
      <requires csharp="(object)right != null" vb="((Object)right) &lt;&gt; Nothing">(object)right != null</requires>
      <requires csharp="this.Contains(right)" vb="Me.Contains(right)">this.Contains(right)</requires>
    </member>
    <member name="M:QuickGraph.Collections.IDisjointSet`1.Contains(`0)">
      <summary>
            Gets a value indicating whether the value is in the data structure
            </summary>
      <param name="value" />
      <returns />
      <pure />
    </member>
    <member name="T:QuickGraph.Collections.IEdgeList`2">
      <summary>
            A cloneable list of edges
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="M:QuickGraph.Collections.IEdgeList`2.TrimExcess">
      <summary>
            Trims excess allocated space
            </summary>
    </member>
    <member name="M:QuickGraph.Collections.IEdgeList`2.Clone">
      <summary>
            Gets a clone of this list
            </summary>
      <returns />
      <ensures csharp="Contract.Result&lt;QuickGraph.Collections.IEdgeList&lt;TVertex, TEdge&gt;&gt;() != null" vb="Contract.Result(Of QuickGraph.Collections.IEdgeList(Of TVertex, TEdge))() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:QuickGraph.Collections.IVertexEdgeDictionary`2">
      <summary>
            A dictionary of vertices to a list of edges
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="M:QuickGraph.Collections.IVertexEdgeDictionary`2.Clone">
      <summary>
            Gets a clone of the dictionary. The vertices and edges are not cloned.
            </summary>
      <returns />
      <ensures csharp="Contract.Result&lt;QuickGraph.Collections.IVertexEdgeDictionary&lt;TVertex, TEdge&gt;&gt;() != null" vb="Contract.Result(Of QuickGraph.Collections.IVertexEdgeDictionary(Of TVertex, TEdge))() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:QuickGraph.CompressedSparseRowGraph`1">
      <summary>
            Directed graph representation using a Compressed Sparse Row representation
            (http://www.cs.utk.edu/~dongarra/etemplates/node373.html)
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
    </member>
    <member name="T:QuickGraph.Contracts.GraphContract">
      <summary>
            Debug only assertions and assumptions
            </summary>
    </member>
    <member name="T:QuickGraph.ArrayUndirectedGraph`2">
      <summary>
            An immutable undirected graph data structure based on arrays.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.Clone">
      <summary>
            Returns self
            </summary>
      <returns />
    </member>
    <member name="T:QuickGraph.ArrayBidirectionalGraph`2">
      <summary>
            An immutable directed graph data structure efficient for large sparse
            graph representation where out-edge need to be enumerated only.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.#ctor(QuickGraph.IBidirectionalGraph{`0,`1})">
      <summary>
            Constructs a new ArrayBidirectionalGraph instance from a 
            IBidirectionalGraph instance
            </summary>
      <param name="visitedGraph" />
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.Clone">
      <summary>
            Returns self since this class is immutable
            </summary>
      <returns />
    </member>
    <member name="T:QuickGraph.DelegateBidirectionalIncidenceGraph`2">
      <summary>
            A delegate based bidirectional implicit graph
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="T:QuickGraph.DelegateImplicitUndirectedGraph`2">
      <summary>
            A functional implicit undirected graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.DelegateIncidenceGraph`2">
      <summary>
            A delegate-based incidence graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.DelegateUndirectedGraph`2">
      <summary>
            A functional implicit undirected graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.DelegateImplicitGraph`2">
      <summary>
            A delegate-based implicit graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.DelegateVertexAndEdgeListGraph`2">
      <summary>
            A delegate-based incidence graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.IBidirectionalIncidenceGraph`2">
      <summary>
            A directed graph datastructure that is efficient
            to traverse both in and out edges.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
    </member>
    <member name="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)">
      <summary>
            Determines whether <paramref name="v" /> has no in-edges.
            </summary>
      <param name="v">The vertex</param>
      <returns>
        <c>true</c> if <paramref name="v" /> has no in-edges; otherwise, <c>false</c>.
            </returns>
      <pure />
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures csharp="Contract.Result&lt;bool&gt;() == this.InDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.InDegree(v) = 0">result == this.InDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)">
      <summary>
            Gets the number of in-edges of <paramref name="v" /></summary>
      <param name="v">The vertex.</param>
      <returns>The number of in-edges pointing towards <paramref name="v" /></returns>
      <pure />
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.InEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.InEdges(v))">result == decimal.Count&lt;decimal&gt;(this.InEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)">
      <summary>
            Gets the collection of in-edges of <paramref name="v" />.
            </summary>
      <param name="v">The vertex</param>
      <returns>The collection of in-edges of <paramref name="v" /></returns>
      <pure />
      <requires csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))() &lt;&gt; Nothing">result != null</ensures>
      <ensures csharp="decimal.All&lt;decimal&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;(), delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))(), delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    Return edge.Target.Equals(((Object)v))
    Return False
})">decimal.All&lt;decimal&gt;(result, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <summary>
            Tries to get the in-edges of <paramref name="v" /></summary>
      <param name="v" />
      <param name="edges" />
      <returns />
      <pure />
      <requires csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures csharp="Contract.Result&lt;bool&gt;() == this.ContainsVertex(v)" vb="Contract.Result(Of Boolean )() = Me.ContainsVertex(v)">result == this.ContainsVertex(v)</ensures>
      <ensures csharp="!Contract.Result&lt;bool&gt;() || edges != null" vb="Not Contract.Result(Of Boolean )() OrElse edges &lt;&gt; Nothing">!result || edges != null</ensures>
      <ensures csharp="!Contract.Result&lt;bool&gt;() || decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})" vb="Not Contract.Result(Of Boolean )() OrElse System.Linq.Enumerable.All(edges, delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    Return edge.Target.Equals(((Object)v))
    Return False
})">!result || decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)">
      <summary>
            Gets the in-edge at location <paramref name="index" />.
            </summary>
      <param name="v">The vertex.</param>
      <param name="index">The index.</param>
      <returns />
      <pure />
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires csharp="index &gt;= 0 &amp;&amp; index &lt; this.InDegree(v)" vb="index &gt;= 0 AndAlso index &lt; Me.InDegree(v)">index &gt;= 0 &amp;&amp; index &lt; this.InDegree(v)</requires>
      <ensures csharp="Contract.Result&lt;decimal&gt;().Equals((object)decimal.ElementAt&lt;decimal&gt;(this.InEdges(v), index))" vb="Contract.Result(Of TEdge)().Equals(((Object)System.Linq.Enumerable.ElementAt(Me.InEdges(v), index)))">result.Equals((object)decimal.ElementAt&lt;decimal&gt;(this.InEdges(v), index))</ensures>
    </member>
    <member name="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)">
      <summary>
            Gets the degree of <paramref name="v" />, i.e.
            the sum of the out-degree and in-degree of <paramref name="v" />.
            </summary>
      <param name="v">The vertex</param>
      <returns>The sum of OutDegree and InDegree of <paramref name="v" /></returns>
      <pure />
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures csharp="Contract.Result&lt;int&gt;() == this.InDegree(v) + this.OutDegree(v)" vb="Contract.Result(Of Integer )() = Me.InDegree(v) + Me.OutDegree(v)">result == this.InDegree(v) + this.OutDegree(v)</ensures>
    </member>
    <member name="T:QuickGraph.TaggedUndirectedEdge`2">
      <summary>
            A tagged undirected edge.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TTag">Type type of the tag</typeparam>
    </member>
    <member name="M:QuickGraph.TaggedUndirectedEdge`2.#ctor(`0,`0,`1)">
      <summary>
            Initializes a new instance of the <see cref="T:QuickGraph.TaggedUndirectedEdge`2" /> class.
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <param name="tag">the tag</param>
    </member>
    <member name="E:QuickGraph.TaggedUndirectedEdge`2.TagChanged">
      <summary>
            Raised when the tag is changed
            </summary>
    </member>
    <member name="P:QuickGraph.TaggedUndirectedEdge`2.Tag">
      <summary>
            Gets or sets the tag
            </summary>
    </member>
    <member name="M:QuickGraph.TaggedUndirectedEdge`2.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="T:QuickGraph.SUndirectedTaggedEdge`2">
      <summary>
            An struct based <see cref="T:QuickGraph.IUndirectedEdge`1" /> implementation.
            </summary>
      <typeparam name="TVertex">type of the vertex.</typeparam>
      <typeparam name="TTag">type of the tag</typeparam>
    </member>
    <member name="M:QuickGraph.SUndirectedTaggedEdge`2.#ctor(`0,`0,`1)">
      <summary>
            Initializes a new instance of the <see cref="T:QuickGraph.SUndirectedTaggedEdge`2" /> class.
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <param name="tag">The tag.</param>
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires csharp="System.Collections.Generic.Comparer&lt;TVertex&gt;.Default.Compare(source, target) &lt;= 0" vb="System.Collections.Generic.Comparer(Of TVertex).Default.Compare(source, target) &lt;= 0">System.Collections.Generic.Comparer&lt;TVertex&gt;.Default.Compare(source, target) &lt;= 0</requires>
      <ensures csharp="this.Source.Equals((object)source)" vb="Me.Source.Equals(((Object)source))">this.Source.Equals((object)source)</ensures>
      <ensures csharp="this.Target.Equals((object)target)" vb="Me.Target.Equals(((Object)target))">this.Target.Equals((object)target)</ensures>
    </member>
    <member name="P:QuickGraph.SUndirectedTaggedEdge`2.Source">
      <summary>
            Gets the source vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.SUndirectedTaggedEdge`2.Target">
      <summary>
            Gets the target vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.SUndirectedTaggedEdge`2.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="T:QuickGraph.ITagged`1">
      <summary>
            An instance holding a tag
            </summary>
      <typeparam name="TTag" />
    </member>
    <member name="P:QuickGraph.ITagged`1.Tag">
      <summary>
            Gets or sets the tag
            </summary>
    </member>
    <member name="E:QuickGraph.ITagged`1.TagChanged">
      <summary>
            Raised when the tag is changed
            </summary>
    </member>
    <member name="T:QuickGraph.SEquatableUndirectedEdge`1">
      <summary>
            An struct based <see cref="T:QuickGraph.IEdge`1" /> implementation.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
    </member>
    <member name="M:QuickGraph.SEquatableUndirectedEdge`1.#ctor(`0,`0)">
      <summary>
            Initializes a new instance of the <see cref="T:QuickGraph.SEdge`1" /> class.
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires csharp="System.Collections.Generic.Comparer&lt;TVertex&gt;.Default.Compare(source, target) &lt;= 0" vb="System.Collections.Generic.Comparer(Of TVertex).Default.Compare(source, target) &lt;= 0">System.Collections.Generic.Comparer&lt;TVertex&gt;.Default.Compare(source, target) &lt;= 0</requires>
      <ensures csharp="this.Source.Equals((object)source)" vb="Me.Source.Equals(((Object)source))">this.Source.Equals((object)source)</ensures>
      <ensures csharp="this.Target.Equals((object)target)" vb="Me.Target.Equals(((Object)target))">this.Target.Equals((object)target)</ensures>
    </member>
    <member name="P:QuickGraph.SEquatableUndirectedEdge`1.Source">
      <summary>
            Gets the source vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.SEquatableUndirectedEdge`1.Target">
      <summary>
            Gets the target vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.SEquatableUndirectedEdge`1.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:QuickGraph.SEquatableUndirectedEdge`1.Equals(QuickGraph.SEquatableUndirectedEdge{`0})">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <param name="other">An object to compare with this object.</param>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
      <ensures csharp="Contract.Result&lt;bool&gt;() == (this.Source.Equals((object)other.Source) &amp;&amp; this.Target.Equals((object)other.Target))" vb="Contract.Result(Of Boolean )() = (Me.Source.Equals(((Object)other.Source)) AndAlso Me.Target.Equals(((Object)other.Target)))">result == (this.Source.Equals((object)other.Source) &amp;&amp; this.Target.Equals((object)other.Target))</ensures>
    </member>
    <member name="M:QuickGraph.SEquatableUndirectedEdge`1.Equals(System.Object)">
      <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
      <param name="obj">Another object to compare to.</param>
      <returns>
            true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
    </member>
    <member name="M:QuickGraph.SEquatableUndirectedEdge`1.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
    </member>
    <member name="T:QuickGraph.STaggedEdge`2">
      <summary>
            A tagged edge as value type.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TTag" />
    </member>
    <member name="M:QuickGraph.STaggedEdge`2.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="T:QuickGraph.STaggedEquatableEdge`2">
      <summary>
            A tagged edge as value type.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TTag" />
    </member>
    <member name="M:QuickGraph.STaggedEquatableEdge`2.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:QuickGraph.STaggedEquatableEdge`2.Equals(QuickGraph.STaggedEquatableEdge{`0,`1})">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <param name="other">An object to compare with this object.</param>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
      <ensures csharp="Contract.Result&lt;bool&gt;() == (this.Source.Equals((object)other.Source) &amp;&amp; this.Target.Equals((object)other.Target))" vb="Contract.Result(Of Boolean )() = (Me.Source.Equals(((Object)other.Source)) AndAlso Me.Target.Equals(((Object)other.Target)))">result == (this.Source.Equals((object)other.Source) &amp;&amp; this.Target.Equals((object)other.Target))</ensures>
    </member>
    <member name="M:QuickGraph.STaggedEquatableEdge`2.Equals(System.Object)">
      <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
      <param name="obj">Another object to compare to.</param>
      <returns>
            true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
    </member>
    <member name="M:QuickGraph.STaggedEquatableEdge`2.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
    </member>
    <member name="T:QuickGraph.TaggedEquatableEdge`2">
      <summary>
            An equatable, tagged, edge
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TTag" />
    </member>
    <member name="T:QuickGraph.UndirectedEdge`1">
      <summary>
            The default <see cref="T:QuickGraph.IUndirectedEdge`1" /> implementation.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
    </member>
    <member name="M:QuickGraph.UndirectedEdge`1.#ctor(`0,`0)">
      <summary>
            Initializes a new instance of the <see cref="T:QuickGraph.Edge`1" /> class.
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires csharp="System.Collections.Generic.Comparer&lt;TVertex&gt;.Default.Compare(source, target) &lt;= 0" vb="System.Collections.Generic.Comparer(Of TVertex).Default.Compare(source, target) &lt;= 0">System.Collections.Generic.Comparer&lt;TVertex&gt;.Default.Compare(source, target) &lt;= 0</requires>
      <ensures csharp="this.source.Equals((object)source)" vb="Me.source.Equals(((Object)source))">this.source.Equals((object)source)</ensures>
      <ensures csharp="this.target.Equals((object)target)" vb="Me.target.Equals(((Object)target))">this.target.Equals((object)target)</ensures>
    </member>
    <member name="P:QuickGraph.UndirectedEdge`1.Source">
      <summary>
            Gets the source vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.UndirectedEdge`1.Target">
      <summary>
            Gets the target vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.UndirectedEdge`1.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="T:QuickGraph.IUndirectedEdge`1">
      <summary>
            An undirected edge. 
            </summary>
      <remarks>
            Invariant: source must be less or equal to target (using the default comparer)
            </remarks>
      <typeparam name="TVertex">type of the vertices</typeparam>
    </member>
    <member name="T:QuickGraph.SEquatableEdge`1">
      <summary>
            An struct based <see cref="T:QuickGraph.IEdge`1" /> implementation.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
    </member>
    <member name="M:QuickGraph.SEquatableEdge`1.#ctor(`0,`0)">
      <summary>
            Initializes a new instance of the <see cref="T:QuickGraph.SEdge`1" /> class.
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <ensures csharp="this.Source.Equals((object)source)" vb="Me.Source.Equals(((Object)source))">this.Source.Equals((object)source)</ensures>
      <ensures csharp="this.Target.Equals((object)target)" vb="Me.Target.Equals(((Object)target))">this.Target.Equals((object)target)</ensures>
    </member>
    <member name="P:QuickGraph.SEquatableEdge`1.Source">
      <summary>
            Gets the source vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.SEquatableEdge`1.Target">
      <summary>
            Gets the target vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.SEquatableEdge`1.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:QuickGraph.SEquatableEdge`1.Equals(QuickGraph.SEquatableEdge{`0})">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <param name="other">An object to compare with this object.</param>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
      <ensures csharp="Contract.Result&lt;bool&gt;() == (this.Source.Equals((object)other.Source) &amp;&amp; this.Target.Equals((object)other.Target))" vb="Contract.Result(Of Boolean )() = (Me.Source.Equals(((Object)other.Source)) AndAlso Me.Target.Equals(((Object)other.Target)))">result == (this.Source.Equals((object)other.Source) &amp;&amp; this.Target.Equals((object)other.Target))</ensures>
    </member>
    <member name="M:QuickGraph.SEquatableEdge`1.Equals(System.Object)">
      <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
      <param name="obj">Another object to compare to.</param>
      <returns>
            true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
    </member>
    <member name="M:QuickGraph.SEquatableEdge`1.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.IsSelfEdge``2(``1)">
      <summary>
            Gets a value indicating if the edge is a self edge.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="edge" />
      <returns />
      <pure />
      <requires csharp="(object)edge != null" vb="((Object)edge) &lt;&gt; Nothing">(object)edge != null</requires>
      <ensures csharp="Contract.Result&lt;bool&gt;() == edge.Source.Equals((object)edge.Target)" vb="Contract.Result(Of Boolean )() = edge.Source.Equals(((Object)edge.Target))">result == edge.Source.Equals((object)edge.Target)</ensures>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.GetOtherVertex``2(``1,``0)">
      <summary>
            Given a source vertex, returns the other vertex in the edge
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="edge">must not be a self-edge</param>
      <param name="vertex" />
      <returns />
      <pure />
      <requires csharp="(object)edge != null" vb="((Object)edge) &lt;&gt; Nothing">(object)edge != null</requires>
      <requires csharp="(object)vertex != null" vb="((Object)vertex) &lt;&gt; Nothing">(object)vertex != null</requires>
      <requires csharp="!edge.Source.Equals((object)edge.Target)" vb="Not edge.Source.Equals(((Object)edge.Target))">!edge.Source.Equals((object)edge.Target)</requires>
      <requires csharp="edge.Source.Equals((object)vertex) || edge.Target.Equals((object)vertex)" vb="edge.Source.Equals(((Object)vertex)) OrElse edge.Target.Equals(((Object)vertex))">edge.Source.Equals((object)vertex) || edge.Target.Equals((object)vertex)</requires>
      <ensures csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      <ensures csharp="Contract.Result&lt;TVertex&gt;().Equals((object)(edge.Source.Equals((object)vertex) ? edge.Target : edge.Source))" vb="Contract.Result(Of TVertex)().Equals(((Object)edge.Source.Equals(((Object)vertex)) ? edge.Target : edge.Source))">result.Equals((object)(edge.Source.Equals((object)vertex) ? edge.Target : edge.Source))</ensures>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.IsAdjacent``2(``1,``0)">
      <summary>
            Gets a value indicating if <paramref name="vertex" /> is adjacent to <paramref name="edge" />
            (is the source or target).
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="edge" />
      <param name="vertex" />
      <returns />
      <pure />
      <requires csharp="(object)edge != null" vb="((Object)edge) &lt;&gt; Nothing">(object)edge != null</requires>
      <requires csharp="(object)vertex != null" vb="((Object)vertex) &lt;&gt; Nothing">(object)vertex != null</requires>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.ToVertexPair``2(``1)">
      <summary>
            Creates a vertex pair (source, target) from the edge
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="edge" />
      <returns />
      <requires csharp="(object)edge != null" vb="((Object)edge) &lt;&gt; Nothing">(object)edge != null</requires>
      <ensures csharp="Contract.Result&lt;QuickGraph.SEquatableEdge&lt;TVertex&gt;&gt;().Source.Equals((object)edge.Source)" vb="Contract.Result(Of QuickGraph.SEquatableEdge(Of TVertex))().Source.Equals(((Object)edge.Source))">result.Source.Equals((object)edge.Source)</ensures>
      <ensures csharp="Contract.Result&lt;QuickGraph.SEquatableEdge&lt;TVertex&gt;&gt;().Target.Equals((object)edge.Target)" vb="Contract.Result(Of QuickGraph.SEquatableEdge(Of TVertex))().Target.Equals(((Object)edge.Target))">result.Target.Equals((object)edge.Target)</ensures>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.IsPredecessor``2(System.Collections.Generic.IDictionary{``0,``1},``0,``0)">
      <summary>
            Checks that <paramref name="root" /> is a predecessor of <paramref name="vertex" /></summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="predecessors" />
      <param name="root" />
      <param name="vertex" />
      <returns />
      <requires csharp="predecessors != null" vb="predecessors &lt;&gt; Nothing">predecessors != null</requires>
      <requires csharp="(object)root != null" vb="((Object)root) &lt;&gt; Nothing">(object)root != null</requires>
      <requires csharp="(object)vertex != null" vb="((Object)vertex) &lt;&gt; Nothing">(object)vertex != null</requires>
      <requires csharp="(() =&gt; {
    {
        if (!System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType)
        {
            push predecessors.Values;
            push QuickGraph.EdgeExtensions.&lt;&gt;c__15&lt;TVertex, TEdge&gt;.&lt;&gt;9__15_0;
            if (dup == default(System.Func&lt;TEdge, bool&gt;))
            {
                pop;
                push (TEdge e) =&gt; (object)e != null;
                &lt;&gt;9__15_0 = dup;
            }
            push System.Linq.Enumerable.All&lt;TEdge&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()" vb="(() =&gt; {
    If Not System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType Then
    push predecessors.Values;
    push QuickGraph.EdgeExtensions.&lt;&gt;c__15(Of TVertex, TEdge).&lt;&gt;9__15_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__15_0 = dup
    push System.Linq.Enumerable.All(pop, pop);
    else    push 1;
    return pop &lt;&gt; 0; })()">(() =&gt; {
    {
        if (!System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType)
        {
            push predecessors.Values;
            push QuickGraph.EdgeExtensions.&lt;&gt;c__15&lt;TVertex, TEdge&gt;.&lt;&gt;9__15_0;
            if (dup == default(System.Func&lt;TEdge, bool&gt;))
            {
                pop;
                push (TEdge e) =&gt; (object)e != null;
                &lt;&gt;9__15_0 = dup;
            }
            push System.Linq.Enumerable.All&lt;TEdge&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()</requires>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.TryGetPath``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Collections.Generic.IEnumerable{``1}@)">
      <summary>
            Tries to get the predecessor path, if reachable.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="predecessors" />
      <param name="v" />
      <param name="result" />
      <returns />
      <requires csharp="predecessors != null" vb="predecessors &lt;&gt; Nothing">predecessors != null</requires>
      <requires csharp="(object)v != null" vb="((Object)v) &lt;&gt; Nothing">(object)v != null</requires>
      <requires csharp="(() =&gt; {
    {
        if (!System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType)
        {
            push predecessors.Values;
            push QuickGraph.EdgeExtensions.&lt;&gt;c__16&lt;TVertex, TEdge&gt;.&lt;&gt;9__16_0;
            if (dup == default(System.Func&lt;TEdge, bool&gt;))
            {
                pop;
                push (TEdge e) =&gt; (object)e != null;
                &lt;&gt;9__16_0 = dup;
            }
            push System.Linq.Enumerable.All&lt;TEdge&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()" vb="(() =&gt; {
    If Not System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType Then
    push predecessors.Values;
    push QuickGraph.EdgeExtensions.&lt;&gt;c__16(Of TVertex, TEdge).&lt;&gt;9__16_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__16_0 = dup
    push System.Linq.Enumerable.All(pop, pop);
    else    push 1;
    return pop &lt;&gt; 0; })()">(() =&gt; {
    {
        if (!System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType)
        {
            push predecessors.Values;
            push QuickGraph.EdgeExtensions.&lt;&gt;c__16&lt;TVertex, TEdge&gt;.&lt;&gt;9__16_0;
            if (dup == default(System.Func&lt;TEdge, bool&gt;))
            {
                pop;
                push (TEdge e) =&gt; (object)e != null;
                &lt;&gt;9__16_0 = dup;
            }
            push System.Linq.Enumerable.All&lt;TEdge&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()</requires>
      <ensures csharp="(() =&gt; {
    {
        if (Contract.Result&lt;bool&gt;())
        {
            if (result != default(System.Collections.Generic.IEnumerable&lt;TEdge&gt;))
            {
                if (!System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType)
                {
                    push result;
                    push QuickGraph.EdgeExtensions.&lt;&gt;c__16&lt;TVertex, TEdge&gt;.&lt;&gt;9__16_1;
                    if (dup == default(System.Func&lt;TEdge, bool&gt;))
                    {
                        pop;
                        push (TEdge e) =&gt; (object)e != null;
                        &lt;&gt;9__16_1 = dup;
                    }
                    push System.Linq.Enumerable.All&lt;TEdge&gt;(pop, pop);
                }
                else
                {
                    push 1;
                }
            }
            else
            {
                push 0;
            }
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()" vb="(() =&gt; {
    If Contract.Result(Of Boolean )() Then
    If result &lt;&gt; Nothing Then
    If Not System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType Then
    push result;
    push QuickGraph.EdgeExtensions.&lt;&gt;c__16(Of TVertex, TEdge).&lt;&gt;9__16_1;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__16_1 = dup
    push System.Linq.Enumerable.All(pop, pop);
    else    push 1;
    else    push 0;
    else    push 1;
    return pop &lt;&gt; 0; })()">(() =&gt; {
    {
        if (result)
        {
            if (result != default(System.Collections.Generic.IEnumerable&lt;TEdge&gt;))
            {
                if (!System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType)
                {
                    push result;
                    push QuickGraph.EdgeExtensions.&lt;&gt;c__16&lt;TVertex, TEdge&gt;.&lt;&gt;9__16_1;
                    if (dup == default(System.Func&lt;TEdge, bool&gt;))
                    {
                        pop;
                        push (TEdge e) =&gt; (object)e != null;
                        &lt;&gt;9__16_1 = dup;
                    }
                    push System.Linq.Enumerable.All&lt;TEdge&gt;(pop, pop);
                }
                else
                {
                    push 1;
                }
            }
            else
            {
                push 0;
            }
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()</ensures>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.GetUndirectedVertexEquality``2">
      <summary>
            Returns the most efficient comporer for the particular type of TEdge.
            If TEdge implements IUndirectedEdge, then only the (source,target) pair
            has to be compared; if not, (source, target) and (target, source) have to be compared.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <returns />
    </member>
    <member name="M:QuickGraph.EdgeExtensions.UndirectedVertexEquality``2(``1,``0,``0)">
      <summary>
            Gets a value indicating if the vertices of edge match (source, target) or
            (target, source)
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="edge" />
      <param name="source" />
      <param name="target" />
      <returns />
      <requires csharp="(object)edge != null" vb="((Object)edge) &lt;&gt; Nothing">(object)edge != null</requires>
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.SortedVertexEquality``2(``1,``0,``0)">
      <summary>
            Gets a value indicating if the vertices of edge match (source, target)
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="edge" />
      <param name="source" />
      <param name="target" />
      <returns />
      <requires csharp="(object)edge != null" vb="((Object)edge) &lt;&gt; Nothing">(object)edge != null</requires>
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires csharp="System.Collections.Generic.Comparer&lt;TVertex&gt;.Default.Compare(source, target) &lt;= 0" vb="System.Collections.Generic.Comparer(Of TVertex).Default.Compare(source, target) &lt;= 0">System.Collections.Generic.Comparer&lt;TVertex&gt;.Default.Compare(source, target) &lt;= 0</requires>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.ReverseEdges``2(System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Returns a reversed edge enumeration
            </summary>
      <param name="edges" />
      <returns />
    </member>
    <member name="T:QuickGraph.EquatableEdge`1">
      <summary>
            An equatable edge implementation
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
    </member>
    <member name="T:QuickGraph.GraphExtensions">
      <summary>
            Extension methods for populating graph datastructures
            </summary>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToVertexAndEdgeListGraph``3(System.Collections.Generic.IDictionary{``0,``2})">
      <summary>
            Wraps a dictionary into a vertex and edge list graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <typeparam name="TValue" />
      <param name="dictionary" />
      <returns />
      <requires csharp="dictionary != null" vb="dictionary &lt;&gt; Nothing">dictionary != null</requires>
      <requires csharp="(() =&gt; {
    {
        push dictionary.Values;
        push QuickGraph.GraphExtensions.&lt;&gt;c__0&lt;TVertex, TEdge, TValue&gt;.&lt;&gt;9__0_0;
        if (dup == default(System.Func&lt;TValue, bool&gt;))
        {
            pop;
            push (TValue v) =&gt; (object)v != null;
            &lt;&gt;9__0_0 = dup;
        }
    }
    return System.Linq.Enumerable.All&lt;TValue&gt;(pop, pop); })()" vb="(() =&gt; {
    push dictionary.Values;
    push QuickGraph.GraphExtensions.&lt;&gt;c__0(Of TVertex, TEdge, TValue).&lt;&gt;9__0_0;
    If dup = Nothing Then
    pop
    push (v As TValue) =&gt; ((Object)v) &lt;&gt; Nothing;
    &lt;&gt;9__0_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push dictionary.Values;
        push QuickGraph.GraphExtensions.&lt;&gt;c__0&lt;TVertex, TEdge, TValue&gt;.&lt;&gt;9__0_0;
        if (dup == default(System.Func&lt;TValue, bool&gt;))
        {
            pop;
            push (TValue v) =&gt; (object)v != null;
            &lt;&gt;9__0_0 = dup;
        }
    }
    return System.Linq.Enumerable.All&lt;TValue&gt;(pop, pop); })()</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToVertexAndEdgeListGraph``3(System.Collections.Generic.IDictionary{``0,``2},System.Func{System.Collections.Generic.KeyValuePair{``0,``2},System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Wraps a dictionary into a vertex and edge list graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <typeparam name="TValue" />
      <param name="dictionary" />
      <param name="keyValueToOutEdges" />
      <returns />
      <requires csharp="(() =&gt; {
    {
        QuickGraph.GraphExtensions.&lt;&gt;c__DisplayClass1_0&lt;TVertex, TEdge, TValue&gt; local_0 = new QuickGraph.GraphExtensions.&lt;&gt;c__DisplayClass1_0&lt;TVertex, TEdge, TValue&gt;();
        local_0.dictionary = dictionary;
        local_0.keyValueToOutEdges = keyValueToOutEdges;
    }
    return local_0.dictionary != null; })()" vb="(() =&gt; {
    QuickGraph.GraphExtensions.&lt;&gt;c__DisplayClass1_0&lt;TVertex, TEdge, TValue&gt; local_0 = New QuickGraph.GraphExtensions.&lt;&gt;c__DisplayClass1_0(Of TVertex, TEdge, TValue)();
    local_0.dictionary = dictionary
    local_0.keyValueToOutEdges = keyValueToOutEdges
    return local_0.dictionary &lt;&gt; Nothing; })()">(() =&gt; {
    {
        QuickGraph.GraphExtensions.&lt;&gt;c__DisplayClass1_0&lt;TVertex, TEdge, TValue&gt; local_0 = new QuickGraph.GraphExtensions.&lt;&gt;c__DisplayClass1_0&lt;TVertex, TEdge, TValue&gt;();
        local_0.dictionary = dictionary;
        local_0.keyValueToOutEdges = keyValueToOutEdges;
    }
    return local_0.dictionary != null; })()</requires>
      <requires csharp="local_0.keyValueToOutEdges != null" vb="local_0.keyValueToOutEdges &lt;&gt; Nothing">local_0.keyValueToOutEdges != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToDelegateIncidenceGraph``2(QuickGraph.TryFunc{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Creates an instance of DelegateIncidenceGraph.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="tryGetOutEdges" />
      <returns />
      <requires csharp="tryGetOutEdges != null" vb="tryGetOutEdges &lt;&gt; Nothing">tryGetOutEdges != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToDelegateBidirectionalIncidenceGraph``2(QuickGraph.TryFunc{``0,System.Collections.Generic.IEnumerable{``1}},QuickGraph.TryFunc{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Creates an instance of DelegateIncidenceGraph.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="tryGetOutEdges" />
      <param name="tryGetInEdges" />
      <returns />
      <requires csharp="tryGetOutEdges != null" vb="tryGetOutEdges &lt;&gt; Nothing">tryGetOutEdges != null</requires>
      <requires csharp="tryGetInEdges != null" vb="tryGetInEdges &lt;&gt; Nothing">tryGetInEdges != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToDelegateIncidenceGraph``2(System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Creates an instance of DelegateIncidenceGraph.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="getOutEdges" />
      <returns />
      <requires csharp="getOutEdges != null" vb="getOutEdges &lt;&gt; Nothing">getOutEdges != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToTryFunc``2(System.Func{``0,``1})">
      <summary>
            Converts a Func that returns a reference type into a tryfunc
            </summary>
      <typeparam name="T" />
      <typeparam name="TResult" />
      <param name="func" />
      <returns />
      <requires csharp="new QuickGraph.GraphExtensions.&lt;&gt;c__DisplayClass5_0&lt;T, TResult&gt;(){
    func = func, 
}.func != null" vb="(() =&gt; {
    QuickGraph.GraphExtensions.&lt;&gt;c__DisplayClass5_0&lt;T, TResult&gt; local_0_prime = New QuickGraph.GraphExtensions.&lt;&gt;c__DisplayClass5_0(Of T, TResult)();
    (local_0_prime.func = func)
    return local_0_prime; })().func &lt;&gt; Nothing">new QuickGraph.GraphExtensions.&lt;&gt;c__DisplayClass5_0&lt;T, TResult&gt;(){
    func = func, 
}.func != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToDelegateVertexAndEdgeListGraph``2(System.Collections.Generic.IEnumerable{``0},QuickGraph.TryFunc{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Creates an instance of DelegateIncidenceGraph.
            </summary>
      <param name="vertices" />
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="tryGetOutEdges" />
      <returns />
      <requires csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
      <requires csharp="tryGetOutEdges != null" vb="tryGetOutEdges &lt;&gt; Nothing">tryGetOutEdges != null</requires>
      <requires csharp="System.Linq.Enumerable.All&lt;TVertex&gt;(vertices, delegate (TVertex v) {
    decimal&lt;TEdge&gt; local_0;
    return tryGetOutEdges(v, ref local_0);

})" vb="System.Linq.Enumerable.All(vertices, delegate (v As TVertex) {
    decimal&lt;TEdge&gt; local_0;
    Return tryGetOutEdges(v, &amp;local_0)
})">System.Linq.Enumerable.All&lt;TVertex&gt;(vertices, delegate (TVertex v) {
    decimal&lt;TEdge&gt; local_0;
    return tryGetOutEdges(v, ref local_0);

})</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToDelegateVertexAndEdgeListGraph``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Creates an instance of DelegateIncidenceGraph.
            </summary>
      <param name="vertices" />
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="getOutEdges" />
      <returns />
      <requires csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
      <requires csharp="getOutEdges != null" vb="getOutEdges &lt;&gt; Nothing">getOutEdges != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToDelegateUndirectedGraph``3(System.Collections.Generic.IDictionary{``0,``2})">
      <summary>
            Wraps a dictionary into an undirected list graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <typeparam name="TValue" />
      <param name="dictionary" />
      <returns />
      <requires csharp="dictionary != null" vb="dictionary &lt;&gt; Nothing">dictionary != null</requires>
      <requires csharp="(() =&gt; {
    {
        push dictionary.Values;
        push QuickGraph.GraphExtensions.&lt;&gt;c__8&lt;TVertex, TEdge, TValue&gt;.&lt;&gt;9__8_0;
        if (dup == default(System.Func&lt;TValue, bool&gt;))
        {
            pop;
            push (TValue v) =&gt; (object)v != null;
            &lt;&gt;9__8_0 = dup;
        }
    }
    return System.Linq.Enumerable.All&lt;TValue&gt;(pop, pop); })()" vb="(() =&gt; {
    push dictionary.Values;
    push QuickGraph.GraphExtensions.&lt;&gt;c__8(Of TVertex, TEdge, TValue).&lt;&gt;9__8_0;
    If dup = Nothing Then
    pop
    push (v As TValue) =&gt; ((Object)v) &lt;&gt; Nothing;
    &lt;&gt;9__8_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push dictionary.Values;
        push QuickGraph.GraphExtensions.&lt;&gt;c__8&lt;TVertex, TEdge, TValue&gt;.&lt;&gt;9__8_0;
        if (dup == default(System.Func&lt;TValue, bool&gt;))
        {
            pop;
            push (TValue v) =&gt; (object)v != null;
            &lt;&gt;9__8_0 = dup;
        }
    }
    return System.Linq.Enumerable.All&lt;TValue&gt;(pop, pop); })()</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToDelegateUndirectedGraph``3(System.Collections.Generic.IDictionary{``0,``2},System.Func{System.Collections.Generic.KeyValuePair{``0,``2},System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Wraps a dictionary into an undirected graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <typeparam name="TValue" />
      <param name="dictionary" />
      <param name="keyValueToOutEdges" />
      <returns />
      <requires csharp="(() =&gt; {
    {
        QuickGraph.GraphExtensions.&lt;&gt;c__DisplayClass9_0&lt;TVertex, TEdge, TValue&gt; local_0 = new QuickGraph.GraphExtensions.&lt;&gt;c__DisplayClass9_0&lt;TVertex, TEdge, TValue&gt;();
        local_0.dictionary = dictionary;
        local_0.keyValueToOutEdges = keyValueToOutEdges;
    }
    return local_0.dictionary != null; })()" vb="(() =&gt; {
    QuickGraph.GraphExtensions.&lt;&gt;c__DisplayClass9_0&lt;TVertex, TEdge, TValue&gt; local_0 = New QuickGraph.GraphExtensions.&lt;&gt;c__DisplayClass9_0(Of TVertex, TEdge, TValue)();
    local_0.dictionary = dictionary
    local_0.keyValueToOutEdges = keyValueToOutEdges
    return local_0.dictionary &lt;&gt; Nothing; })()">(() =&gt; {
    {
        QuickGraph.GraphExtensions.&lt;&gt;c__DisplayClass9_0&lt;TVertex, TEdge, TValue&gt; local_0 = new QuickGraph.GraphExtensions.&lt;&gt;c__DisplayClass9_0&lt;TVertex, TEdge, TValue&gt;();
        local_0.dictionary = dictionary;
        local_0.keyValueToOutEdges = keyValueToOutEdges;
    }
    return local_0.dictionary != null; })()</requires>
      <requires csharp="local_0.keyValueToOutEdges != null" vb="local_0.keyValueToOutEdges &lt;&gt; Nothing">local_0.keyValueToOutEdges != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToDelegateUndirectedGraph``2(System.Collections.Generic.IEnumerable{``0},QuickGraph.TryFunc{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Creates an instance of DelegateIncidenceGraph.
            </summary>
      <param name="vertices" />
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="tryGetAdjacentEdges" />
      <returns />
      <requires csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
      <requires csharp="tryGetAdjacentEdges != null" vb="tryGetAdjacentEdges &lt;&gt; Nothing">tryGetAdjacentEdges != null</requires>
      <requires csharp="System.Linq.Enumerable.All&lt;TVertex&gt;(vertices, delegate (TVertex v) {
    decimal&lt;TEdge&gt; local_0;
    return tryGetAdjacentEdges(v, ref local_0);

})" vb="System.Linq.Enumerable.All(vertices, delegate (v As TVertex) {
    decimal&lt;TEdge&gt; local_0;
    Return tryGetAdjacentEdges(v, &amp;local_0)
})">System.Linq.Enumerable.All&lt;TVertex&gt;(vertices, delegate (TVertex v) {
    decimal&lt;TEdge&gt; local_0;
    return tryGetAdjacentEdges(v, ref local_0);

})</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToDelegateUndirectedGraph``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Creates an instance of DelegateIncidenceGraph.
            </summary>
      <param name="vertices" />
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="getAdjacentEdges" />
      <returns />
      <requires csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
      <requires csharp="getAdjacentEdges != null" vb="getAdjacentEdges &lt;&gt; Nothing">getAdjacentEdges != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToAdjacencyGraph``1(``0[][])">
      <summary>
            Converts a jagged array of sources and targets into a graph
            </summary>
      <typeparam name="TVertex" />
      <param name="edges" />
      <returns />
      <requires csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
      <requires csharp="edges.Length == 2" vb="edges.Length = 2">edges.Length == 2</requires>
      <requires csharp="edges[0] != null" vb="edges(0) &lt;&gt; Nothing">edges[0] != null</requires>
      <requires csharp="edges[1] != null" vb="edges(1) &lt;&gt; Nothing">edges[1] != null</requires>
      <requires csharp="edges[0].Length == edges[1].Length" vb="edges(0).Length = edges(1).Length">edges[0].Length == edges[1].Length</requires>
      <ensures csharp="Contract.Result&lt;QuickGraph.AdjacencyGraph&lt;TVertex, QuickGraph.SEquatableEdge&lt;TVertex&gt;&gt;&gt;() != null" vb="Contract.Result(Of QuickGraph.AdjacencyGraph(Of TVertex, QuickGraph.SEquatableEdge(Of TVertex)))() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToArrayAdjacencyGraph``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1})">
      <summary>
            Creates an immutable array adjacency graph from the input graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="graph" />
      <returns />
      <requires csharp="graph != null" vb="graph &lt;&gt; Nothing">graph != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToArrayBidirectionalGraph``2(QuickGraph.IBidirectionalGraph{``0,``1})">
      <summary>
            Creates an immutable array bidirectional graph from the input graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="graph" />
      <returns />
      <requires csharp="graph != null" vb="graph &lt;&gt; Nothing">graph != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToArrayUndirectedGraph``2(QuickGraph.IUndirectedGraph{``0,``1})">
      <summary>
            Creates an immutable array undirected graph from the input graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="graph" />
      <returns />
      <requires csharp="graph != null" vb="graph &lt;&gt; Nothing">graph != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToBidirectionalGraph``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1})">
      <summary>
            Wraps a adjacency graph (out-edge only) into a bidirectional graph.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="graph" />
      <returns />
      <requires csharp="graph != null" vb="graph &lt;&gt; Nothing">graph != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToUndirectedGraph``2(System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Converts a sequence of edges into an undirected graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="edges" />
      <returns />
      <requires csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
      <requires csharp="(() =&gt; {
    {
        push edges;
        push QuickGraph.GraphExtensions.&lt;&gt;c__17&lt;TVertex, TEdge&gt;.&lt;&gt;9__17_0;
        if (dup == default(System.Func&lt;TEdge, bool&gt;))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__17_0 = dup;
        }
    }
    return System.Linq.Enumerable.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push edges;
    push QuickGraph.GraphExtensions.&lt;&gt;c__17(Of TVertex, TEdge).&lt;&gt;9__17_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__17_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push edges;
        push QuickGraph.GraphExtensions.&lt;&gt;c__17&lt;TVertex, TEdge&gt;.&lt;&gt;9__17_0;
        if (dup == default(System.Func&lt;TEdge, bool&gt;))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__17_0 = dup;
        }
    }
    return System.Linq.Enumerable.All&lt;TEdge&gt;(pop, pop); })()</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToUndirectedGraph``2(System.Collections.Generic.IEnumerable{``1},System.Boolean)">
      <summary>
            Converts a sequence of edges into an undirected graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="edges" />
      <param name="allowParralelEdges" />
      <returns />
      <requires csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
      <requires csharp="(() =&gt; {
    {
        push edges;
        push QuickGraph.GraphExtensions.&lt;&gt;c__18&lt;TVertex, TEdge&gt;.&lt;&gt;9__18_0;
        if (dup == default(System.Func&lt;TEdge, bool&gt;))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__18_0 = dup;
        }
    }
    return System.Linq.Enumerable.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push edges;
    push QuickGraph.GraphExtensions.&lt;&gt;c__18(Of TVertex, TEdge).&lt;&gt;9__18_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__18_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push edges;
        push QuickGraph.GraphExtensions.&lt;&gt;c__18&lt;TVertex, TEdge&gt;.&lt;&gt;9__18_0;
        if (dup == default(System.Func&lt;TEdge, bool&gt;))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__18_0 = dup;
        }
    }
    return System.Linq.Enumerable.All&lt;TEdge&gt;(pop, pop); })()</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToBidirectionalGraph``2(System.Collections.Generic.IEnumerable{``1},System.Boolean)">
      <summary>
            Converts a set of edges into a bidirectional graph.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="edges">The edges.</param>
      <param name="allowParallelEdges">if set to <c>true</c>, the graph allows parallel edges.</param>
      <returns />
      <requires csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
      <requires csharp="QuickGraph.EnumerableContract.ElementsNotNull&lt;TEdge&gt;(edges)" vb="QuickGraph.EnumerableContract.ElementsNotNull(edges)">QuickGraph.EnumerableContract.ElementsNotNull&lt;TEdge&gt;(edges)</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToBidirectionalGraph``2(System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Converts a set of edges into a bidirectional graph.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="edges">The edges.</param>
      <returns />
      <requires csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
      <requires csharp="QuickGraph.EnumerableContract.ElementsNotNull&lt;TEdge&gt;(edges)" vb="QuickGraph.EnumerableContract.ElementsNotNull(edges)">QuickGraph.EnumerableContract.ElementsNotNull&lt;TEdge&gt;(edges)</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToAdjacencyGraph``2(System.Collections.Generic.IEnumerable{``1},System.Boolean)">
      <summary>
            Converts a set of edges into an adjacency graph.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="edges">The edges.</param>
      <param name="allowParallelEdges">if set to <c>true</c>, the graph allows parallel edges.</param>
      <returns />
      <requires csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
      <requires csharp="QuickGraph.EnumerableContract.ElementsNotNull&lt;TEdge&gt;(edges)" vb="QuickGraph.EnumerableContract.ElementsNotNull(edges)">QuickGraph.EnumerableContract.ElementsNotNull&lt;TEdge&gt;(edges)</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToAdjacencyGraph``2(System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Converts a set of edges into an adjacency graph.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="edges">The edges.</param>
      <returns />
      <requires csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
      <requires csharp="QuickGraph.EnumerableContract.ElementsNotNull&lt;TEdge&gt;(edges)" vb="QuickGraph.EnumerableContract.ElementsNotNull(edges)">QuickGraph.EnumerableContract.ElementsNotNull&lt;TEdge&gt;(edges)</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToAdjacencyGraph``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Boolean)">
      <summary>
            Converts a set of vertices into an adjacency graph,
            using an edge factory.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="vertices">The vertices.</param>
      <param name="outEdgesFactory">The out edges factory.</param>
      <param name="allowParallelEdges">if set to <c>true</c>, the graph allows parallel edges.</param>
      <returns />
      <requires csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
      <requires csharp="outEdgesFactory != null" vb="outEdgesFactory &lt;&gt; Nothing">outEdgesFactory != null</requires>
      <requires csharp="QuickGraph.EnumerableContract.ElementsNotNull&lt;TVertex&gt;(vertices)" vb="QuickGraph.EnumerableContract.ElementsNotNull(vertices)">QuickGraph.EnumerableContract.ElementsNotNull&lt;TVertex&gt;(vertices)</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToAdjacencyGraph``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Converts a set of vertices into an adjacency graph,
            using an edge factory.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="vertices">The vertices.</param>
      <param name="outEdgesFactory">The out edges factory.</param>
      <returns />
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToBidirectionalGraph``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Boolean)">
      <summary>
            Converts a set of vertices into a bidirectional graph,
            using an edge factory.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="vertices">The vertices.</param>
      <param name="outEdgesFactory">The out edges factory.</param>
      <param name="allowParallelEdges">if set to <c>true</c>, the graph allows parallel edges.</param>
      <returns />
      <requires csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
      <requires csharp="outEdgesFactory != null" vb="outEdgesFactory &lt;&gt; Nothing">outEdgesFactory != null</requires>
      <requires csharp="QuickGraph.EnumerableContract.ElementsNotNull&lt;TVertex&gt;(vertices)" vb="QuickGraph.EnumerableContract.ElementsNotNull(vertices)">QuickGraph.EnumerableContract.ElementsNotNull&lt;TVertex&gt;(vertices)</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToBidirectionalGraph``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>
            Converts a set of vertices into a bidirectional graph,
            using an edge factory
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
      <param name="vertices">The vertices.</param>
      <param name="outEdgesFactory">The out edges factory.</param>
      <returns />
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToAdjacencyGraph``1(System.Collections.Generic.IEnumerable{QuickGraph.SEquatableEdge{``0}})">
      <summary>
            Converts a sequence of vertex pairs into an adjancency graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <param name="vertexPairs" />
      <returns />
      <requires csharp="vertexPairs != null" vb="vertexPairs &lt;&gt; Nothing">vertexPairs != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToBidirectionalGraph``1(System.Collections.Generic.IEnumerable{QuickGraph.SEquatableEdge{``0}})">
      <summary>
            Converts a sequence of vertex pairs into an bidirectional graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <param name="vertexPairs" />
      <returns />
      <requires csharp="vertexPairs != null" vb="vertexPairs &lt;&gt; Nothing">vertexPairs != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToUndirectedGraph``1(System.Collections.Generic.IEnumerable{QuickGraph.SEquatableEdge{``0}})">
      <summary>
            Converts a sequence of vertex pairs into an bidirectional graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <param name="vertexPairs" />
      <returns />
      <requires csharp="vertexPairs != null" vb="vertexPairs &lt;&gt; Nothing">vertexPairs != null</requires>
    </member>
    <member name="M:QuickGraph.GraphExtensions.ToCompressedRowGraph``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1})">
      <summary>
            Creates an immutable compressed row graph representation of the visited graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="visitedGraph" />
      <returns />
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.HashCodeHelper.Combine(System.Int32,System.Int32)">
      <summary>
            Combines two hashcodes in a strong way.
            </summary>
      <param name="x" />
      <param name="y" />
      <returns />
    </member>
    <member name="M:QuickGraph.HashCodeHelper.Combine(System.Int32,System.Int32,System.Int32)">
      <summary>
            Combines three hashcodes in a strong way.
            </summary>
      <param name="x" />
      <param name="y" />
      <param name="z" />
      <returns />
    </member>
    <member name="T:QuickGraph.IEdgeSet`2">
      <summary>
            A set of edges
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
    </member>
    <member name="P:QuickGraph.IEdgeSet`2.IsEdgesEmpty">
      <summary>
            Gets a value indicating whether there are no edges in this set.
            </summary>
      <value>
        <c>true</c> if this set is empty; otherwise, <c>false</c>.
            </value>
      <getter>
        <ensures csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.EdgeCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.EdgeCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.EdgeCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.IEdgeSet`2.EdgeCount">
      <summary>
            Gets the edge count.
            </summary>
      <value>The edge count.</value>
      <getter>
        <ensures csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Edges); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Edges); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Edges); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.IEdgeSet`2.Edges">
      <summary>
            Gets the edges.
            </summary>
      <value>The edges.</value>
      <getter>
        <ensures csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
        <ensures csharp="(() =&gt; {
    {
        push Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;();
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))();
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__5_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__5_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push result;
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)">
      <summary>
            Determines whether the specified edge contains edge.
            </summary>
      <param name="edge">The edge.</param>
      <returns>
        <c>true</c> if the specified edge contains edge; otherwise, <c>false</c>.
            </returns>
      <pure />
      <requires csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures csharp="Contract.Result&lt;bool&gt;() == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))" vb="Contract.Result(Of Boolean )() = System.Diagnostics.Contracts.Contract.Exists(Me.Edges, (e As TEdge) =&gt; e.Equals(((Object)edge)))">result == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))</ensures>
    </member>
    <member name="T:QuickGraph.IImplicitVertexSet`1">
      <summary>
            An implicit set of vertices
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
    </member>
    <member name="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)">
      <summary>
            Determines whether the specified vertex contains vertex.
            </summary>
      <param name="vertex">The vertex.</param>
      <returns>
        <c>true</c> if the specified vertex contains vertex; otherwise, <c>false</c>.
            </returns>
      <pure />
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()</requires>
    </member>
    <member name="T:QuickGraph.IMutableVertexAndEdgeSet`2">
      <summary>
            A mutable vertex and edge set
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)">
      <summary>
            Adds the vertices and edge to the graph.
            </summary>
      <param name="edge" />
      <returns>true if the edge was added, otherwise false.</returns>
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures csharp="this.ContainsEdge(edge)" vb="Me.ContainsEdge(edge)">this.ContainsEdge(edge)</ensures>
      <ensures csharp="this.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.Old(!this.ContainsEdge(edge))" vb="Me.AllowParallelEdges OrElse Contract.Result(Of Boolean )() = Contract.Old(Not Me.ContainsEdge(edge))">this.AllowParallelEdges || result == old(!this.ContainsEdge(edge))</ensures>
      <ensures csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + (Contract.Result(Of Boolean )() ? 1 : 0)">this.EdgeCount == old(this.EdgeCount) + (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})">
      <summary>
            Adds a set of edges (and it's vertices if necessary)
            </summary>
      <param name="edges" />
      <returns>the number of edges added.</returns>
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return edges != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return edges &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return edges != null; })()</requires>
      <requires csharp="(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__1_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__1_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()" vb="(() =&gt; {
    If Not System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType Then
    push edges;
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__1_0;
    If dup = Nothing Then
    pop
    push (edge As TEdge) =&gt; ((Object)edge) &lt;&gt; Nothing;
    &lt;&gt;9__1_0 = dup
    push System.Linq.Enumerable.All(pop, pop);
    else    push 1;
    return pop &lt;&gt; 0; })()">(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__1_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__1_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()</requires>
      <ensures csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + Contract.Result&lt;int&gt;()" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + Contract.Result(Of Integer )()">this.EdgeCount == old(this.EdgeCount) + result</ensures>
    </member>
    <member name="T:QuickGraph.IMutableVertexSet`1">
      <summary>
            A mutable vertex set
            </summary>
      <typeparam name="TVertex" />
    </member>
    <member name="P:QuickGraph.Predicates.FilteredGraph`3.BaseGraph">
      <summary>
            Underlying filtered graph
            </summary>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredGraph`3.EdgePredicate">
      <summary>
            Edge predicate used to filter the edges
            </summary>
    </member>
    <member name="T:QuickGraph.Predicates.IsolatedVertexPredicate`2">
      <summary>
            A vertex predicate that detects vertex with no in or out edges.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="P:QuickGraph.Predicates.ReversedResidualEdgePredicate`2.ResidualCapacities">
      <summary>
            Residual capacities map
            </summary>
    </member>
    <member name="P:QuickGraph.Predicates.ReversedResidualEdgePredicate`2.ReversedEdges">
      <summary>
            Reversed edges map
            </summary>
    </member>
    <member name="T:QuickGraph.BidirectionalGraph`2">
      <summary>
            A mutable directed graph data structure efficient for sparse
            graph representation where out-edge and in-edges need to be enumerated. Requires
            twice as much memory as the adjacency graph.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.CreateEdgeDelegate`2">
      <summary>
            An edge factory delegate
            </summary>
    </member>
    <member name="T:QuickGraph.CreateVertexDelegate`2">
      <summary>
            A vertex factory delegate.
            </summary>
    </member>
    <member name="T:QuickGraph.Edge`1">
      <summary>
            The default <see cref="T:QuickGraph.IEdge`1" /> implementation.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
    </member>
    <member name="M:QuickGraph.Edge`1.#ctor(`0,`0)">
      <summary>
            Initializes a new instance of the <see cref="T:QuickGraph.Edge`1" /> class.
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <ensures csharp="this.Source.Equals((object)source)" vb="Me.Source.Equals(((Object)source))">this.Source.Equals((object)source)</ensures>
      <ensures csharp="this.Target.Equals((object)target)" vb="Me.Target.Equals(((Object)target))">this.Target.Equals((object)target)</ensures>
    </member>
    <member name="P:QuickGraph.Edge`1.Source">
      <summary>
            Gets the source vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Edge`1.Target">
      <summary>
            Gets the target vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Edge`1.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="T:QuickGraph.EdgeEdgeAction`2">
      <summary>
            The handler for events involving two edges
            </summary>
    </member>
    <member name="T:QuickGraph.EdgeEventArgs`2">
      <summary>
            An event involving an edge.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
    </member>
    <member name="M:QuickGraph.EdgeEventArgs`2.#ctor(`1)">
      <summary>
            Initializes a new instance of the <see cref="T:QuickGraph.EdgeEventArgs`2" /> class.
            </summary>
      <param name="edge">The edge.</param>
      <requires csharp="(object)edge != null" vb="((Object)edge) &lt;&gt; Nothing">(object)edge != null</requires>
    </member>
    <member name="P:QuickGraph.EdgeEventArgs`2.Edge">
      <summary>
            Gets the edge.
            </summary>
      <value>The edge.</value>
    </member>
    <member name="T:QuickGraph.EdgeAction`2">
      <summary>
            The handler for events involving edges
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
      <param name="e" />
    </member>
    <member name="P:QuickGraph.IHierarchy`2.Root">
      <summary>
            Gets the roots of the hierarchy
            </summary>
    </member>
    <member name="M:QuickGraph.IHierarchy`2.GetParent(`0)">
      <summary>
            Gets the parent <typeparamref name="TVertex" /> of <paramref name="vertex" /></summary>
      <param name="vertex" />
      <returns />
      <exception cref="T:System.ArgumentException">
        <paramref name="vertex" /> is the root of the graph.
            </exception>
    </member>
    <member name="M:QuickGraph.IHierarchy`2.GetParentEdge(`0)">
      <summary>
            Gets the parent <typeparamref name="TEdge" /> of <paramref name="vertex" /></summary>
      <param name="vertex" />
      <returns />
      <exception cref="T:System.ArgumentException">
        <paramref name="vertex" /> is the root of the graph.
            </exception>
    </member>
    <member name="M:QuickGraph.IHierarchy`2.IsCrossEdge(`1)">
      <summary>
            Gets a value indicating if <paramref name="edge" /> is 
            a cross edge.
            </summary>
      <param name="edge" />
      <returns />
    </member>
    <member name="M:QuickGraph.IHierarchy`2.IsRealEdge(`1)">
      <summary>
            Gets a value indicating whether <paramref name="edge" /> 
            exists really or is just an induced edge.
            </summary>
      <param name="edge" />
      <returns />
    </member>
    <member name="M:QuickGraph.IHierarchy`2.IsPredecessorOf(`0,`0)">
      <summary>
            Gets a value indicating if <paramref name="source" />
            is a predecessor of <paramref name="target" /></summary>
      <param name="source" />
      <param name="target" />
      <returns>
            true if <paramref name="source" /> is a predecessor of
            <paramref name="target" /></returns>
    </member>
    <member name="M:QuickGraph.IHierarchy`2.InducedEdgeCount(`0,`0)">
      <summary>
            Gets the number of edges between <paramref name="source" />
            and <paramref name="target" />. 
            </summary>
      <param name="source" />
      <param name="target" />
      <returns />
      <exception cref="T:System.ArgumentException">
        <paramref name="source" /> is a predecessor of <paramref name="target" />
            or the otherway round.
            </exception>
    </member>
    <member name="M:QuickGraph.IHierarchy`2.IsInnerNode(`0)">
      <summary>
            Gets a value indicating if <paramref name="vertex" /> is 
            inner node or a leaf.
            </summary>
      <param name="vertex" />
      <returns>
            true if not a leaf
            </returns>
    </member>
    <member name="M:QuickGraph.IHierarchy`2.ChildrenEdges(`0)">
      <summary>
            Gets the collection of children <typeparamref name="TEdge" />
            from <paramref name="vertex" /></summary>
      <param name="vertex" />
      <returns />
    </member>
    <member name="M:QuickGraph.IHierarchy`2.ChildrenVertices(`0)">
      <summary>
            Gets the collection of children <typeparamref name="TVertex" />
            from <paramref name="vertex" /></summary>
      <param name="vertex" />
      <returns />
    </member>
    <member name="T:QuickGraph.IdentifiableEdgeFactory`2">
      <summary>
            A factory of identifiable edges.
            </summary>
    </member>
    <member name="T:QuickGraph.IdentifiableVertexFactory`1">
      <summary>
            A factory of identifiable vertices.
            </summary>
    </member>
    <member name="T:QuickGraph.IMutableUndirectedGraph`2">
      <summary>
            A mutable indirect graph
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="T:QuickGraph.IUndirectedGraph`2">
      <summary>
            An undirected graph
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="T:QuickGraph.IVertexSet`1">
      <summary>
            A set of vertices
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
    </member>
    <member name="P:QuickGraph.IVertexSet`1.IsVerticesEmpty">
      <summary>
            Gets a value indicating whether there are no vertices in this set.
            </summary>
      <value>
        <c>true</c> if the vertex set is empty; otherwise, <c>false</c>.
            </value>
      <getter>
        <ensures csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.VertexCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.VertexCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.VertexCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.IVertexSet`1.VertexCount">
      <summary>
            Gets the vertex count.
            </summary>
      <value>The vertex count.</value>
      <getter>
        <ensures csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Vertices); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Vertices); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Vertices); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.IVertexSet`1.Vertices">
      <summary>
            Gets the vertices.
            </summary>
      <value>The vertices.</value>
      <getter>
        <ensures csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TVertex&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TVertex))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="T:QuickGraph.NonStronglyConnectedGraphException">
      <summary>
            Exception raised when an algorithm detects a non-strongly connected graph.
            </summary>
    </member>
    <member name="T:QuickGraph.GraphColor">
      <summary>
            Colors used in vertex coloring algorithms
            </summary>
    </member>
    <member name="F:QuickGraph.GraphColor.White">
      <summary>
            Usually initial color,
            </summary>
    </member>
    <member name="F:QuickGraph.GraphColor.Gray">
      <summary>
            Usually intermidiate color,
            </summary>
    </member>
    <member name="F:QuickGraph.GraphColor.Black">
      <summary>
            Usually finished color
            </summary>
    </member>
    <member name="T:QuickGraph.IBidirectionalGraph`2">
      <summary>
            A directed graph datastructure that is efficient
            to traverse both in and out edges.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
    </member>
    <member name="T:QuickGraph.ICloneableEdge`2">
      <summary>
            A cloneable edge
            </summary>
      <typeparam name="TVertex">type of the vertex</typeparam>
      <typeparam name="TEdge">type of the edge</typeparam>
    </member>
    <member name="M:QuickGraph.ICloneableEdge`2.Clone(`0,`0)">
      <summary>
            Clones the edge content to a different pair of <paramref name="source" />
            and <paramref name="target" /> vertices
            </summary>
      <param name="source">The source vertex of the new edge</param>
      <param name="target">The target vertex of the new edge</param>
      <returns>A clone of the edge with new source and target vertices</returns>
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <ensures csharp="(object)Contract.Result&lt;TEdge&gt;() != null" vb="((Object)Contract.Result(Of TEdge)()) &lt;&gt; Nothing">(object)result != null</ensures>
      <ensures csharp="Contract.Result&lt;TEdge&gt;().Source.Equals((object)source)" vb="Contract.Result(Of TEdge)().Source.Equals(((Object)source))">result.Source.Equals((object)source)</ensures>
      <ensures csharp="Contract.Result&lt;TEdge&gt;().Target.Equals((object)target)" vb="Contract.Result(Of TEdge)().Target.Equals(((Object)target))">result.Target.Equals((object)target)</ensures>
    </member>
    <member name="T:QuickGraph.IEdge`1">
      <summary>
            A directed edge
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
    </member>
    <member name="P:QuickGraph.IEdge`1.Source">
      <summary>
            Gets the source vertex
            </summary>
      <getter>
        <ensures csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.IEdge`1.Target">
      <summary>
            Gets the target vertex
            </summary>
      <getter>
        <ensures csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="T:QuickGraph.EdgeFactory`2">
      <summary>
            An edge factory
            </summary>
    </member>
    <member name="T:QuickGraph.IEdgeListAndIncidenceGraph`2">
      <summary>
            An incidence graph whose edges can be enumerated
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.IEdgeListGraph`2">
      <summary>
            A graph whose edges can be enumerated
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.IGraph`2">
      <summary>
            A graph with vertices of type <typeparamref name="TVertex" />
            and edges of type <typeparamref name="TEdge" /></summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="P:QuickGraph.IGraph`2.IsDirected">
      <summary>
            Gets a value indicating if the graph is directed
            </summary>
    </member>
    <member name="P:QuickGraph.IGraph`2.AllowParallelEdges">
      <summary>
            Gets a value indicating if the graph allows parallel edges
            </summary>
    </member>
    <member name="T:QuickGraph.IImplicitGraph`2">
      <summary>
            A implicit directed graph datastructure
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
    </member>
    <member name="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)">
      <summary>
            Determines whether there are out-edges associated to <paramref name="v" />.
            </summary>
      <param name="v">The vertex.</param>
      <returns>
        <c>true</c> if <paramref name="v" /> has no out-edges; otherwise, <c>false</c>.
            </returns>
      <pure />
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures csharp="Contract.Result&lt;bool&gt;() == this.OutDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.OutDegree(v) = 0">result == this.OutDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)">
      <summary>
            Gets the count of out-edges of <paramref name="v" /></summary>
      <param name="v">The vertex.</param>
      <returns>The count of out-edges of <paramref name="v" /></returns>
      <pure />
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.OutEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.OutEdges(v))">result == decimal.Count&lt;decimal&gt;(this.OutEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)">
      <summary>
            Gets the out-edges of <paramref name="v" />.
            </summary>
      <param name="v">The vertex.</param>
      <returns>An enumeration of the out-edges of <paramref name="v" />.</returns>
      <pure />
      <requires csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))() &lt;&gt; Nothing">result != null</ensures>
      <ensures csharp="decimal.All&lt;decimal&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;(), (decimal e) =&gt; e.Source.Equals((decimal)v))" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))(), (e As TEdge) =&gt; e.Source.Equals(((Object)v)))">decimal.All&lt;decimal&gt;(result, (decimal e) =&gt; e.Source.Equals((decimal)v))</ensures>
    </member>
    <member name="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <summary>
            Tries to get the out-edges of <paramref name="v" /></summary>
      <param name="v" />
      <param name="edges" />
      <returns />
      <pure />
      <requires csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <ensures csharp="(!Contract.Result&lt;bool&gt;() || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0" vb="(Contract.Result(Of Boolean )() AndAlso Not (edges &lt;&gt; Nothing AndAlso System.Linq.Enumerable.All(edges, (e As TEdge) =&gt; e.Source.Equals(((Object)v))))) &lt;&gt; 0">(!result || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0</ensures>
    </member>
    <member name="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)">
      <summary>
            Gets the out-edge of <paramref name="v" /> at position <paramref name="index" />.
            </summary>
      <param name="v">The vertex.</param>
      <param name="index">The index.</param>
      <returns>The out-edge at position <paramref name="index" /></returns>
      <pure />
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires csharp="index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)" vb="index &gt;= 0 AndAlso index &lt; Me.OutDegree(v)">index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)</requires>
      <ensures csharp="decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)Contract.Result&lt;decimal&gt;())" vb="System.Linq.Enumerable.ElementAt(Me.OutEdges(v), index).Equals(((Object)Contract.Result(Of TEdge)()))">decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)result)</ensures>
    </member>
    <member name="T:QuickGraph.IMutableBidirectionalGraph`2">
      <summary>
            A mutable bidirectional directed graph
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="M:QuickGraph.IMutableBidirectionalGraph`2.RemoveInEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})">
      <summary>
            Removes in-edges of <paramref name="v" /> that match
            predicate <paramref name="edgePredicate" />.
            </summary>
      <param name="v" />
      <param name="edgePredicate" />
      <returns>Number of edges removed</returns>
      <requires csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires csharp="edgePredicate != null" vb="edgePredicate &lt;&gt; Nothing">edgePredicate != null</requires>
      <requires csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</ensures>
      <ensures csharp="decimal.All&lt;decimal&gt;(this.InEdges(v), (decimal e) =&gt; edgePredicate(e))" vb="System.Linq.Enumerable.All(Me.InEdges(v), (e As TEdge) =&gt; edgePredicate(e))">decimal.All&lt;decimal&gt;(this.InEdges(v), (decimal e) =&gt; edgePredicate(e))</ensures>
      <ensures csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(this.InEdges(v), (decimal e) =&gt; edgePredicate(e)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(Me.InEdges(v), (e As TEdge) =&gt; edgePredicate(e)))">result == old(decimal.Count&lt;decimal&gt;(this.InEdges(v), (decimal e) =&gt; edgePredicate(e)))</ensures>
      <ensures csharp="this.InDegree(v) == Contract.Old(this.InDegree(v)) - Contract.Result&lt;int&gt;()" vb="Me.InDegree(v) = Contract.Old(Me.InDegree(v)) - Contract.Result(Of Integer )()">this.InDegree(v) == old(this.InDegree(v)) - result</ensures>
    </member>
    <member name="M:QuickGraph.IMutableBidirectionalGraph`2.ClearInEdges(`0)">
      <summary>
            Clears in-edges of <paramref name="v" /></summary>
      <param name="v" />
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures csharp="this.EdgeCount == Contract.Old(this.EdgeCount) - Contract.Old(this.InDegree(v))" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) - Contract.Old(Me.InDegree(v))">this.EdgeCount == old(this.EdgeCount) - old(this.InDegree(v))</ensures>
      <ensures csharp="this.InDegree(v) == 0" vb="Me.InDegree(v) = 0">this.InDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.IMutableBidirectionalGraph`2.ClearEdges(`0)">
      <summary>
            Clears in-edges and out-edges of <paramref name="v" /></summary>
      <param name="v" />
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures csharp="!this.ContainsVertex(v)" vb="Not Me.ContainsVertex(v)">!this.ContainsVertex(v)</ensures>
    </member>
    <member name="T:QuickGraph.IMutableEdgeListGraph`2">
      <summary>
            A mutable edge list graph.
            </summary>
      <typeparam name="TVertex">the vertex type</typeparam>
      <typeparam name="TEdge">the edge type</typeparam>
    </member>
    <member name="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)">
      <summary>
            Adds the edge to the graph
            </summary>
      <param name="edge" />
      <returns>true if the edge was added, otherwise false.</returns>
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()</requires>
      <requires csharp="this.ContainsVertex(edge.Source)" vb="Me.ContainsVertex(edge.Source)">this.ContainsVertex(edge.Source)</requires>
      <requires csharp="this.ContainsVertex(edge.Target)" vb="Me.ContainsVertex(edge.Target)">this.ContainsVertex(edge.Target)</requires>
      <ensures csharp="this.ContainsEdge(edge)" vb="Me.ContainsEdge(edge)">this.ContainsEdge(edge)</ensures>
      <ensures csharp="this.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.Old(!this.ContainsEdge(edge))" vb="Me.AllowParallelEdges OrElse Contract.Result(Of Boolean )() = Contract.Old(Not Me.ContainsEdge(edge))">this.AllowParallelEdges || result == old(!this.ContainsEdge(edge))</ensures>
      <ensures csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + (Contract.Result(Of Boolean )() ? 1 : 0)">this.EdgeCount == old(this.EdgeCount) + (result ? 1 : 0)</ensures>
    </member>
    <member name="E:QuickGraph.IMutableEdgeListGraph`2.EdgeAdded">
      <summary>
            Raised when an edge is added to the graph.
            </summary>
    </member>
    <member name="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})">
      <summary>
            Adds a set of edges to the graph.
            </summary>
      <param name="edges" />
      <returns>the number of edges successfully added to the graph.</returns>
      <requires csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
      <requires csharp="(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__4_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__4_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()" vb="(() =&gt; {
    If Not System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType Then
    push edges;
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__4_0;
    If dup = Nothing Then
    pop
    push (edge As TEdge) =&gt; ((Object)edge) &lt;&gt; Nothing;
    &lt;&gt;9__4_0 = dup
    push System.Linq.Enumerable.All(pop, pop);
    else    push 1;
    return pop &lt;&gt; 0; })()">(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__4_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__4_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()</requires>
      <requires csharp="decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if (this.ContainsVertex(edge.Source))
    {
        return this.ContainsVertex(edge.Target);

    }
    return false;

})" vb="System.Linq.Enumerable.All(edges, delegate (edge As TEdge) {
    If Me.ContainsVertex(edge.Source) Then
    Return Me.ContainsVertex(edge.Target)
    Return False
})">decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if (this.ContainsVertex(edge.Source))
    {
        return this.ContainsVertex(edge.Target);

    }
    return false;

})</requires>
      <ensures description="all edge from edges belong to the graph" csharp="decimal.All&lt;decimal&gt;(edges, (decimal edge) =&gt; this.ContainsEdge(edge))" vb="System.Linq.Enumerable.All(edges, (edge As TEdge) =&gt; Me.ContainsEdge(edge))">decimal.All&lt;decimal&gt;(edges, (decimal edge) =&gt; this.ContainsEdge(edge))</ensures>
      <ensures csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(edges, (decimal edge) =&gt; !this.ContainsEdge(edge)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(edges, (edge As TEdge) =&gt; Not Me.ContainsEdge(edge)))">result == old(decimal.Count&lt;decimal&gt;(edges, (decimal edge) =&gt; !this.ContainsEdge(edge)))</ensures>
      <ensures csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + Contract.Result&lt;int&gt;()" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + Contract.Result(Of Integer )()">this.EdgeCount == old(this.EdgeCount) + result</ensures>
    </member>
    <member name="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)">
      <summary>
            Removes <paramref name="edge" /> from the graph
            </summary>
      <param name="edge" />
      <returns>true if <paramref name="edge" /> was successfully removed; otherwise false.</returns>
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures csharp="Contract.Result&lt;bool&gt;() == Contract.Old(this.ContainsEdge(edge))" vb="Contract.Result(Of Boolean )() = Contract.Old(Me.ContainsEdge(edge))">result == old(this.ContainsEdge(edge))</ensures>
      <ensures csharp="!this.ContainsEdge(edge)" vb="Not Me.ContainsEdge(edge)">!this.ContainsEdge(edge)</ensures>
      <ensures csharp="this.EdgeCount == Contract.Old(this.EdgeCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) - (Contract.Result(Of Boolean )() ? 1 : 0)">this.EdgeCount == old(this.EdgeCount) - (result ? 1 : 0)</ensures>
    </member>
    <member name="E:QuickGraph.IMutableEdgeListGraph`2.EdgeRemoved">
      <summary>
            Raised when an edge has been removed from the graph.
            </summary>
    </member>
    <member name="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})">
      <summary>
            Removes all edges that match <paramref name="predicate" />.
            </summary>
      <param name="predicate">A pure delegate that takes an <typeparamref name="TEdge" /> and returns true if the edge should be removed.</param>
      <returns>the number of edges removed.</returns>
      <requires csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return predicate != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return predicate &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return predicate != null; })()</requires>
      <ensures csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(this.Edges, (decimal e) =&gt; predicate(e)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(Me.Edges, (e As TEdge) =&gt; predicate(e)))">result == old(decimal.Count&lt;decimal&gt;(this.Edges, (decimal e) =&gt; predicate(e)))</ensures>
      <ensures csharp="decimal.All&lt;decimal&gt;(this.Edges, (decimal e) =&gt; !predicate(e))" vb="System.Linq.Enumerable.All(Me.Edges, (e As TEdge) =&gt; Not predicate(e))">decimal.All&lt;decimal&gt;(this.Edges, (decimal e) =&gt; !predicate(e))</ensures>
      <ensures csharp="this.EdgeCount == Contract.Old(this.EdgeCount) - Contract.Result&lt;int&gt;()" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) - Contract.Result(Of Integer )()">this.EdgeCount == old(this.EdgeCount) - result</ensures>
    </member>
    <member name="T:QuickGraph.IMutableGraph`2">
      <summary>
            A mutable graph instance
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="M:QuickGraph.IMutableGraph`2.Clear">
      <summary>
            Clears the vertex and edges
            </summary>
    </member>
    <member name="E:QuickGraph.IMutableGraph`2.Cleared">
      <summary>
            Called when the graph vertices and edges have been cleared.
            </summary>
    </member>
    <member name="T:QuickGraph.IMutableIncidenceGraph`2">
      <summary>
            A mutable incidence graph
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})">
      <summary>
            Removes all out edges of <paramref name="v" />
            where <paramref name="predicate" /> evalutes to true.
            </summary>
      <param name="v" />
      <param name="predicate" />
      <returns />
      <requires csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires csharp="predicate != null" vb="predicate &lt;&gt; Nothing">predicate != null</requires>
      <ensures csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(this.OutEdges(v), (decimal ve) =&gt; predicate(ve)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(Me.OutEdges(v), (ve As TEdge) =&gt; predicate(ve)))">result == old(decimal.Count&lt;decimal&gt;(this.OutEdges(v), (decimal ve) =&gt; predicate(ve)))</ensures>
      <ensures csharp="decimal.All&lt;decimal&gt;(this.OutEdges(v), (decimal ve) =&gt; !predicate(ve))" vb="System.Linq.Enumerable.All(Me.OutEdges(v), (ve As TEdge) =&gt; Not predicate(ve))">decimal.All&lt;decimal&gt;(this.OutEdges(v), (decimal ve) =&gt; !predicate(ve))</ensures>
    </member>
    <member name="M:QuickGraph.IMutableIncidenceGraph`2.ClearOutEdges(`0)">
      <summary>
            Trims the out edges of vertex <paramref name="v" /></summary>
      <param name="v" />
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures csharp="this.OutDegree(v) == 0" vb="Me.OutDegree(v) = 0">this.OutDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.IMutableIncidenceGraph`2.TrimEdgeExcess">
      <summary>
            Trims excess storage allocated for edges
            </summary>
    </member>
    <member name="T:QuickGraph.IMutableVertexAndEdgeListGraph`2">
      <summary>
            A mutable vertex and edge list graph
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="T:QuickGraph.IMutableVertexListGraph`2">
      <summary>
            A mutable vertex list graph
            </summary>
      <typeparam name="TVertex" />
      <typeparam name="TEdge" />
    </member>
    <member name="T:QuickGraph.IVertexAndEdgeListGraph`2">
      <summary>
            A directed graph where vertices and edges can be enumerated efficiently.
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:QuickGraph.SEdge`1">
      <summary>
            An struct based <see cref="T:QuickGraph.IEdge`1" /> implementation.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
    </member>
    <member name="M:QuickGraph.SEdge`1.#ctor(`0,`0)">
      <summary>
            Initializes a new instance of the <see cref="T:QuickGraph.SEdge`1" /> class.
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <ensures csharp="this.Source.Equals((object)source)" vb="Me.Source.Equals(((Object)source))">this.Source.Equals((object)source)</ensures>
      <ensures csharp="this.Target.Equals((object)target)" vb="Me.Target.Equals(((Object)target))">this.Target.Equals((object)target)</ensures>
    </member>
    <member name="P:QuickGraph.SEdge`1.Source">
      <summary>
            Gets the source vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.SEdge`1.Target">
      <summary>
            Gets the target vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.SEdge`1.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="T:QuickGraph.SUndirectedEdge`1">
      <summary>
            An struct based <see cref="T:QuickGraph.IUndirectedEdge`1" /> implementation.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
    </member>
    <member name="M:QuickGraph.SUndirectedEdge`1.#ctor(`0,`0)">
      <summary>
            Initializes a new instance of the <see cref="T:QuickGraph.SUndirectedEdge`1" /> class.
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires csharp="System.Collections.Generic.Comparer&lt;TVertex&gt;.Default.Compare(source, target) &lt;= 0" vb="System.Collections.Generic.Comparer(Of TVertex).Default.Compare(source, target) &lt;= 0">System.Collections.Generic.Comparer&lt;TVertex&gt;.Default.Compare(source, target) &lt;= 0</requires>
      <ensures csharp="this.Source.Equals((object)source)" vb="Me.Source.Equals(((Object)source))">this.Source.Equals((object)source)</ensures>
      <ensures csharp="this.Target.Equals((object)target)" vb="Me.Target.Equals(((Object)target))">this.Target.Equals((object)target)</ensures>
    </member>
    <member name="P:QuickGraph.SUndirectedEdge`1.Source">
      <summary>
            Gets the source vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.SUndirectedEdge`1.Target">
      <summary>
            Gets the target vertex
            </summary>
      <value />
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.SUndirectedEdge`1.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="T:QuickGraph.IVertexListGraph`2">
      <summary>
            A directed graph datastructure where out-edges can be traversed,
            i.e. a vertex set + implicit graph.
            </summary>
      <typeparam name="TVertex">The type of the vertex.</typeparam>
      <typeparam name="TEdge">The type of the edge.</typeparam>
    </member>
    <member name="T:QuickGraph.SReversedEdge`2">
      <summary>
            A reversed edge
            </summary>
      <typeparam name="TVertex">type of the vertices</typeparam>
      <typeparam name="TEdge">type of the edges</typeparam>
    </member>
    <member name="T:System.Diagnostics.Contracts.DummyContract">
      <summary>
            Ensures that System.Diagnostics.Contracts namespace exists 
            </summary>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.#ctor(System.Int32)">
      <requires csharp="vertexCount &gt; 0" vb="vertexCount &gt; 0">vertexCount &gt; 0</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.IsInEdgesEmpty(System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;bool&gt;() == this.InDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.InDegree(v) = 0">result == this.InDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.InDegree(System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.InEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.InEdges(v))">result == decimal.Count&lt;decimal&gt;(this.InEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.InEdges(System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="decimal.All&lt;decimal&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;(), delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))(), delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    Return edge.Target.Equals(((Object)v))
    Return False
})">decimal.All&lt;decimal&gt;(result, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.TryGetInEdges(System.Int32,System.Collections.Generic.IEnumerable{`0}@)">
      <pure />
      <ensures csharp="Contract.Result&lt;bool&gt;() == v &gt; this.VertexCount" vb="Contract.Result(Of Boolean )() = v &gt; Me.VertexCount">result == v &gt; this.VertexCount</ensures>
      <ensures csharp="Contract.Result&lt;bool&gt;() == edges != null" vb="Contract.Result(Of Boolean )() = edges &lt;&gt; Nothing">result == edges != null</ensures>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;bool&gt;() == this.ContainsVertex(v)" vb="Contract.Result(Of Boolean )() = Me.ContainsVertex(v)">result == this.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="!Contract.Result&lt;bool&gt;() || edges != null" vb="Not Contract.Result(Of Boolean )() OrElse edges &lt;&gt; Nothing">!result || edges != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="!Contract.Result&lt;bool&gt;() || decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})" vb="Not Contract.Result(Of Boolean )() OrElse System.Linq.Enumerable.All(edges, delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    Return edge.Target.Equals(((Object)v))
    Return False
})">!result || decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.InEdge(System.Int32,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="index &gt;= 0 &amp;&amp; index &lt; this.InDegree(v)" vb="index &gt;= 0 AndAlso index &lt; Me.InDegree(v)">index &gt;= 0 &amp;&amp; index &lt; this.InDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;decimal&gt;().Equals((object)decimal.ElementAt&lt;decimal&gt;(this.InEdges(v), index))" vb="Contract.Result(Of TEdge)().Equals(((Object)System.Linq.Enumerable.ElementAt(Me.InEdges(v), index)))">result.Equals((object)decimal.ElementAt&lt;decimal&gt;(this.InEdges(v), index))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.Degree(System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;int&gt;() == this.InDegree(v) + this.OutDegree(v)" vb="Contract.Result(Of Integer )() = Me.InDegree(v) + Me.OutDegree(v)">result == this.InDegree(v) + this.OutDegree(v)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.ContainsEdge(System.Int32,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.TryGetEdge(System.Int32,System.Int32,`0@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.TryGetEdges(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{`0}@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.IsOutEdgesEmpty(System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;bool&gt;() == this.OutDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.OutDegree(v) = 0">result == this.OutDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.OutDegree(System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.OutEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.OutEdges(v))">result == decimal.Count&lt;decimal&gt;(this.OutEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.OutEdges(System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.All&lt;decimal&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;(), (decimal e) =&gt; e.Source.Equals((decimal)v))" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))(), (e As TEdge) =&gt; e.Source.Equals(((Object)v)))">decimal.All&lt;decimal&gt;(result, (decimal e) =&gt; e.Source.Equals((decimal)v))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.TryGetOutEdges(System.Int32,System.Collections.Generic.IEnumerable{`0}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(!Contract.Result&lt;bool&gt;() || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0" vb="(Contract.Result(Of Boolean )() AndAlso Not (edges &lt;&gt; Nothing AndAlso System.Linq.Enumerable.All(edges, (e As TEdge) =&gt; e.Source.Equals(((Object)v))))) &lt;&gt; 0">(!result || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.OutEdge(System.Int32,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)" vb="index &gt;= 0 AndAlso index &lt; Me.OutDegree(v)">index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)Contract.Result&lt;decimal&gt;())" vb="System.Linq.Enumerable.ElementAt(Me.OutEdges(v), index).Equals(((Object)Contract.Result(Of TEdge)()))">decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)result)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.ContainsVertex(System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.ContainsEdge(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;bool&gt;() == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))" vb="Contract.Result(Of Boolean )() = System.Diagnostics.Contracts.Contract.Exists(Me.Edges, (e As TEdge) =&gt; e.Equals(((Object)edge)))">result == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.RemoveInEdgeIf(System.Int32,QuickGraph.EdgePredicate{System.Int32,`0})">
      <requires csharp="0 &lt;= v &amp;&amp; v &lt; this.VertexCount" vb="0 &lt;= v AndAlso v &lt; Me.VertexCount">0 &lt;= v &amp;&amp; v &lt; this.VertexCount</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.ClearInEdges(System.Int32)">
      <requires csharp="0 &lt;= v &amp;&amp; v &lt; this.VertexCount" vb="0 &lt;= v AndAlso v &lt; Me.VertexCount">0 &lt;= v &amp;&amp; v &lt; this.VertexCount</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.ClearEdges(System.Int32)">
      <requires csharp="0 &lt;= v &amp;&amp; v &lt; this.VertexCount" vb="0 &lt;= v AndAlso v &lt; Me.VertexCount">0 &lt;= v &amp;&amp; v &lt; this.VertexCount</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.RemoveOutEdgeIf(System.Int32,QuickGraph.EdgePredicate{System.Int32,`0})">
      <requires csharp="0 &lt;= v &amp;&amp; v &lt; this.VertexCount" vb="0 &lt;= v AndAlso v &lt; Me.VertexCount">0 &lt;= v &amp;&amp; v &lt; this.VertexCount</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.ClearOutEdges(System.Int32)">
      <requires csharp="0 &lt;= v &amp;&amp; v &lt; this.VertexCount" vb="0 &lt;= v AndAlso v &lt; Me.VertexCount">0 &lt;= v &amp;&amp; v &lt; this.VertexCount</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.AddEdge(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.ContainsVertex(edge.Source)" vb="Me.ContainsVertex(edge.Source)">this.ContainsVertex(edge.Source)</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.ContainsVertex(edge.Target)" vb="Me.ContainsVertex(edge.Target)">this.ContainsVertex(edge.Target)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.ContainsEdge(edge)" vb="Me.ContainsEdge(edge)">this.ContainsEdge(edge)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.Old(!this.ContainsEdge(edge))" vb="Me.AllowParallelEdges OrElse Contract.Result(Of Boolean )() = Contract.Old(Not Me.ContainsEdge(edge))">this.AllowParallelEdges || result == old(!this.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + (Contract.Result(Of Boolean )() ? 1 : 0)">this.EdgeCount == old(this.EdgeCount) + (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.AddEdgeRange(System.Collections.Generic.IEnumerable{`0})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__4_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__4_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()" vb="(() =&gt; {
    If Not System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType Then
    push edges;
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__4_0;
    If dup = Nothing Then
    pop
    push (edge As TEdge) =&gt; ((Object)edge) &lt;&gt; Nothing;
    &lt;&gt;9__4_0 = dup
    push System.Linq.Enumerable.All(pop, pop);
    else    push 1;
    return pop &lt;&gt; 0; })()">(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__4_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__4_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if (this.ContainsVertex(edge.Source))
    {
        return this.ContainsVertex(edge.Target);

    }
    return false;

})" vb="System.Linq.Enumerable.All(edges, delegate (edge As TEdge) {
    If Me.ContainsVertex(edge.Source) Then
    Return Me.ContainsVertex(edge.Target)
    Return False
})">decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if (this.ContainsVertex(edge.Source))
    {
        return this.ContainsVertex(edge.Target);

    }
    return false;

})</requires>
      <ensures description="all edge from edges belong to the graph" inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="decimal.All&lt;decimal&gt;(edges, (decimal edge) =&gt; this.ContainsEdge(edge))" vb="System.Linq.Enumerable.All(edges, (edge As TEdge) =&gt; Me.ContainsEdge(edge))">decimal.All&lt;decimal&gt;(edges, (decimal edge) =&gt; this.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(edges, (decimal edge) =&gt; !this.ContainsEdge(edge)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(edges, (edge As TEdge) =&gt; Not Me.ContainsEdge(edge)))">result == old(decimal.Count&lt;decimal&gt;(edges, (decimal edge) =&gt; !this.ContainsEdge(edge)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + Contract.Result&lt;int&gt;()" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + Contract.Result(Of Integer )()">this.EdgeCount == old(this.EdgeCount) + result</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.RemoveEdge(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="Contract.Result&lt;bool&gt;() == Contract.Old(this.ContainsEdge(edge))" vb="Contract.Result(Of Boolean )() = Contract.Old(Me.ContainsEdge(edge))">result == old(this.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="!this.ContainsEdge(edge)" vb="Not Me.ContainsEdge(edge)">!this.ContainsEdge(edge)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) - (Contract.Result(Of Boolean )() ? 1 : 0)">this.EdgeCount == old(this.EdgeCount) - (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.RemoveEdgeIf(QuickGraph.EdgePredicate{System.Int32,`0})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return predicate != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return predicate &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return predicate != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(this.Edges, (decimal e) =&gt; predicate(e)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(Me.Edges, (e As TEdge) =&gt; predicate(e)))">result == old(decimal.Count&lt;decimal&gt;(this.Edges, (decimal e) =&gt; predicate(e)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="decimal.All&lt;decimal&gt;(this.Edges, (decimal e) =&gt; !predicate(e))" vb="System.Linq.Enumerable.All(Me.Edges, (e As TEdge) =&gt; Not predicate(e))">decimal.All&lt;decimal&gt;(this.Edges, (decimal e) =&gt; !predicate(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) - Contract.Result&lt;int&gt;()" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) - Contract.Result(Of Integer )()">this.EdgeCount == old(this.EdgeCount) - result</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalMatrixGraph`1.#ctor(System.Int32,System.Int32,`0[0:,0:])">
      <requires csharp="vertexCount &gt; 0" vb="vertexCount &gt; 0">vertexCount &gt; 0</requires>
      <requires csharp="edgeCount &gt;= 0" vb="edgeCount &gt;= 0">edgeCount &gt;= 0</requires>
      <requires csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
      <requires csharp="vertexCount == edges.GetLength(0)" vb="vertexCount = edges.GetLength(0)">vertexCount == edges.GetLength(0)</requires>
      <requires csharp="vertexCount == edges.GetLength(1)" vb="vertexCount = edges.GetLength(1)">vertexCount == edges.GetLength(1)</requires>
    </member>
    <member name="P:QuickGraph.BidirectionalMatrixGraph`1.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;int&gt;(this.Vertices); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Vertices); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;int&gt;(this.Vertices); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionalMatrixGraph`1.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.VertexCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.VertexCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.VertexCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionalMatrixGraph`1.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Edges); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Edges); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Edges); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionalMatrixGraph`1.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.EdgeCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.EdgeCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.EdgeCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionalMatrixGraph`1.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        push Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;();
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))();
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__5_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__5_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push result;
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionalMatrixGraph`1.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;int&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Integer))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)">
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <ensures csharp="Contract.Result&lt;bool&gt;() == Contract.Old(!this.ContainsVertex(v))" vb="Contract.Result(Of Boolean )() = Contract.Old(Not Me.ContainsVertex(v))">result == old(!this.ContainsVertex(v))</ensures>
      <ensures csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</ensures>
      <ensures csharp="this.VertexCount == Contract.Old(this.VertexCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.VertexCount = Contract.Old(Me.VertexCount) + (Contract.Result(Of Boolean )() ? 1 : 0)">this.VertexCount == old(this.VertexCount) + (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})">
      <requires csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
      <requires csharp="(() =&gt; {
    {
        push vertices;
        push decimal.&lt;&gt;9__4_0;
        if (dup == default(decimal))
        {
            pop;
            push (decimal v) =&gt; (object)v != null;
            &lt;&gt;9__4_0 = dup;
        }
    }
    return decimal.All&lt;decimal&gt;(pop, pop); })()" vb="(() =&gt; {
    push vertices;
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__4_0;
    If dup = Nothing Then
    pop
    push (v As TVertex) =&gt; ((Object)v) &lt;&gt; Nothing;
    &lt;&gt;9__4_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push vertices;
        push decimal.&lt;&gt;9__4_0;
        if (dup == default(decimal))
        {
            pop;
            push (decimal v) =&gt; (object)v != null;
            &lt;&gt;9__4_0 = dup;
        }
    }
    return decimal.All&lt;decimal&gt;(pop, pop); })()</requires>
      <ensures csharp="decimal.All&lt;decimal&gt;(vertices, (decimal v) =&gt; this.ContainsVertex(v))" vb="System.Linq.Enumerable.All(vertices, (v As TVertex) =&gt; Me.ContainsVertex(v))">decimal.All&lt;decimal&gt;(vertices, (decimal v) =&gt; this.ContainsVertex(v))</ensures>
      <ensures csharp="this.VertexCount == Contract.Old(this.VertexCount) + Contract.Result&lt;int&gt;()" vb="Me.VertexCount = Contract.Old(Me.VertexCount) + Contract.Result(Of Integer )()">this.VertexCount == old(this.VertexCount) + result</ensures>
    </member>
    <member name="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)">
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <ensures csharp="Contract.Result&lt;bool&gt;() == Contract.Old(this.ContainsVertex(v))" vb="Contract.Result(Of Boolean )() = Contract.Old(Me.ContainsVertex(v))">result == old(this.ContainsVertex(v))</ensures>
      <ensures csharp="!this.ContainsVertex(v)" vb="Not Me.ContainsVertex(v)">!this.ContainsVertex(v)</ensures>
      <ensures csharp="this.VertexCount == Contract.Old(this.VertexCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.VertexCount = Contract.Old(Me.VertexCount) - (Contract.Result(Of Boolean )() ? 1 : 0)">this.VertexCount == old(this.VertexCount) - (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})">
      <requires csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return pred != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return pred &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return pred != null; })()</requires>
      <ensures csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(this.Vertices, (decimal v) =&gt; pred(v)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(Me.Vertices, (v As TVertex) =&gt; pred(v)))">result == old(decimal.Count&lt;decimal&gt;(this.Vertices, (decimal v) =&gt; pred(v)))</ensures>
      <ensures csharp="decimal.All&lt;decimal&gt;(this.Vertices, (decimal v) =&gt; !pred(v))" vb="System.Linq.Enumerable.All(Me.Vertices, (v As TVertex) =&gt; Not pred(v))">decimal.All&lt;decimal&gt;(this.Vertices, (decimal v) =&gt; !pred(v))</ensures>
      <ensures csharp="this.VertexCount == Contract.Old(this.VertexCount) - Contract.Result&lt;int&gt;()" vb="Me.VertexCount = Contract.Old(Me.VertexCount) - Contract.Result(Of Integer )()">this.VertexCount == old(this.VertexCount) - result</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.#ctor(System.Collections.Generic.Dictionary{`0,QuickGraph.ArrayBidirectionalGraph{`0,`1}.InOutEdges},System.Int32)">
      <requires csharp="vertexEdges != null" vb="vertexEdges &lt;&gt; Nothing">vertexEdges != null</requires>
      <requires csharp="edgeCount &gt;= 0" vb="edgeCount &gt;= 0">edgeCount &gt;= 0</requires>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.ContainsEdge(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.TryGetEdge(`0,`0,`1@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.IsOutEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;bool&gt;() == this.OutDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.OutDegree(v) = 0">result == this.OutDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.OutDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.OutEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.OutEdges(v))">result == decimal.Count&lt;decimal&gt;(this.OutEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.OutEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.All&lt;decimal&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;(), (decimal e) =&gt; e.Source.Equals((decimal)v))" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))(), (e As TEdge) =&gt; e.Source.Equals(((Object)v)))">decimal.All&lt;decimal&gt;(result, (decimal e) =&gt; e.Source.Equals((decimal)v))</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(!Contract.Result&lt;bool&gt;() || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0" vb="(Contract.Result(Of Boolean )() AndAlso Not (edges &lt;&gt; Nothing AndAlso System.Linq.Enumerable.All(edges, (e As TEdge) =&gt; e.Source.Equals(((Object)v))))) &lt;&gt; 0">(!result || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.OutEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)" vb="index &gt;= 0 AndAlso index &lt; Me.OutDegree(v)">index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)Contract.Result&lt;decimal&gt;())" vb="System.Linq.Enumerable.ElementAt(Me.OutEdges(v), index).Equals(((Object)Contract.Result(Of TEdge)()))">decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)result)</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.ContainsVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()</requires>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.ContainsEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;bool&gt;() == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))" vb="Contract.Result(Of Boolean )() = System.Diagnostics.Contracts.Contract.Exists(Me.Edges, (e As TEdge) =&gt; e.Equals(((Object)edge)))">result == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.IsInEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;bool&gt;() == this.InDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.InDegree(v) = 0">result == this.InDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.InDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.InEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.InEdges(v))">result == decimal.Count&lt;decimal&gt;(this.InEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.InEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="decimal.All&lt;decimal&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;(), delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))(), delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    Return edge.Target.Equals(((Object)v))
    Return False
})">decimal.All&lt;decimal&gt;(result, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;bool&gt;() == this.ContainsVertex(v)" vb="Contract.Result(Of Boolean )() = Me.ContainsVertex(v)">result == this.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="!Contract.Result&lt;bool&gt;() || edges != null" vb="Not Contract.Result(Of Boolean )() OrElse edges &lt;&gt; Nothing">!result || edges != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="!Contract.Result&lt;bool&gt;() || decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})" vb="Not Contract.Result(Of Boolean )() OrElse System.Linq.Enumerable.All(edges, delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    Return edge.Target.Equals(((Object)v))
    Return False
})">!result || decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.InEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="index &gt;= 0 &amp;&amp; index &lt; this.InDegree(v)" vb="index &gt;= 0 AndAlso index &lt; Me.InDegree(v)">index &gt;= 0 &amp;&amp; index &lt; this.InDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;decimal&gt;().Equals((object)decimal.ElementAt&lt;decimal&gt;(this.InEdges(v), index))" vb="Contract.Result(Of TEdge)().Equals(((Object)System.Linq.Enumerable.ElementAt(Me.InEdges(v), index)))">result.Equals((object)decimal.ElementAt&lt;decimal&gt;(this.InEdges(v), index))</ensures>
    </member>
    <member name="M:QuickGraph.ArrayBidirectionalGraph`2.Degree(`0)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;int&gt;() == this.InDegree(v) + this.OutDegree(v)" vb="Contract.Result(Of Integer )() = Me.InDegree(v) + Me.OutDegree(v)">result == this.InDegree(v) + this.OutDegree(v)</ensures>
    </member>
    <member name="P:QuickGraph.ArrayBidirectionalGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.VertexCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.VertexCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.VertexCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayBidirectionalGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Vertices); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Vertices); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Vertices); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayBidirectionalGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TVertex&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TVertex))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayBidirectionalGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.EdgeCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.EdgeCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.EdgeCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayBidirectionalGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Edges); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Edges); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Edges); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayBidirectionalGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        push Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;();
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))();
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__5_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__5_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push result;
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.DelegateBidirectionalIncidenceGraph`2.#ctor(QuickGraph.TryFunc{`0,System.Collections.Generic.IEnumerable{`1}},QuickGraph.TryFunc{`0,System.Collections.Generic.IEnumerable{`1}})">
      <requires csharp="tryGetInEdges != null" vb="tryGetInEdges &lt;&gt; Nothing">tryGetInEdges != null</requires>
    </member>
    <member name="M:QuickGraph.DelegateBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;bool&gt;() == this.InDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.InDegree(v) = 0">result == this.InDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.DelegateBidirectionalIncidenceGraph`2.InDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.InEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.InEdges(v))">result == decimal.Count&lt;decimal&gt;(this.InEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.DelegateBidirectionalIncidenceGraph`2.InEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="decimal.All&lt;decimal&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;(), delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))(), delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    Return edge.Target.Equals(((Object)v))
    Return False
})">decimal.All&lt;decimal&gt;(result, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.DelegateBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;bool&gt;() == this.ContainsVertex(v)" vb="Contract.Result(Of Boolean )() = Me.ContainsVertex(v)">result == this.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="!Contract.Result&lt;bool&gt;() || edges != null" vb="Not Contract.Result(Of Boolean )() OrElse edges &lt;&gt; Nothing">!result || edges != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="!Contract.Result&lt;bool&gt;() || decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})" vb="Not Contract.Result(Of Boolean )() OrElse System.Linq.Enumerable.All(edges, delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    Return edge.Target.Equals(((Object)v))
    Return False
})">!result || decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.DelegateBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="index &gt;= 0 &amp;&amp; index &lt; this.InDegree(v)" vb="index &gt;= 0 AndAlso index &lt; Me.InDegree(v)">index &gt;= 0 &amp;&amp; index &lt; this.InDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;decimal&gt;().Equals((object)decimal.ElementAt&lt;decimal&gt;(this.InEdges(v), index))" vb="Contract.Result(Of TEdge)().Equals(((Object)System.Linq.Enumerable.ElementAt(Me.InEdges(v), index)))">result.Equals((object)decimal.ElementAt&lt;decimal&gt;(this.InEdges(v), index))</ensures>
    </member>
    <member name="M:QuickGraph.DelegateBidirectionalIncidenceGraph`2.Degree(`0)">
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;int&gt;() == this.InDegree(v) + this.OutDegree(v)" vb="Contract.Result(Of Integer )() = Me.InDegree(v) + Me.OutDegree(v)">result == this.InDegree(v) + this.OutDegree(v)</ensures>
    </member>
    <member name="M:QuickGraph.EnumerableContract.ElementsNotNull``1(System.Collections.Generic.IEnumerable{``0})">
      <pure />
      <requires csharp="elements != null" vb="elements &lt;&gt; Nothing">elements != null</requires>
    </member>
    <member name="M:QuickGraph.EnumerableContract.All(System.Int32,System.Int32,System.Func{System.Int32,System.Boolean})">
      <pure />
    </member>
    <member name="M:QuickGraph.EdgeExtensions.IsPath``2(System.Collections.Generic.IEnumerable{``1})">
      <pure />
      <requires csharp="path != null" vb="path &lt;&gt; Nothing">path != null</requires>
      <requires csharp="(() =&gt; {
    {
        if (!System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType)
        {
            push path;
            push QuickGraph.EdgeExtensions.&lt;&gt;c__11&lt;TVertex, TEdge&gt;.&lt;&gt;9__11_0;
            if (dup == default(System.Func&lt;TEdge, bool&gt;))
            {
                pop;
                push (TEdge e) =&gt; (object)e != null;
                &lt;&gt;9__11_0 = dup;
            }
            push System.Linq.Enumerable.All&lt;TEdge&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()" vb="(() =&gt; {
    If Not System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType Then
    push path;
    push QuickGraph.EdgeExtensions.&lt;&gt;c__11(Of TVertex, TEdge).&lt;&gt;9__11_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__11_0 = dup
    push System.Linq.Enumerable.All(pop, pop);
    else    push 1;
    return pop &lt;&gt; 0; })()">(() =&gt; {
    {
        if (!System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType)
        {
            push path;
            push QuickGraph.EdgeExtensions.&lt;&gt;c__11&lt;TVertex, TEdge&gt;.&lt;&gt;9__11_0;
            if (dup == default(System.Func&lt;TEdge, bool&gt;))
            {
                pop;
                push (TEdge e) =&gt; (object)e != null;
                &lt;&gt;9__11_0 = dup;
            }
            push System.Linq.Enumerable.All&lt;TEdge&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()</requires>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.HasCycles``2(System.Collections.Generic.IEnumerable{``1})">
      <pure />
      <requires csharp="path != null" vb="path &lt;&gt; Nothing">path != null</requires>
      <requires csharp="(() =&gt; {
    {
        if (!System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType)
        {
            push path;
            push QuickGraph.EdgeExtensions.&lt;&gt;c__12&lt;TVertex, TEdge&gt;.&lt;&gt;9__12_0;
            if (dup == default(System.Func&lt;TEdge, bool&gt;))
            {
                pop;
                push (TEdge e) =&gt; (object)e != null;
                &lt;&gt;9__12_0 = dup;
            }
            push System.Linq.Enumerable.All&lt;TEdge&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()" vb="(() =&gt; {
    If Not System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType Then
    push path;
    push QuickGraph.EdgeExtensions.&lt;&gt;c__12(Of TVertex, TEdge).&lt;&gt;9__12_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__12_0 = dup
    push System.Linq.Enumerable.All(pop, pop);
    else    push 1;
    return pop &lt;&gt; 0; })()">(() =&gt; {
    {
        if (!System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType)
        {
            push path;
            push QuickGraph.EdgeExtensions.&lt;&gt;c__12&lt;TVertex, TEdge&gt;.&lt;&gt;9__12_0;
            if (dup == default(System.Func&lt;TEdge, bool&gt;))
            {
                pop;
                push (TEdge e) =&gt; (object)e != null;
                &lt;&gt;9__12_0 = dup;
            }
            push System.Linq.Enumerable.All&lt;TEdge&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()</requires>
    </member>
    <member name="M:QuickGraph.EdgeExtensions.IsPathWithoutCycles``2(System.Collections.Generic.IEnumerable{``1})">
      <pure />
      <requires csharp="path != null" vb="path &lt;&gt; Nothing">path != null</requires>
      <requires csharp="(() =&gt; {
    {
        if (!System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType)
        {
            push path;
            push QuickGraph.EdgeExtensions.&lt;&gt;c__13&lt;TVertex, TEdge&gt;.&lt;&gt;9__13_0;
            if (dup == default(System.Func&lt;TEdge, bool&gt;))
            {
                pop;
                push (TEdge e) =&gt; (object)e != null;
                &lt;&gt;9__13_0 = dup;
            }
            push System.Linq.Enumerable.All&lt;TEdge&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()" vb="(() =&gt; {
    If Not System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType Then
    push path;
    push QuickGraph.EdgeExtensions.&lt;&gt;c__13(Of TVertex, TEdge).&lt;&gt;9__13_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__13_0 = dup
    push System.Linq.Enumerable.All(pop, pop);
    else    push 1;
    return pop &lt;&gt; 0; })()">(() =&gt; {
    {
        if (!System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType)
        {
            push path;
            push QuickGraph.EdgeExtensions.&lt;&gt;c__13&lt;TVertex, TEdge&gt;.&lt;&gt;9__13_0;
            if (dup == default(System.Func&lt;TEdge, bool&gt;))
            {
                pop;
                push (TEdge e) =&gt; (object)e != null;
                &lt;&gt;9__13_0 = dup;
            }
            push System.Linq.Enumerable.All&lt;TEdge&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()</requires>
      <requires csharp="QuickGraph.EdgeExtensions.IsPath&lt;TVertex, TEdge&gt;(path)" vb="QuickGraph.EdgeExtensions.IsPath(path)">QuickGraph.EdgeExtensions.IsPath&lt;TVertex, TEdge&gt;(path)</requires>
    </member>
    <member name="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)">
      <pure />
      <requires csharp="(object)v != null" vb="((Object)v) &lt;&gt; Nothing">(object)v != null</requires>
      <requires csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
      <ensures csharp="decimal.All&lt;TEdge&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;(), delegate (TEdge edge) {
    if ((decimal)edge != default(decimal))
    {
        if (this.ContainsEdge(edge.Source, edge.Target))
        {
            if (!edge.Source.Equals((decimal)v))
            {
                return edge.Target.Equals((decimal)v);

            }
            return true;

        }
    }
    return false;

})" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))(), delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    If Me.ContainsEdge(edge.Source, edge.Target) Then
    If Not edge.Source.Equals(((Object)v)) Then
    Return edge.Target.Equals(((Object)v))
    Return True
    Return False
})">decimal.All&lt;TEdge&gt;(result, delegate (TEdge edge) {
    if ((decimal)edge != default(decimal))
    {
        if (this.ContainsEdge(edge.Source, edge.Target))
        {
            if (!edge.Source.Equals((decimal)v))
            {
                return edge.Target.Equals((decimal)v);

            }
            return true;

        }
    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)">
      <pure />
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.AdjacentEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.AdjacentEdges(v))">result == decimal.Count&lt;decimal&gt;(this.AdjacentEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)">
      <pure />
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures csharp="Contract.Result&lt;bool&gt;() == this.AdjacentDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.AdjacentDegree(v) = 0">result == this.AdjacentDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)">
      <pure />
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures csharp="(object)Contract.Result&lt;decimal&gt;() != null" vb="((Object)Contract.Result(Of TEdge)()) &lt;&gt; Nothing">(object)result != null</ensures>
      <ensures csharp="Contract.Result&lt;decimal&gt;().Source.Equals((object)v) || Contract.Result&lt;decimal&gt;().Target.Equals((object)v)" vb="Contract.Result(Of TEdge)().Source.Equals(((Object)v)) OrElse Contract.Result(Of TEdge)().Target.Equals(((Object)v))">result.Source.Equals((object)v) || result.Target.Equals((object)v)</ensures>
    </member>
    <member name="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)">
      <pure />
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
    </member>
    <member name="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)">
      <pure />
      <requires csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)source != null; })()</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <ensures csharp="Contract.Result&lt;bool&gt;() == decimal.Any&lt;decimal&gt;(this.AdjacentEdges(source), delegate (decimal e) {
    if (!e.Target.Equals((decimal)target))
    {
        return e.Source.Equals((decimal)target);

    }
    return true;

})" vb="Contract.Result(Of Boolean )() = System.Linq.Enumerable.Any(Me.AdjacentEdges(source), delegate (e As TEdge) {
    If Not e.Target.Equals(((Object)target)) Then
    Return e.Source.Equals(((Object)target))
    Return True
})">result == decimal.Any&lt;decimal&gt;(this.AdjacentEdges(source), delegate (decimal e) {
    if (!e.Target.Equals((decimal)target))
    {
        return e.Source.Equals((decimal)target);

    }
    return true;

})</ensures>
    </member>
    <member name="P:QuickGraph.IImplicitUndirectedGraph`2.EdgeEqualityComparer">
      <getter>
        <ensures csharp="Contract.Result&lt;QuickGraph.EdgeEqualityComparer&lt;TVertex, TEdge&gt;&gt;() != null" vb="Contract.Result(Of QuickGraph.EdgeEqualityComparer(Of TVertex, TEdge))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.STaggedEquatableEdge`2.#ctor(`0,`0,`1)">
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
    </member>
    <member name="P:QuickGraph.STaggedEquatableEdge`2.Source">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.STaggedEquatableEdge`2.Target">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.UndirectedBidirectionalGraph`2.#ctor(QuickGraph.IBidirectionalGraph{`0,`1})">
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.UndirectedBidirectionalGraph`2.AdjacentEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)v != null" vb="((Object)v) &lt;&gt; Nothing">(object)v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="decimal.All&lt;TEdge&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;(), delegate (TEdge edge) {
    if ((decimal)edge != default(decimal))
    {
        if (this.ContainsEdge(edge.Source, edge.Target))
        {
            if (!edge.Source.Equals((decimal)v))
            {
                return edge.Target.Equals((decimal)v);

            }
            return true;

        }
    }
    return false;

})" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))(), delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    If Me.ContainsEdge(edge.Source, edge.Target) Then
    If Not edge.Source.Equals(((Object)v)) Then
    Return edge.Target.Equals(((Object)v))
    Return True
    Return False
})">decimal.All&lt;TEdge&gt;(result, delegate (TEdge edge) {
    if ((decimal)edge != default(decimal))
    {
        if (this.ContainsEdge(edge.Source, edge.Target))
        {
            if (!edge.Source.Equals((decimal)v))
            {
                return edge.Target.Equals((decimal)v);

            }
            return true;

        }
    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedBidirectionalGraph`2.AdjacentDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.AdjacentEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.AdjacentEdges(v))">result == decimal.Count&lt;decimal&gt;(this.AdjacentEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedBidirectionalGraph`2.IsAdjacentEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;bool&gt;() == this.AdjacentDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.AdjacentDegree(v) = 0">result == this.AdjacentDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedBidirectionalGraph`2.AdjacentEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)Contract.Result&lt;decimal&gt;() != null" vb="((Object)Contract.Result(Of TEdge)()) &lt;&gt; Nothing">(object)result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;decimal&gt;().Source.Equals((object)v) || Contract.Result&lt;decimal&gt;().Target.Equals((object)v)" vb="Contract.Result(Of TEdge)().Source.Equals(((Object)v)) OrElse Contract.Result(Of TEdge)().Target.Equals(((Object)v))">result.Source.Equals((object)v) || result.Target.Equals((object)v)</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedBidirectionalGraph`2.ContainsEdge(`0,`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;bool&gt;() == decimal.Any&lt;decimal&gt;(this.AdjacentEdges(source), delegate (decimal e) {
    if (!e.Target.Equals((decimal)target))
    {
        return e.Source.Equals((decimal)target);

    }
    return true;

})" vb="Contract.Result(Of Boolean )() = System.Linq.Enumerable.Any(Me.AdjacentEdges(source), delegate (e As TEdge) {
    If Not e.Target.Equals(((Object)target)) Then
    Return e.Source.Equals(((Object)target))
    Return True
})">result == decimal.Any&lt;decimal&gt;(this.AdjacentEdges(source), delegate (decimal e) {
    if (!e.Target.Equals((decimal)target))
    {
        return e.Source.Equals((decimal)target);

    }
    return true;

})</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedBidirectionalGraph`2.TryGetEdge(`0,`0,`1@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
    </member>
    <member name="M:QuickGraph.UndirectedBidirectionalGraph`2.ContainsVertex(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()</requires>
    </member>
    <member name="M:QuickGraph.UndirectedBidirectionalGraph`2.ContainsEdge(`1)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;bool&gt;() == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))" vb="Contract.Result(Of Boolean )() = System.Diagnostics.Contracts.Contract.Exists(Me.Edges, (e As TEdge) =&gt; e.Equals(((Object)edge)))">result == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))</ensures>
    </member>
    <member name="P:QuickGraph.UndirectedBidirectionalGraph`2.EdgeEqualityComparer">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.get_EdgeEqualityComparer" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;QuickGraph.EdgeEqualityComparer&lt;TVertex, TEdge&gt;&gt;() != null" vb="Contract.Result(Of QuickGraph.EdgeEqualityComparer(Of TVertex, TEdge))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.UndirectedBidirectionalGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.VertexCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.VertexCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.VertexCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.UndirectedBidirectionalGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Vertices); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Vertices); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Vertices); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.UndirectedBidirectionalGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TVertex&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TVertex))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.UndirectedBidirectionalGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.EdgeCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.EdgeCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.EdgeCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.UndirectedBidirectionalGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Edges); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Edges); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Edges); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.UndirectedBidirectionalGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        push Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;();
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))();
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__5_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__5_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push result;
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.SReversedEdge`2.#ctor(`1)">
      <requires csharp="(object)originalEdge != null" vb="((Object)originalEdge) &lt;&gt; Nothing">(object)originalEdge != null</requires>
    </member>
    <member name="M:QuickGraph.SReversedEdge`2.Equals(System.Object)">
      <pure />
    </member>
    <member name="M:QuickGraph.SReversedEdge`2.GetHashCode">
      <pure />
    </member>
    <member name="M:QuickGraph.SReversedEdge`2.ToString">
      <pure />
    </member>
    <member name="M:QuickGraph.SReversedEdge`2.Equals(QuickGraph.SReversedEdge{`0,`1})">
      <pure />
    </member>
    <member name="P:QuickGraph.SReversedEdge`2.Source">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.SReversedEdge`2.Target">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.#ctor(System.Collections.Generic.Dictionary{`0,QuickGraph.CompressedSparseRowGraph{`0}.Range},`0[])">
      <requires csharp="outEdgeStartRanges != null" vb="outEdgeStartRanges &lt;&gt; Nothing">outEdgeStartRanges != null</requires>
      <requires csharp="outEdges != null" vb="outEdges &lt;&gt; Nothing">outEdges != null</requires>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.FromGraph``1(QuickGraph.IVertexAndEdgeListGraph{`0,``0})">
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
      <ensures csharp="Contract.Result&lt;QuickGraph.CompressedSparseRowGraph&lt;TVertex&gt;&gt;() != null" vb="Contract.Result(Of QuickGraph.CompressedSparseRowGraph(Of TVertex))() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.ContainsVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()</requires>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.ContainsEdge(QuickGraph.SEquatableEdge{`0})">
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;bool&gt;() == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))" vb="Contract.Result(Of Boolean )() = System.Diagnostics.Contracts.Contract.Exists(Me.Edges, (e As QuickGraph.SEquatableEdge(Of Decimal)) =&gt; e.Equals(((Object)edge)))">result == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))</ensures>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.ContainsEdge(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{QuickGraph.SEquatableEdge{`0}}@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.TryGetEdge(`0,`0,QuickGraph.SEquatableEdge{`0}@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.IsOutEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;bool&gt;() == this.OutDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.OutDegree(v) = 0">result == this.OutDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.OutDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.OutEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.OutEdges(v))">result == decimal.Count&lt;decimal&gt;(this.OutEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.OutEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.All&lt;decimal&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;(), (decimal e) =&gt; e.Source.Equals((decimal)v))" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))(), (e As QuickGraph.SEquatableEdge(Of Decimal)) =&gt; e.Source.Equals(((Object)v)))">decimal.All&lt;decimal&gt;(result, (decimal e) =&gt; e.Source.Equals((decimal)v))</ensures>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{QuickGraph.SEquatableEdge{`0}}@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(!Contract.Result&lt;bool&gt;() || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0" vb="(Contract.Result(Of Boolean )() AndAlso Not (edges &lt;&gt; Nothing AndAlso System.Linq.Enumerable.All(edges, (e As QuickGraph.SEquatableEdge(Of Decimal)) =&gt; e.Source.Equals(((Object)v))))) &lt;&gt; 0">(!result || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0</ensures>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.OutEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)" vb="index &gt;= 0 AndAlso index &lt; Me.OutDegree(v)">index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)Contract.Result&lt;decimal&gt;())" vb="System.Linq.Enumerable.ElementAt(Me.OutEdges(v), index).Equals(((Object)Contract.Result(Of QuickGraph.SEquatableEdge(Of Decimal))()))">decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)result)</ensures>
    </member>
    <member name="M:QuickGraph.CompressedSparseRowGraph`1.Range.#ctor(System.Int32,System.Int32)">
      <requires csharp="start &gt;= 0" vb="start &gt;= 0">start &gt;= 0</requires>
      <requires csharp="start &lt;= end" vb="start &lt;= end">start &lt;= end</requires>
      <ensures csharp="this.Start == start" vb="Me.Start = start">this.Start == start</ensures>
      <ensures csharp="this.End == end" vb="Me.End = end">this.End == end</ensures>
    </member>
    <member name="P:QuickGraph.CompressedSparseRowGraph`1.Range.Length">
      <getter>
        <ensures csharp="Contract.Result&lt;int&gt;() &gt;= 0" vb="Contract.Result(Of Integer )() &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.CompressedSparseRowGraph`1.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.VertexCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.VertexCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.VertexCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.CompressedSparseRowGraph`1.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Vertices); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Vertices); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Vertices); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.CompressedSparseRowGraph`1.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TVertex&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TVertex))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.CompressedSparseRowGraph`1.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Edges); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Edges); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Edges); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.CompressedSparseRowGraph`1.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.EdgeCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.EdgeCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.EdgeCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.CompressedSparseRowGraph`1.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;QuickGraph.SEquatableEdge&lt;TVertex&gt;&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of QuickGraph.SEquatableEdge(Of TVertex)))() &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        push Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;QuickGraph.SEquatableEdge&lt;TVertex&gt;&gt;&gt;();
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (QuickGraph.SEquatableEdge&lt;TVertex&gt; e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;QuickGraph.SEquatableEdge&lt;TVertex&gt;&gt;(pop, pop); })()" vb="(() =&gt; {
    push Contract.Result(Of System.Collections.Generic.IEnumerable(Of QuickGraph.SEquatableEdge(Of TVertex)))();
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__5_0;
    If dup = Nothing Then
    pop
    push (e As QuickGraph.SEquatableEdge(Of TVertex)) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__5_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push result;
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (QuickGraph.SEquatableEdge&lt;TVertex&gt; e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;QuickGraph.SEquatableEdge&lt;TVertex&gt;&gt;(pop, pop); })()</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.#ctor(QuickGraph.IVertexAndEdgeListGraph{`0,`1})">
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.#ctor(System.Collections.Generic.Dictionary{`0,`1[]},System.Int32)">
      <requires csharp="vertexOutEdges != null" vb="vertexOutEdges &lt;&gt; Nothing">vertexOutEdges != null</requires>
      <requires csharp="edgeCount &gt;= 0" vb="edgeCount &gt;= 0">edgeCount &gt;= 0</requires>
      <requires csharp="(() =&gt; {
    {
        push edgeCount;
        push vertexOutEdges;
        push QuickGraph.ArrayAdjacencyGraph&lt;TVertex, TEdge&gt;.&lt;&gt;c.&lt;&gt;9__3_0;
        if (dup == default(System.Func&lt;System.Collections.Generic.KeyValuePair&lt;TVertex, TEdge[]&gt;, int&gt;))
        {
            pop;
            push delegate (System.Collections.Generic.KeyValuePair&lt;TVertex, TEdge[]&gt; kv) {
                if (kv.Value != default(decimal))
                {
                    return kv.Value.Length;

                }
                return 0;

            };
            &lt;&gt;9__3_0 = dup;
        }
    }
    return pop == System.Linq.Enumerable.Sum&lt;System.Collections.Generic.KeyValuePair&lt;TVertex, TEdge[]&gt;&gt;(pop, pop); })()" vb="(() =&gt; {
    push edgeCount;
    push vertexOutEdges;
    push QuickGraph.ArrayAdjacencyGraph(Of TVertex, TEdge).&lt;&gt;c.&lt;&gt;9__3_0;
    If dup = Nothing Then
    pop
    push delegate (kv As System.Collections.Generic.KeyValuePair(Of TVertex, TEdge())) {
        If kv.Value &lt;&gt; Nothing Then
        Return kv.Value.Length
        Return 0
    };
    &lt;&gt;9__3_0 = dup
    return pop = System.Linq.Enumerable.Sum(pop, pop); })()">(() =&gt; {
    {
        push edgeCount;
        push vertexOutEdges;
        push QuickGraph.ArrayAdjacencyGraph&lt;TVertex, TEdge&gt;.&lt;&gt;c.&lt;&gt;9__3_0;
        if (dup == default(System.Func&lt;System.Collections.Generic.KeyValuePair&lt;TVertex, TEdge[]&gt;, int&gt;))
        {
            pop;
            push delegate (System.Collections.Generic.KeyValuePair&lt;TVertex, TEdge[]&gt; kv) {
                if (kv.Value != default(decimal))
                {
                    return kv.Value.Length;

                }
                return 0;

            };
            &lt;&gt;9__3_0 = dup;
        }
    }
    return pop == System.Linq.Enumerable.Sum&lt;System.Collections.Generic.KeyValuePair&lt;TVertex, TEdge[]&gt;&gt;(pop, pop); })()</requires>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.ContainsEdge(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.TryGetEdge(`0,`0,`1@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.IsOutEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;bool&gt;() == this.OutDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.OutDegree(v) = 0">result == this.OutDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.OutDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.OutEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.OutEdges(v))">result == decimal.Count&lt;decimal&gt;(this.OutEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.OutEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.All&lt;decimal&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;(), (decimal e) =&gt; e.Source.Equals((decimal)v))" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))(), (e As TEdge) =&gt; e.Source.Equals(((Object)v)))">decimal.All&lt;decimal&gt;(result, (decimal e) =&gt; e.Source.Equals((decimal)v))</ensures>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(!Contract.Result&lt;bool&gt;() || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0" vb="(Contract.Result(Of Boolean )() AndAlso Not (edges &lt;&gt; Nothing AndAlso System.Linq.Enumerable.All(edges, (e As TEdge) =&gt; e.Source.Equals(((Object)v))))) &lt;&gt; 0">(!result || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0</ensures>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.OutEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)" vb="index &gt;= 0 AndAlso index &lt; Me.OutDegree(v)">index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)Contract.Result&lt;decimal&gt;())" vb="System.Linq.Enumerable.ElementAt(Me.OutEdges(v), index).Equals(((Object)Contract.Result(Of TEdge)()))">decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)result)</ensures>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.ContainsVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()</requires>
    </member>
    <member name="M:QuickGraph.ArrayAdjacencyGraph`2.ContainsEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;bool&gt;() == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))" vb="Contract.Result(Of Boolean )() = System.Diagnostics.Contracts.Contract.Exists(Me.Edges, (e As TEdge) =&gt; e.Equals(((Object)edge)))">result == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))</ensures>
    </member>
    <member name="P:QuickGraph.ArrayAdjacencyGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.VertexCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.VertexCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.VertexCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayAdjacencyGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Vertices); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Vertices); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Vertices); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayAdjacencyGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TVertex&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TVertex))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayAdjacencyGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.EdgeCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.EdgeCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.EdgeCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayAdjacencyGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Edges); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Edges); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Edges); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayAdjacencyGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        push Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;();
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))();
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__5_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__5_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push result;
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.DelegateIncidenceGraph`2.ContainsEdge(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.DelegateIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.DelegateIncidenceGraph`2.TryGetEdge(`0,`0,`1@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.TaggedEdge`2.#ctor(`0,`0,`1)">
      <ensures csharp="object.Equals((object)this.Tag, (object)tag)" vb="System.Object.Equals(((Object)Me.Tag), ((Object)tag))">object.Equals((object)this.Tag, (object)tag)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.#ctor(System.Boolean,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <requires csharp="vertexComparer != null" vb="vertexComparer &lt;&gt; Nothing">vertexComparer != null</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.#ctor(System.Boolean,System.Int32,System.Func{System.Int32,QuickGraph.Collections.IVertexEdgeDictionary{`0,`1}})">
      <requires csharp="vertexEdgesDictionaryFactory != null" vb="vertexEdgesDictionaryFactory &lt;&gt; Nothing">vertexEdgesDictionaryFactory != null</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.ContainsVertex(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.IsOutEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;bool&gt;() == this.OutDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.OutDegree(v) = 0">result == this.OutDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.OutDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.OutEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.OutEdges(v))">result == decimal.Count&lt;decimal&gt;(this.OutEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.OutEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.All&lt;decimal&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;(), (decimal e) =&gt; e.Source.Equals((decimal)v))" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))(), (e As TEdge) =&gt; e.Source.Equals(((Object)v)))">decimal.All&lt;decimal&gt;(result, (decimal e) =&gt; e.Source.Equals((decimal)v))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;bool&gt;() == this.ContainsVertex(v)" vb="Contract.Result(Of Boolean )() = Me.ContainsVertex(v)">result == this.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="!Contract.Result&lt;bool&gt;() || edges != null" vb="Not Contract.Result(Of Boolean )() OrElse edges &lt;&gt; Nothing">!result || edges != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="!Contract.Result&lt;bool&gt;() || decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})" vb="Not Contract.Result(Of Boolean )() OrElse System.Linq.Enumerable.All(edges, delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    Return edge.Target.Equals(((Object)v))
    Return False
})">!result || decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(!Contract.Result&lt;bool&gt;() || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0" vb="(Contract.Result(Of Boolean )() AndAlso Not (edges &lt;&gt; Nothing AndAlso System.Linq.Enumerable.All(edges, (e As TEdge) =&gt; e.Source.Equals(((Object)v))))) &lt;&gt; 0">(!result || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.OutEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)" vb="index &gt;= 0 AndAlso index &lt; Me.OutDegree(v)">index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)Contract.Result&lt;decimal&gt;())" vb="System.Linq.Enumerable.ElementAt(Me.OutEdges(v), index).Equals(((Object)Contract.Result(Of TEdge)()))">decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)result)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.IsInEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;bool&gt;() == this.InDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.InDegree(v) = 0">result == this.InDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.InDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.InEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.InEdges(v))">result == decimal.Count&lt;decimal&gt;(this.InEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.InEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="decimal.All&lt;decimal&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;(), delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))(), delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    Return edge.Target.Equals(((Object)v))
    Return False
})">decimal.All&lt;decimal&gt;(result, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.InEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="index &gt;= 0 &amp;&amp; index &lt; this.InDegree(v)" vb="index &gt;= 0 AndAlso index &lt; Me.InDegree(v)">index &gt;= 0 &amp;&amp; index &lt; this.InDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;decimal&gt;().Equals((object)decimal.ElementAt&lt;decimal&gt;(this.InEdges(v), index))" vb="Contract.Result(Of TEdge)().Equals(((Object)System.Linq.Enumerable.ElementAt(Me.InEdges(v), index)))">result.Equals((object)decimal.ElementAt&lt;decimal&gt;(this.InEdges(v), index))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.Degree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;int&gt;() == this.InDegree(v) + this.OutDegree(v)" vb="Contract.Result(Of Integer )() = Me.InDegree(v) + Me.OutDegree(v)">result == this.InDegree(v) + this.OutDegree(v)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.ContainsEdge(`0,`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.TryGetEdge(`0,`0,`1@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.ContainsEdge(`1)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;bool&gt;() == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))" vb="Contract.Result(Of Boolean )() = System.Diagnostics.Contracts.Contract.Exists(Me.Edges, (e As TEdge) =&gt; e.Equals(((Object)edge)))">result == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.AddVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="Contract.Result&lt;bool&gt;() == Contract.Old(!this.ContainsVertex(v))" vb="Contract.Result(Of Boolean )() = Contract.Old(Not Me.ContainsVertex(v))">result == old(!this.ContainsVertex(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="this.VertexCount == Contract.Old(this.VertexCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.VertexCount = Contract.Old(Me.VertexCount) + (Contract.Result(Of Boolean )() ? 1 : 0)">this.VertexCount == old(this.VertexCount) + (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.AddVertexRange(System.Collections.Generic.IEnumerable{`0})">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="(() =&gt; {
    {
        push vertices;
        push decimal.&lt;&gt;9__4_0;
        if (dup == default(decimal))
        {
            pop;
            push (decimal v) =&gt; (object)v != null;
            &lt;&gt;9__4_0 = dup;
        }
    }
    return decimal.All&lt;decimal&gt;(pop, pop); })()" vb="(() =&gt; {
    push vertices;
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__4_0;
    If dup = Nothing Then
    pop
    push (v As TVertex) =&gt; ((Object)v) &lt;&gt; Nothing;
    &lt;&gt;9__4_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push vertices;
        push decimal.&lt;&gt;9__4_0;
        if (dup == default(decimal))
        {
            pop;
            push (decimal v) =&gt; (object)v != null;
            &lt;&gt;9__4_0 = dup;
        }
    }
    return decimal.All&lt;decimal&gt;(pop, pop); })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="decimal.All&lt;decimal&gt;(vertices, (decimal v) =&gt; this.ContainsVertex(v))" vb="System.Linq.Enumerable.All(vertices, (v As TVertex) =&gt; Me.ContainsVertex(v))">decimal.All&lt;decimal&gt;(vertices, (decimal v) =&gt; this.ContainsVertex(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="this.VertexCount == Contract.Old(this.VertexCount) + Contract.Result&lt;int&gt;()" vb="Me.VertexCount = Contract.Old(Me.VertexCount) + Contract.Result(Of Integer )()">this.VertexCount == old(this.VertexCount) + result</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.RemoveVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="Contract.Result&lt;bool&gt;() == Contract.Old(this.ContainsVertex(v))" vb="Contract.Result(Of Boolean )() = Contract.Old(Me.ContainsVertex(v))">result == old(this.ContainsVertex(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="!this.ContainsVertex(v)" vb="Not Me.ContainsVertex(v)">!this.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="this.VertexCount == Contract.Old(this.VertexCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.VertexCount = Contract.Old(Me.VertexCount) - (Contract.Result(Of Boolean )() ? 1 : 0)">this.VertexCount == old(this.VertexCount) - (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.RemoveVertexIf(QuickGraph.VertexPredicate{`0})">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return pred != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return pred &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return pred != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(this.Vertices, (decimal v) =&gt; pred(v)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(Me.Vertices, (v As TVertex) =&gt; pred(v)))">result == old(decimal.Count&lt;decimal&gt;(this.Vertices, (decimal v) =&gt; pred(v)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="decimal.All&lt;decimal&gt;(this.Vertices, (decimal v) =&gt; !pred(v))" vb="System.Linq.Enumerable.All(Me.Vertices, (v As TVertex) =&gt; Not pred(v))">decimal.All&lt;decimal&gt;(this.Vertices, (decimal v) =&gt; !pred(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="this.VertexCount == Contract.Old(this.VertexCount) - Contract.Result&lt;int&gt;()" vb="Me.VertexCount = Contract.Old(Me.VertexCount) - Contract.Result(Of Integer )()">this.VertexCount == old(this.VertexCount) - result</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.AddEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.ContainsVertex(edge.Source)" vb="Me.ContainsVertex(edge.Source)">this.ContainsVertex(edge.Source)</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.ContainsVertex(edge.Target)" vb="Me.ContainsVertex(edge.Target)">this.ContainsVertex(edge.Target)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.ContainsEdge(edge)" vb="Me.ContainsEdge(edge)">this.ContainsEdge(edge)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.Old(!this.ContainsEdge(edge))" vb="Me.AllowParallelEdges OrElse Contract.Result(Of Boolean )() = Contract.Old(Not Me.ContainsEdge(edge))">this.AllowParallelEdges || result == old(!this.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + (Contract.Result(Of Boolean )() ? 1 : 0)">this.EdgeCount == old(this.EdgeCount) + (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__4_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__4_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()" vb="(() =&gt; {
    If Not System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType Then
    push edges;
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__4_0;
    If dup = Nothing Then
    pop
    push (edge As TEdge) =&gt; ((Object)edge) &lt;&gt; Nothing;
    &lt;&gt;9__4_0 = dup
    push System.Linq.Enumerable.All(pop, pop);
    else    push 1;
    return pop &lt;&gt; 0; })()">(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__4_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__4_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if (this.ContainsVertex(edge.Source))
    {
        return this.ContainsVertex(edge.Target);

    }
    return false;

})" vb="System.Linq.Enumerable.All(edges, delegate (edge As TEdge) {
    If Me.ContainsVertex(edge.Source) Then
    Return Me.ContainsVertex(edge.Target)
    Return False
})">decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if (this.ContainsVertex(edge.Source))
    {
        return this.ContainsVertex(edge.Target);

    }
    return false;

})</requires>
      <ensures description="all edge from edges belong to the graph" inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="decimal.All&lt;decimal&gt;(edges, (decimal edge) =&gt; this.ContainsEdge(edge))" vb="System.Linq.Enumerable.All(edges, (edge As TEdge) =&gt; Me.ContainsEdge(edge))">decimal.All&lt;decimal&gt;(edges, (decimal edge) =&gt; this.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(edges, (decimal edge) =&gt; !this.ContainsEdge(edge)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(edges, (edge As TEdge) =&gt; Not Me.ContainsEdge(edge)))">result == old(decimal.Count&lt;decimal&gt;(edges, (decimal edge) =&gt; !this.ContainsEdge(edge)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + Contract.Result&lt;int&gt;()" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + Contract.Result(Of Integer )()">this.EdgeCount == old(this.EdgeCount) + result</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.AddVerticesAndEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="this.ContainsEdge(edge)" vb="Me.ContainsEdge(edge)">this.ContainsEdge(edge)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="this.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.Old(!this.ContainsEdge(edge))" vb="Me.AllowParallelEdges OrElse Contract.Result(Of Boolean )() = Contract.Old(Not Me.ContainsEdge(edge))">this.AllowParallelEdges || result == old(!this.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + (Contract.Result(Of Boolean )() ? 1 : 0)">this.EdgeCount == old(this.EdgeCount) + (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return edges != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return edges &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return edges != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__1_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__1_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()" vb="(() =&gt; {
    If Not System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType Then
    push edges;
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__1_0;
    If dup = Nothing Then
    pop
    push (edge As TEdge) =&gt; ((Object)edge) &lt;&gt; Nothing;
    &lt;&gt;9__1_0 = dup
    push System.Linq.Enumerable.All(pop, pop);
    else    push 1;
    return pop &lt;&gt; 0; })()">(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__1_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__1_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + Contract.Result&lt;int&gt;()" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + Contract.Result(Of Integer )()">this.EdgeCount == old(this.EdgeCount) + result</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.RemoveEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="Contract.Result&lt;bool&gt;() == Contract.Old(this.ContainsEdge(edge))" vb="Contract.Result(Of Boolean )() = Contract.Old(Me.ContainsEdge(edge))">result == old(this.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="!this.ContainsEdge(edge)" vb="Not Me.ContainsEdge(edge)">!this.ContainsEdge(edge)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) - (Contract.Result(Of Boolean )() ? 1 : 0)">this.EdgeCount == old(this.EdgeCount) - (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return predicate != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return predicate &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return predicate != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(this.Edges, (decimal e) =&gt; predicate(e)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(Me.Edges, (e As TEdge) =&gt; predicate(e)))">result == old(decimal.Count&lt;decimal&gt;(this.Edges, (decimal e) =&gt; predicate(e)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="decimal.All&lt;decimal&gt;(this.Edges, (decimal e) =&gt; !predicate(e))" vb="System.Linq.Enumerable.All(Me.Edges, (e As TEdge) =&gt; Not predicate(e))">decimal.All&lt;decimal&gt;(this.Edges, (decimal e) =&gt; !predicate(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) - Contract.Result&lt;int&gt;()" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) - Contract.Result(Of Integer )()">this.EdgeCount == old(this.EdgeCount) - result</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph" csharp="predicate != null" vb="predicate &lt;&gt; Nothing">predicate != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph" csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(this.OutEdges(v), (decimal ve) =&gt; predicate(ve)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(Me.OutEdges(v), (ve As TEdge) =&gt; predicate(ve)))">result == old(decimal.Count&lt;decimal&gt;(this.OutEdges(v), (decimal ve) =&gt; predicate(ve)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph" csharp="decimal.All&lt;decimal&gt;(this.OutEdges(v), (decimal ve) =&gt; !predicate(ve))" vb="System.Linq.Enumerable.All(Me.OutEdges(v), (ve As TEdge) =&gt; Not predicate(ve))">decimal.All&lt;decimal&gt;(this.OutEdges(v), (decimal ve) =&gt; !predicate(ve))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.RemoveInEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.RemoveInEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableBidirectionalGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.RemoveInEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableBidirectionalGraph" csharp="edgePredicate != null" vb="edgePredicate &lt;&gt; Nothing">edgePredicate != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.RemoveInEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableBidirectionalGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.RemoveInEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableBidirectionalGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.RemoveInEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableBidirectionalGraph" csharp="decimal.All&lt;decimal&gt;(this.InEdges(v), (decimal e) =&gt; edgePredicate(e))" vb="System.Linq.Enumerable.All(Me.InEdges(v), (e As TEdge) =&gt; edgePredicate(e))">decimal.All&lt;decimal&gt;(this.InEdges(v), (decimal e) =&gt; edgePredicate(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.RemoveInEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableBidirectionalGraph" csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(this.InEdges(v), (decimal e) =&gt; edgePredicate(e)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(Me.InEdges(v), (e As TEdge) =&gt; edgePredicate(e)))">result == old(decimal.Count&lt;decimal&gt;(this.InEdges(v), (decimal e) =&gt; edgePredicate(e)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.RemoveInEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableBidirectionalGraph" csharp="this.InDegree(v) == Contract.Old(this.InDegree(v)) - Contract.Result&lt;int&gt;()" vb="Me.InDegree(v) = Contract.Old(Me.InDegree(v)) - Contract.Result(Of Integer )()">this.InDegree(v) == old(this.InDegree(v)) - result</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.ClearOutEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.ClearOutEdges(`0)" inheritedFromTypeName="IMutableIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.ClearOutEdges(`0)" inheritedFromTypeName="IMutableIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.ClearOutEdges(`0)" inheritedFromTypeName="IMutableIncidenceGraph" csharp="this.OutDegree(v) == 0" vb="Me.OutDegree(v) = 0">this.OutDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.ClearInEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.ClearInEdges(`0)" inheritedFromTypeName="IMutableBidirectionalGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.ClearInEdges(`0)" inheritedFromTypeName="IMutableBidirectionalGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.ClearInEdges(`0)" inheritedFromTypeName="IMutableBidirectionalGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) - Contract.Old(this.InDegree(v))" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) - Contract.Old(Me.InDegree(v))">this.EdgeCount == old(this.EdgeCount) - old(this.InDegree(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.ClearInEdges(`0)" inheritedFromTypeName="IMutableBidirectionalGraph" csharp="this.InDegree(v) == 0" vb="Me.InDegree(v) = 0">this.InDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.ClearEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.ClearEdges(`0)" inheritedFromTypeName="IMutableBidirectionalGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.ClearEdges(`0)" inheritedFromTypeName="IMutableBidirectionalGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableBidirectionalGraph`2.ClearEdges(`0)" inheritedFromTypeName="IMutableBidirectionalGraph" csharp="!this.ContainsVertex(v)" vb="Not Me.ContainsVertex(v)">!this.ContainsVertex(v)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.MergeVertex(`0,QuickGraph.EdgeFactory{`0,`1})">
      <requires csharp="QuickGraph.Contracts.GraphContract.InVertexSet&lt;TVertex&gt;(this, v)" vb="QuickGraph.Contracts.GraphContract.InVertexSet(Me, v)">QuickGraph.Contracts.GraphContract.InVertexSet&lt;TVertex&gt;(this, v)</requires>
      <requires csharp="edgeFactory != null" vb="edgeFactory &lt;&gt; Nothing">edgeFactory != null</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.MergeVertexIf(QuickGraph.VertexPredicate{`0},QuickGraph.EdgeFactory{`0,`1})">
      <requires csharp="vertexPredicate != null" vb="vertexPredicate &lt;&gt; Nothing">vertexPredicate != null</requires>
      <requires csharp="edgeFactory != null" vb="edgeFactory &lt;&gt; Nothing">edgeFactory != null</requires>
    </member>
    <member name="M:QuickGraph.BidirectionalGraph`2.#ctor(QuickGraph.Collections.IVertexEdgeDictionary{`0,`1},QuickGraph.Collections.IVertexEdgeDictionary{`0,`1},System.Int32,System.Int32,System.Boolean)">
      <requires csharp="vertexInEdges != null" vb="vertexInEdges &lt;&gt; Nothing">vertexInEdges != null</requires>
      <requires csharp="vertexOutEdges != null" vb="vertexOutEdges &lt;&gt; Nothing">vertexOutEdges != null</requires>
      <requires csharp="edgeCount &gt;= 0" vb="edgeCount &gt;= 0">edgeCount &gt;= 0</requires>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.EdgeType">
      <getter>
        <pure />
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.EdgeCapacity">
      <getter>
        <pure />
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.IsDirected">
      <getter>
        <pure />
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.AllowParallelEdges">
      <getter>
        <pure />
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.IsVerticesEmpty">
      <getter>
        <pure />
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.VertexCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.VertexCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.VertexCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.VertexCount">
      <getter>
        <pure />
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Vertices); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Vertices); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Vertices); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.Vertices">
      <getter>
        <pure />
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TVertex&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TVertex))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.EdgeCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.EdgeCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.EdgeCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Edges); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Edges); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Edges); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionalGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        push Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;();
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))();
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__5_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__5_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push result;
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Algorithms.MinimumSpanningTree.KruskalMinimumSpanningTreeAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IUndirectedGraph{`0,`1},System.Func{`1,System.Double})">
      <requires csharp="edgeWeights != null" vb="edgeWeights &lt;&gt; Nothing">edgeWeights != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.CentralityApproximationAlgorithm`2.#ctor(QuickGraph.IVertexListGraph{`0,`1},System.Func{`1,System.Double})">
      <requires csharp="distances != null" vb="distances &lt;&gt; Nothing">distances != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexPredecessorRecorderObserver`2.#ctor(System.Collections.Generic.Dictionary{`0,`1})">
      <requires csharp="vertexPredecessors != null" vb="vertexPredecessors &lt;&gt; Nothing">vertexPredecessors != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexPredecessorRecorderObserver`2.Attach(QuickGraph.Algorithms.ITreeBuilderAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="(object)algorithm != null" vb="((Object)algorithm) &lt;&gt; Nothing">(object)algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="Contract.Result&lt;System.IDisposable&gt;() != null" vb="Contract.Result(Of System.IDisposable)() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.EdgePredecessorRecorderObserver`2.#ctor(System.Collections.Generic.IDictionary{`1,`1},System.Collections.Generic.IList{`1})">
      <requires csharp="edgePredecessors != null" vb="edgePredecessors &lt;&gt; Nothing">edgePredecessors != null</requires>
      <requires csharp="endPathEdges != null" vb="endPathEdges &lt;&gt; Nothing">endPathEdges != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.EdgePredecessorRecorderObserver`2.Attach(QuickGraph.Algorithms.IEdgePredecessorRecorderAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="(object)algorithm != null" vb="((Object)algorithm) &lt;&gt; Nothing">(object)algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="Contract.Result&lt;System.IDisposable&gt;() != null" vb="Contract.Result(Of System.IDisposable)() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.EdgeRecorderObserver`2.#ctor(System.Collections.Generic.IList{`1})">
      <requires csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.EdgeRecorderObserver`2.Attach(QuickGraph.Algorithms.ITreeBuilderAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="(object)algorithm != null" vb="((Object)algorithm) &lt;&gt; Nothing">(object)algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="Contract.Result&lt;System.IDisposable&gt;() != null" vb="Contract.Result(Of System.IDisposable)() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.EdgeRecorderObserver`2.RecordEdge(`1)">
      <requires csharp="(object)args != null" vb="((Object)args) &lt;&gt; Nothing">(object)args != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexTimeStamperObserver`2.#ctor(System.Collections.Generic.Dictionary{`0,System.Int32})">
      <requires csharp="discoverTimes != null" vb="discoverTimes &lt;&gt; Nothing">discoverTimes != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexTimeStamperObserver`2.#ctor(System.Collections.Generic.Dictionary{`0,System.Int32},System.Collections.Generic.Dictionary{`0,System.Int32})">
      <requires csharp="discoverTimes != null" vb="discoverTimes &lt;&gt; Nothing">discoverTimes != null</requires>
      <requires csharp="finishTimes != null" vb="finishTimes &lt;&gt; Nothing">finishTimes != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexTimeStamperObserver`2.Attach(QuickGraph.Algorithms.IVertexTimeStamperAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="(object)algorithm != null" vb="((Object)algorithm) &lt;&gt; Nothing">(object)algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="Contract.Result&lt;System.IDisposable&gt;() != null" vb="Contract.Result(Of System.IDisposable)() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexRecorderObserver`2.#ctor(System.Collections.Generic.IList{`0})">
      <requires csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexRecorderObserver`2.Attach(QuickGraph.Algorithms.IVertexTimeStamperAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="(object)algorithm != null" vb="((Object)algorithm) &lt;&gt; Nothing">(object)algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="Contract.Result&lt;System.IDisposable&gt;() != null" vb="Contract.Result(Of System.IDisposable)() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.UndirectedVertexDistanceRecorderObserver`2.#ctor(System.Func{`1,System.Double},QuickGraph.Algorithms.IDistanceRelaxer,System.Collections.Generic.IDictionary{`0,System.Double})">
      <requires csharp="edgeWeights != null" vb="edgeWeights &lt;&gt; Nothing">edgeWeights != null</requires>
      <requires csharp="distanceRelaxer != null" vb="distanceRelaxer &lt;&gt; Nothing">distanceRelaxer != null</requires>
      <requires csharp="distances != null" vb="distances &lt;&gt; Nothing">distances != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.UndirectedVertexDistanceRecorderObserver`2.Attach(QuickGraph.Algorithms.IUndirectedTreeBuilderAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="(object)algorithm != null" vb="((Object)algorithm) &lt;&gt; Nothing">(object)algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="Contract.Result&lt;System.IDisposable&gt;() != null" vb="Contract.Result(Of System.IDisposable)() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.DisposableAction.#ctor(QuickGraph.Algorithms.Observers.DisposableAction.Action)">
      <requires csharp="action != null" vb="action &lt;&gt; Nothing">action != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.UndirectedVertexPredecessorRecorderObserver`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
      <requires csharp="vertexPredecessors != null" vb="vertexPredecessors &lt;&gt; Nothing">vertexPredecessors != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.UndirectedVertexPredecessorRecorderObserver`2.Attach(QuickGraph.Algorithms.IUndirectedTreeBuilderAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="(object)algorithm != null" vb="((Object)algorithm) &lt;&gt; Nothing">(object)algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="Contract.Result&lt;System.IDisposable&gt;() != null" vb="Contract.Result(Of System.IDisposable)() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexPredecessorPathRecorderObserver`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
      <requires csharp="vertexPredecessors != null" vb="vertexPredecessors &lt;&gt; Nothing">vertexPredecessors != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexPredecessorPathRecorderObserver`2.Attach(QuickGraph.Algorithms.IVertexPredecessorRecorderAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="(object)algorithm != null" vb="((Object)algorithm) &lt;&gt; Nothing">(object)algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="Contract.Result&lt;System.IDisposable&gt;() != null" vb="Contract.Result(Of System.IDisposable)() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexDistanceRecorderObserver`2.#ctor(System.Func{`1,System.Double},QuickGraph.Algorithms.IDistanceRelaxer,System.Collections.Generic.IDictionary{`0,System.Double})">
      <requires csharp="edgeWeights != null" vb="edgeWeights &lt;&gt; Nothing">edgeWeights != null</requires>
      <requires csharp="distanceRelaxer != null" vb="distanceRelaxer &lt;&gt; Nothing">distanceRelaxer != null</requires>
      <requires csharp="distances != null" vb="distances &lt;&gt; Nothing">distances != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Observers.VertexDistanceRecorderObserver`2.Attach(QuickGraph.Algorithms.ITreeBuilderAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="(object)algorithm != null" vb="((Object)algorithm) &lt;&gt; Nothing">(object)algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="Contract.Result&lt;System.IDisposable&gt;() != null" vb="Contract.Result(Of System.IDisposable)() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.Condensation.EdgeMergeCondensationGraphAlgorithm`2.#ctor(QuickGraph.IBidirectionalGraph{`0,`1},QuickGraph.IMutableBidirectionalGraph{`0,QuickGraph.Algorithms.Condensation.MergedEdge{`0,`1}},QuickGraph.VertexPredicate{`0})">
      <requires csharp="condensatedGraph != null" vb="condensatedGraph &lt;&gt; Nothing">condensatedGraph != null</requires>
      <requires csharp="vertexPredicate != null" vb="vertexPredicate &lt;&gt; Nothing">vertexPredicate != null</requires>
    </member>
    <member name="P:QuickGraph.Algorithms.IComputation.SyncRoot">
      <getter>
        <ensures csharp="Contract.Result&lt;object&gt;() != null" vb="Contract.Result(Of Object)() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Algorithms.IComputation.State">
      <getter>
        <ensures csharp="decimal.IsDefined(typeof(decimal), (decimal)Contract.Result&lt;decimal&gt;())" vb="System.Enum.IsDefined(typeof(QuickGraph.Algorithms.ComputationState), ((Object)Contract.Result(Of QuickGraph.Algorithms.ComputationState)()))">decimal.IsDefined(typeof(decimal), (decimal)result)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.DijkstraShortestPathAlgorithm`2.ComputeFromRoot(`0)">
      <requires csharp="(object)rootVertex != null" vb="((Object)rootVertex) &lt;&gt; Nothing">(object)rootVertex != null</requires>
      <requires csharp="this.VisitedGraph.ContainsVertex(rootVertex)" vb="Me.VisitedGraph.ContainsVertex(rootVertex)">this.VisitedGraph.ContainsVertex(rootVertex)</requires>
      <requires csharp="this.VertexColors.Item[rootVertex] == (QuickGraph.GraphColor)0" vb="Me.VertexColors.Item[rootVertex] = ((QuickGraph.GraphColor)0)">this.VertexColors.Item[rootVertex] == (QuickGraph.GraphColor)0</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.FloydWarshallAllShortestPathAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IVertexAndEdgeListGraph{`0,`1},System.Func{`1,System.Double},QuickGraph.Algorithms.IDistanceRelaxer)">
      <requires csharp="weights != null" vb="weights &lt;&gt; Nothing">weights != null</requires>
      <requires csharp="distanceRelaxer != null" vb="distanceRelaxer &lt;&gt; Nothing">distanceRelaxer != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.FloydWarshallAllShortestPathAlgorithm`2.#ctor(QuickGraph.IVertexAndEdgeListGraph{`0,`1},System.Func{`1,System.Double},QuickGraph.Algorithms.IDistanceRelaxer)">
      <requires csharp="weights != null" vb="weights &lt;&gt; Nothing">weights != null</requires>
      <requires csharp="distanceRelaxer != null" vb="distanceRelaxer &lt;&gt; Nothing">distanceRelaxer != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.FloydWarshallAllShortestPathAlgorithm`2.TryGetDistance(`0,`0,System.Double@)">
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.FloydWarshallAllShortestPathAlgorithm`2.TryGetPath(`0,`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
    </member>
    <member name="T:QuickGraph.Algorithms.ShortestPath.FloydWarshallAllShortestPathAlgorithm`2.VertexData">
      <invariant>!this.edgeStored || this._edge != null</invariant>
      <invariant>!this.predecessorStored || this._predecessor != null</invariant>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.FloydWarshallAllShortestPathAlgorithm`2.VertexData.#ctor(System.Double,`1)">
      <requires csharp="(object)edge != null" vb="((Object)edge) &lt;&gt; Nothing">(object)edge != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.FloydWarshallAllShortestPathAlgorithm`2.VertexData.#ctor(System.Double,`0)">
      <requires csharp="(object)predecessor != null" vb="((Object)predecessor) &lt;&gt; Nothing">(object)predecessor != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.AStarShortestPathAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IVertexListGraph{`0,`1},System.Func{`1,System.Double},System.Func{`0,System.Double},QuickGraph.Algorithms.IDistanceRelaxer)">
      <requires csharp="costHeuristic != null" vb="costHeuristic &lt;&gt; Nothing">costHeuristic != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.AStarShortestPathAlgorithm`2.ComputeFromRoot(`0)">
      <requires csharp="(object)rootVertex != null" vb="((Object)rootVertex) &lt;&gt; Nothing">(object)rootVertex != null</requires>
      <requires csharp="this.VisitedGraph.ContainsVertex(rootVertex)" vb="Me.VisitedGraph.ContainsVertex(rootVertex)">this.VisitedGraph.ContainsVertex(rootVertex)</requires>
      <requires csharp="this.VertexColors.Item[rootVertex] == (QuickGraph.GraphColor)0" vb="Me.VertexColors.Item[rootVertex] = ((QuickGraph.GraphColor)0)">this.VertexColors.Item[rootVertex] == (QuickGraph.GraphColor)0</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.ShortestPathAlgorithmBase`3.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,`2,System.Func{`1,System.Double},QuickGraph.Algorithms.IDistanceRelaxer)">
      <requires csharp="weights != null" vb="weights &lt;&gt; Nothing">weights != null</requires>
      <requires csharp="distanceRelaxer != null" vb="distanceRelaxer &lt;&gt; Nothing">distanceRelaxer != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.ShortestPathAlgorithmBase`3.TryGetDistance(`0,System.Double@)">
      <requires csharp="(object)vertex != null" vb="((Object)vertex) &lt;&gt; Nothing">(object)vertex != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.ShortestPathAlgorithmBase`3.Relax(`1)">
      <requires csharp="(object)e != null" vb="((Object)e) &lt;&gt; Nothing">(object)e != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.UndirectedShortestPathAlgorithmBase`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IUndirectedGraph{`0,`1},System.Func{`1,System.Double},QuickGraph.Algorithms.IDistanceRelaxer)">
      <requires csharp="weights != null" vb="weights &lt;&gt; Nothing">weights != null</requires>
      <requires csharp="distanceRelaxer != null" vb="distanceRelaxer &lt;&gt; Nothing">distanceRelaxer != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.UndirectedShortestPathAlgorithmBase`2.TryGetDistance(`0,System.Double@)">
      <requires csharp="(object)vertex != null" vb="((Object)vertex) &lt;&gt; Nothing">(object)vertex != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.UndirectedShortestPathAlgorithmBase`2.Relax(`1,`0,`0)">
      <requires csharp="(object)e != null" vb="((Object)e) &lt;&gt; Nothing">(object)e != null</requires>
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires csharp="(!(!e.Source.Equals((object)source) || !e.Target.Equals((object)target)) || e.Source.Equals((object)target) &amp;&amp; e.Target.Equals((object)source)) != 0" vb="(Not e.Source.Equals(((Object)source)) OrElse Not e.Target.Equals(((Object)target)) AndAlso Not (e.Source.Equals(((Object)target)) AndAlso e.Target.Equals(((Object)source)))) &lt;&gt; 0">(!(!e.Source.Equals((object)source) || !e.Target.Equals((object)target)) || e.Source.Equals((object)target) &amp;&amp; e.Target.Equals((object)source)) != 0</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.UndirectedDijkstraShortestPathAlgorithm`2.InternalTreeEdge(System.Object,QuickGraph.UndirectedEdgeEventArgs{`0,`1})">
      <requires csharp="args != null" vb="args &lt;&gt; Nothing">args != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.UndirectedDijkstraShortestPathAlgorithm`2.InternalGrayTarget(System.Object,QuickGraph.UndirectedEdgeEventArgs{`0,`1})">
      <requires csharp="args != null" vb="args &lt;&gt; Nothing">args != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.UndirectedDijkstraShortestPathAlgorithm`2.ComputeFromRoot(`0)">
      <requires csharp="(object)rootVertex != null" vb="((Object)rootVertex) &lt;&gt; Nothing">(object)rootVertex != null</requires>
      <requires csharp="this.VisitedGraph.ContainsVertex(rootVertex)" vb="Me.VisitedGraph.ContainsVertex(rootVertex)">this.VisitedGraph.ContainsVertex(rootVertex)</requires>
      <requires csharp="this.VertexColors.Item[rootVertex] == (QuickGraph.GraphColor)0" vb="Me.VertexColors.Item[rootVertex] = ((QuickGraph.GraphColor)0)">this.VertexColors.Item[rootVertex] == (QuickGraph.GraphColor)0</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ShortestPath.UndirectedDijkstraShortestPathAlgorithm`2.ComputeNoInit(`0)">
      <requires csharp="(object)s != null" vb="((Object)s) &lt;&gt; Nothing">(object)s != null</requires>
      <requires csharp="this.VisitedGraph.ContainsVertex(s)" vb="Me.VisitedGraph.ContainsVertex(s)">this.VisitedGraph.ContainsVertex(s)</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmBase`1.#ctor(`0)">
      <requires csharp="(object)visitedGraph != null" vb="((Object)visitedGraph) &lt;&gt; Nothing">(object)visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmBase`1.BeginComputation">
      <requires csharp="this.State == (QuickGraph.Algorithms.ComputationState)0" vb="Me.State = ((QuickGraph.Algorithms.ComputationState)0)">this.State == (QuickGraph.Algorithms.ComputationState)0</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmBase`1.EndComputation">
      <requires csharp="this.State == (QuickGraph.Algorithms.ComputationState)1 || this.State == (QuickGraph.Algorithms.ComputationState)4" vb="Me.State = ((QuickGraph.Algorithms.ComputationState)1) OrElse Me.State = ((QuickGraph.Algorithms.ComputationState)4)">this.State == (QuickGraph.Algorithms.ComputationState)1 || this.State == (QuickGraph.Algorithms.ComputationState)4</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmBase`1.TryGetService(System.Type,System.Object@)">
      <requires csharp="serviceType != null" vb="serviceType &lt;&gt; Nothing">serviceType != null</requires>
    </member>
    <member name="P:QuickGraph.Algorithms.AlgorithmBase`1.VisitedGraph">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.Algorithms.IAlgorithm`1.get_VisitedGraph" inheritedFromTypeName="IAlgorithm" csharp="(object)Contract.Result&lt;TGraph&gt;() != null" vb="((Object)Contract.Result(Of TGraph)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Algorithms.AlgorithmBase`1.SyncRoot">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.Algorithms.IComputation.get_SyncRoot" inheritedFromTypeName="IComputation" csharp="Contract.Result&lt;object&gt;() != null" vb="Contract.Result(Of Object)() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Algorithms.AlgorithmBase`1.State">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.Algorithms.IComputation.get_State" inheritedFromTypeName="IComputation" csharp="decimal.IsDefined(typeof(decimal), (decimal)Contract.Result&lt;decimal&gt;())" vb="System.Enum.IsDefined(typeof(QuickGraph.Algorithms.ComputationState), ((Object)Contract.Result(Of QuickGraph.Algorithms.ComputationState)()))">decimal.IsDefined(typeof(decimal), (decimal)result)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Algorithms.LengauerTarjanDominatorAlgorithm`2.TimeStampObserver.#ctor(System.Collections.Generic.List{`0})">
      <requires csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.LengauerTarjanDominatorAlgorithm`2.TimeStampObserver.Attach(QuickGraph.Algorithms.IVertexTimeStamperAlgorithm{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="(object)algorithm != null" vb="((Object)algorithm) &lt;&gt; Nothing">(object)algorithm != null</requires>
      <ensures inheritedFrom="M:QuickGraph.Algorithms.Observers.IObserver`1.Attach(`0)" inheritedFromTypeName="IObserver" csharp="Contract.Result&lt;System.IDisposable&gt;() != null" vb="Contract.Result(Of System.IDisposable)() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.RootedAlgorithmBase`2.SetRootVertex(`0)">
      <requires csharp="(object)rootVertex != null" vb="((Object)rootVertex) &lt;&gt; Nothing">(object)rootVertex != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RootedAlgorithmBase`2.OnRootVertexChanged(System.EventArgs)">
      <requires csharp="e != null" vb="e &lt;&gt; Nothing">e != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RootedAlgorithmBase`2.Compute(`0)">
      <requires csharp="(object)rootVertex != null" vb="((Object)rootVertex) &lt;&gt; Nothing">(object)rootVertex != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomGraphFactory.GetVertex``2(QuickGraph.IVertexListGraph{``0,``1},System.Random)">
      <requires csharp="g != null" vb="g &lt;&gt; Nothing">g != null</requires>
      <requires csharp="rnd != null" vb="rnd &lt;&gt; Nothing">rnd != null</requires>
      <requires csharp="g.VertexCount &gt; 0" vb="g.VertexCount &gt; 0">g.VertexCount &gt; 0</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomGraphFactory.GetVertex``2(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Random)">
      <requires csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
      <requires csharp="rnd != null" vb="rnd &lt;&gt; Nothing">rnd != null</requires>
      <requires csharp="count &gt; 0" vb="count &gt; 0">count &gt; 0</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomGraphFactory.GetEdge``2(QuickGraph.IEdgeSet{``0,``1},System.Random)">
      <requires csharp="g != null" vb="g &lt;&gt; Nothing">g != null</requires>
      <requires csharp="rnd != null" vb="rnd &lt;&gt; Nothing">rnd != null</requires>
      <requires csharp="g.EdgeCount &gt; 0" vb="g.EdgeCount &gt; 0">g.EdgeCount &gt; 0</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomGraphFactory.GetEdge``2(System.Collections.Generic.IEnumerable{``1},System.Int32,System.Random)">
      <requires csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
      <requires csharp="rnd != null" vb="rnd &lt;&gt; Nothing">rnd != null</requires>
      <requires csharp="count &gt; 0" vb="count &gt; 0">count &gt; 0</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomGraphFactory.Create``2(QuickGraph.IMutableVertexAndEdgeListGraph{``0,``1},QuickGraph.VertexFactory{``0},QuickGraph.EdgeFactory{``0,``1},System.Random,System.Int32,System.Int32,System.Boolean)">
      <requires csharp="g != null" vb="g &lt;&gt; Nothing">g != null</requires>
      <requires csharp="vertexFactory != null" vb="vertexFactory &lt;&gt; Nothing">vertexFactory != null</requires>
      <requires csharp="edgeFactory != null" vb="edgeFactory &lt;&gt; Nothing">edgeFactory != null</requires>
      <requires csharp="rnd != null" vb="rnd &lt;&gt; Nothing">rnd != null</requires>
      <requires csharp="vertexCount &gt; 0" vb="vertexCount &gt; 0">vertexCount &gt; 0</requires>
      <requires csharp="edgeCount &gt;= 0" vb="edgeCount &gt;= 0">edgeCount &gt;= 0</requires>
      <requires csharp="g.AllowParallelEdges || selfEdges || edgeCount &lt;= vertexCount * (vertexCount - 1)" vb="g.AllowParallelEdges OrElse selfEdges OrElse edgeCount &lt;= vertexCount * (vertexCount - 1)">g.AllowParallelEdges || selfEdges || edgeCount &lt;= vertexCount * (vertexCount - 1)</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomGraphFactory.Create``2(QuickGraph.IMutableUndirectedGraph{``0,``1},QuickGraph.VertexFactory{``0},QuickGraph.EdgeFactory{``0,``1},System.Random,System.Int32,System.Int32,System.Boolean)">
      <requires csharp="g != null" vb="g &lt;&gt; Nothing">g != null</requires>
      <requires csharp="vertexFactory != null" vb="vertexFactory &lt;&gt; Nothing">vertexFactory != null</requires>
      <requires csharp="edgeFactory != null" vb="edgeFactory &lt;&gt; Nothing">edgeFactory != null</requires>
      <requires csharp="rnd != null" vb="rnd &lt;&gt; Nothing">rnd != null</requires>
      <requires csharp="vertexCount &gt; 0" vb="vertexCount &gt; 0">vertexCount &gt; 0</requires>
      <requires csharp="edgeCount &gt;= 0" vb="edgeCount &gt;= 0">edgeCount &gt;= 0</requires>
      <requires csharp="g.AllowParallelEdges || selfEdges || edgeCount &lt;= vertexCount * (vertexCount - 1) / 2" vb="g.AllowParallelEdges OrElse selfEdges OrElse edgeCount &lt;= vertexCount * (vertexCount - 1) / 2">g.AllowParallelEdges || selfEdges || edgeCount &lt;= vertexCount * (vertexCount - 1) / 2</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.TarjanOfflineLeastCommonAncestorAlgorithm`2.SetVertexPairs(System.Collections.Generic.IEnumerable{QuickGraph.SEquatableEdge{`0}})">
      <requires csharp="pairs != null" vb="pairs &lt;&gt; Nothing">pairs != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.TarjanOfflineLeastCommonAncestorAlgorithm`2.Compute(`0,System.Collections.Generic.IEnumerable{QuickGraph.SEquatableEdge{`0}})">
      <requires csharp="(object)root != null" vb="((Object)root) &lt;&gt; Nothing">(object)root != null</requires>
      <requires csharp="pairs != null" vb="pairs &lt;&gt; Nothing">pairs != null</requires>
    </member>
    <member name="P:QuickGraph.Algorithms.IAlgorithm`1.VisitedGraph">
      <getter>
        <ensures csharp="(object)Contract.Result&lt;TGraph&gt;() != null" vb="((Object)Contract.Result(Of TGraph)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Algorithms.TopologicalSort.TopologicalSortAlgorithm`2.#ctor(QuickGraph.IVertexListGraph{`0,`1},System.Collections.Generic.IList{`0})">
      <requires csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.TopologicalSort.UndirectedFirstTopologicalSortAlgorithm`2.Compute(System.Collections.Generic.IList{`0})">
      <requires csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.TopologicalSort.UndirectedTopologicalSortAlgorithm`2.#ctor(QuickGraph.IUndirectedGraph{`0,`1},System.Collections.Generic.IList{`0})">
      <requires csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.TopologicalSort.SourceFirstTopologicalSortAlgorithm`2.Compute(System.Collections.Generic.IList{`0})">
      <requires csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Services.AlgorithmServices.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent)">
      <requires csharp="host != null" vb="host &lt;&gt; Nothing">host != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IBidirectionalGraph{`0,`1},System.Func{`1,System.Double},QuickGraph.Algorithms.IDistanceRelaxer)">
      <requires csharp="edgeWeights != null" vb="edgeWeights &lt;&gt; Nothing">edgeWeights != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm`2.SetGoalVertex(`0)">
      <requires csharp="(object)goalVertex != null" vb="((Object)goalVertex) &lt;&gt; Nothing">(object)goalVertex != null</requires>
      <requires csharp="this.VisitedGraph.ContainsVertex(goalVertex)" vb="Me.VisitedGraph.ContainsVertex(goalVertex)">this.VisitedGraph.ContainsVertex(goalVertex)</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm`2.Compute(`0,`0)">
      <requires csharp="(object)rootVertex != null" vb="((Object)rootVertex) &lt;&gt; Nothing">(object)rootVertex != null</requires>
      <requires csharp="(object)goalVertex != null" vb="((Object)goalVertex) &lt;&gt; Nothing">(object)goalVertex != null</requires>
      <requires csharp="this.VisitedGraph.ContainsVertex(rootVertex)" vb="Me.VisitedGraph.ContainsVertex(rootVertex)">this.VisitedGraph.ContainsVertex(rootVertex)</requires>
      <requires csharp="this.VisitedGraph.ContainsVertex(goalVertex)" vb="Me.VisitedGraph.ContainsVertex(goalVertex)">this.VisitedGraph.ContainsVertex(goalVertex)</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm`2.EnqueueFirstShortestPath(QuickGraph.Collections.IQueue{QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm{`0,`1}.DeviationPath},System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IDictionary{`0,System.Double},`0)">
      <requires csharp="queue != null" vb="queue &lt;&gt; Nothing">queue != null</requires>
      <requires csharp="queue.Count == 0" vb="queue.Count = 0">queue.Count == 0</requires>
      <requires csharp="successors != null" vb="successors &lt;&gt; Nothing">successors != null</requires>
      <requires csharp="distances != null" vb="distances &lt;&gt; Nothing">distances != null</requires>
      <requires csharp="(object)root != null" vb="((Object)root) &lt;&gt; Nothing">(object)root != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm`2.EnqueueDeviationPaths(QuickGraph.Collections.IQueue{QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm{`0,`1}.DeviationPath},`0,System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IDictionary{`0,System.Double},`1[],System.Int32)">
      <requires csharp="queue != null" vb="queue &lt;&gt; Nothing">queue != null</requires>
      <requires csharp="(object)root != null" vb="((Object)root) &lt;&gt; Nothing">(object)root != null</requires>
      <requires csharp="successors != null" vb="successors &lt;&gt; Nothing">successors != null</requires>
      <requires csharp="distances != null" vb="distances &lt;&gt; Nothing">distances != null</requires>
      <requires csharp="path != null" vb="path &lt;&gt; Nothing">path != null</requires>
      <requires csharp="QuickGraph.EdgeExtensions.IsAdjacent&lt;TVertex, TEdge&gt;(path[0], root)" vb="QuickGraph.EdgeExtensions.IsAdjacent(path(0), root)">QuickGraph.EdgeExtensions.IsAdjacent&lt;TVertex, TEdge&gt;(path[0], root)</requires>
      <requires csharp="0 &lt;= startEdge &amp;&amp; startEdge &lt; path.Length" vb="0 &lt;= startEdge AndAlso startEdge &lt; path.Length">0 &lt;= startEdge &amp;&amp; startEdge &lt; path.Length</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm`2.EnqueueDeviationPaths(QuickGraph.Collections.IQueue{QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm{`0,`1}.DeviationPath},System.Collections.Generic.IDictionary{`0,System.Double},`1[],System.Int32,`0,System.Double,System.Collections.Generic.Dictionary{`0,System.Int32})">
      <requires csharp="queue != null" vb="queue &lt;&gt; Nothing">queue != null</requires>
      <requires csharp="distances != null" vb="distances &lt;&gt; Nothing">distances != null</requires>
      <requires csharp="path != null" vb="path &lt;&gt; Nothing">path != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm`2.AppendShortestPath(System.Collections.Generic.List{`1},System.Collections.Generic.IDictionary{`0,`1},`0)">
      <requires csharp="path != null" vb="path &lt;&gt; Nothing">path != null</requires>
      <requires csharp="successors != null" vb="successors &lt;&gt; Nothing">successors != null</requires>
      <requires csharp="(object)startVertex != null" vb="((Object)startVertex) &lt;&gt; Nothing">(object)startVertex != null</requires>
      <ensures csharp="path.Item[path.Count - 1].Target.Equals((object)this.goalVertex)" vb="path.Item[path.Count - 1].Target.Equals(((Object)Me.goalVertex))">path.Item[path.Count - 1].Target.Equals((object)this.goalVertex)</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.HoffmanPavleyRankedShortestPathAlgorithm`2.DeviationPath.#ctor(`1[],System.Int32,`1,System.Double)">
      <requires csharp="parentPath != null" vb="parentPath &lt;&gt; Nothing">parentPath != null</requires>
      <requires csharp="0 &lt;= deviationIndex &amp;&amp; deviationIndex &lt; parentPath.Length" vb="0 &lt;= deviationIndex AndAlso deviationIndex &lt; parentPath.Length">0 &lt;= deviationIndex &amp;&amp; deviationIndex &lt; parentPath.Length</requires>
      <requires csharp="(object)deviationEdge != null" vb="((Object)deviationEdge) &lt;&gt; Nothing">(object)deviationEdge != null</requires>
      <requires csharp="weight &gt;= 0.0" vb="weight &gt;= 0">weight &gt;= 0.0</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.RankedShortestPathAlgorithmBase`3.AddComputedShortestPath(System.Collections.Generic.List{`1})">
      <requires csharp="path != null" vb="path &lt;&gt; Nothing">path != null</requires>
      <requires csharp="(() =&gt; {
    {
        push path;
        push QuickGraph.Algorithms.RankedShortestPath.RankedShortestPathAlgorithmBase&lt;TVertex, TEdge, TGraph&gt;.&lt;&gt;c.&lt;&gt;9__10_0;
        if (dup == default(System.Func&lt;TEdge, bool&gt;))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__10_0 = dup;
        }
    }
    return System.Linq.Enumerable.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push path;
    push QuickGraph.Algorithms.RankedShortestPath.RankedShortestPathAlgorithmBase(Of TVertex, TEdge, TGraph).&lt;&gt;c.&lt;&gt;9__10_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__10_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push path;
        push QuickGraph.Algorithms.RankedShortestPath.RankedShortestPathAlgorithmBase&lt;TVertex, TEdge, TGraph&gt;.&lt;&gt;c.&lt;&gt;9__10_0;
        if (dup == default(System.Func&lt;TEdge, bool&gt;))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__10_0 = dup;
        }
    }
    return System.Linq.Enumerable.All&lt;TEdge&gt;(pop, pop); })()</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RankedShortestPath.RankedShortestPathAlgorithmBase`3.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,`2,QuickGraph.Algorithms.IDistanceRelaxer)">
      <requires csharp="distanceRelaxer != null" vb="distanceRelaxer &lt;&gt; Nothing">distanceRelaxer != null</requires>
    </member>
    <member name="P:QuickGraph.Algorithms.RankedShortestPath.RankedShortestPathAlgorithmBase`3.ShortestPathCount">
      <setter>
        <requires csharp="value &gt; 1" vb="value &gt; 1">value &gt; 1</requires>
        <ensures csharp="this.ShortestPathCount == value" vb="Me.ShortestPathCount = value">this.ShortestPathCount == value</ensures>
      </setter>
    </member>
    <member name="P:QuickGraph.Algorithms.RankedShortestPath.RankedShortestPathAlgorithmBase`3.ComputedShortestPathCount">
      <getter>
        <ensures csharp="Contract.Result&lt;int&gt;() == System.Linq.Enumerable.Count&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;(this.ComputedShortestPaths)" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.ComputedShortestPaths)">result == System.Linq.Enumerable.Count&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;(this.ComputedShortestPaths)</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomWalks.CyclePoppingRandomTreeAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IVertexListGraph{`0,`1},QuickGraph.Algorithms.RandomWalks.IMarkovEdgeChain{`0,`1})">
      <requires csharp="edgeChain != null" vb="edgeChain &lt;&gt; Nothing">edgeChain != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomWalks.CyclePoppingRandomTreeAlgorithm`2.Tree(`0,`1)">
      <requires csharp="(object)next != null" vb="((Object)next) &lt;&gt; Nothing">(object)next != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomWalks.CyclePoppingRandomTreeAlgorithm`2.RandomTreeWithRoot(`0)">
      <requires csharp="(object)root != null" vb="((Object)root) &lt;&gt; Nothing">(object)root != null</requires>
      <requires csharp="this.VisitedGraph.ContainsVertex(root)" vb="Me.VisitedGraph.ContainsVertex(root)">this.VisitedGraph.ContainsVertex(root)</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomWalks.WeightedMarkovEdgeChainBase`2.#ctor(System.Collections.Generic.IDictionary{`1,System.Double})">
      <requires csharp="weights != null" vb="weights &lt;&gt; Nothing">weights != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomWalks.WeightedMarkovEdgeChainBase`2.TryGetSuccessor(QuickGraph.IImplicitGraph{`0,`1},`0,System.Double,`1@)">
      <requires csharp="g != null" vb="g &lt;&gt; Nothing">g != null</requires>
      <requires csharp="(object)u != null" vb="((Object)u) &lt;&gt; Nothing">(object)u != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomWalks.WeightedMarkovEdgeChainBase`2.TryGetSuccessor(System.Collections.Generic.IEnumerable{`1},System.Double,`1@)">
      <requires csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomWalks.RandomWalkAlgorithm`2.#ctor(QuickGraph.IImplicitGraph{`0,`1},QuickGraph.Algorithms.RandomWalks.IEdgeChain{`0,`1})">
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
      <requires csharp="edgeChain != null" vb="edgeChain &lt;&gt; Nothing">edgeChain != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomWalks.RandomWalkAlgorithm`2.Generate(`0)">
      <requires csharp="(object)root != null" vb="((Object)root) &lt;&gt; Nothing">(object)root != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RandomWalks.RandomWalkAlgorithm`2.Generate(`0,System.Int32)">
      <requires csharp="(object)root != null" vb="((Object)root) &lt;&gt; Nothing">(object)root != null</requires>
    </member>
    <member name="P:QuickGraph.Algorithms.RandomWalks.RandomWalkAlgorithm`2.EdgeChain">
      <setter>
        <requires csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      </setter>
    </member>
    <member name="M:QuickGraph.Algorithms.ConnectedComponents.ConnectedComponentsAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IUndirectedGraph{`0,`1},System.Collections.Generic.IDictionary{`0,System.Int32})">
      <requires csharp="components != null" vb="components &lt;&gt; Nothing">components != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ConnectedComponents.StronglyConnectedComponentsAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IVertexListGraph{`0,`1},System.Collections.Generic.IDictionary{`0,System.Int32})">
      <requires csharp="components != null" vb="components &lt;&gt; Nothing">components != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ConnectedComponents.StronglyConnectedComponentsAlgorithm`2.MinDiscoverTime(`0,`0)">
      <requires csharp="(object)u != null" vb="((Object)u) &lt;&gt; Nothing">(object)u != null</requires>
      <requires csharp="(object)v != null" vb="((Object)v) &lt;&gt; Nothing">(object)v != null</requires>
      <ensures csharp="this.DiscoverTimes.Item[u] &lt; this.DiscoverTimes.Item[v] ? Contract.Result&lt;TVertex&gt;().Equals((object)u) : Contract.Result&lt;TVertex&gt;().Equals((object)v)" vb="Me.DiscoverTimes.Item[u] &lt; Me.DiscoverTimes.Item[v] ? Contract.Result(Of TVertex)().Equals(((Object)u)) : Contract.Result(Of TVertex)().Equals(((Object)v))">this.DiscoverTimes.Item[u] &lt; this.DiscoverTimes.Item[v] ? result.Equals((object)u) : result.Equals((object)v)</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.ConnectedComponents.StronglyConnectedComponentsAlgorithm`2.InternalCompute">
      <ensures csharp="this.ComponentCount &gt;= 0" vb="Me.ComponentCount &gt;= 0">this.ComponentCount &gt;= 0</ensures>
      <ensures csharp="this.VisitedGraph.VertexCount == default(int) || this.ComponentCount &gt; 0" vb="Me.VisitedGraph.VertexCount = Nothing OrElse Me.ComponentCount &gt; 0">this.VisitedGraph.VertexCount == default(int) || this.ComponentCount &gt; 0</ensures>
      <ensures csharp="System.Linq.Enumerable.All&lt;TVertex&gt;(this.VisitedGraph.Vertices, (TVertex v) =&gt; this.get_Components.ContainsKey(v))" vb="System.Linq.Enumerable.All(Me.VisitedGraph.Vertices, (v As TVertex) =&gt; Me.get_Components.ContainsKey(v))">System.Linq.Enumerable.All&lt;TVertex&gt;(this.VisitedGraph.Vertices, (TVertex v) =&gt; this.get_Components.ContainsKey(v))</ensures>
      <ensures csharp="this.VisitedGraph.VertexCount == this.Components.Count" vb="Me.VisitedGraph.VertexCount = Me.Components.Count">this.VisitedGraph.VertexCount == this.Components.Count</ensures>
      <ensures csharp="System.Linq.Enumerable.All&lt;int&gt;(this.Components.Values, (int c) =&gt; c &lt;= this.ComponentCount)" vb="System.Linq.Enumerable.All(Me.Components.Values, (c As Integer ) =&gt; c &lt;= Me.ComponentCount)">System.Linq.Enumerable.All&lt;int&gt;(this.Components.Values, (int c) =&gt; c &lt;= this.ComponentCount)</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.ConnectedComponents.WeaklyConnectedComponentsAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IVertexListGraph{`0,`1},System.Collections.Generic.IDictionary{`0,System.Int32})">
      <requires csharp="components != null" vb="components &lt;&gt; Nothing">components != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.ConnectedComponents.WeaklyConnectedComponentsAlgorithm`2.InternalCompute">
      <ensures csharp="0 &lt;= this.ComponentCount &amp;&amp; !(this.ComponentCount &gt; this.VisitedGraph.VertexCount)" vb="0 &lt;= Me.ComponentCount AndAlso Not Me.ComponentCount &gt; Me.VisitedGraph.VertexCount">0 &lt;= this.ComponentCount &amp;&amp; !(this.ComponentCount &gt; this.VisitedGraph.VertexCount)</ensures>
      <ensures csharp="System.Linq.Enumerable.All&lt;TVertex&gt;(this.VisitedGraph.Vertices, delegate (TVertex v) {
    if (0 &lt;= this.get_Components.Item[v])
    {
        return this.get_Components.Item[v] &lt; this.ComponentCount;

    }
    return false;

})" vb="System.Linq.Enumerable.All(Me.VisitedGraph.Vertices, delegate (v As TVertex) {
    If 0 &lt;= Me.get_Components.Item[v] Then
    Return Me.get_Components.Item[v] &lt; Me.ComponentCount
    Return False
})">System.Linq.Enumerable.All&lt;TVertex&gt;(this.VisitedGraph.Vertices, delegate (TVertex v) {
    if (0 &lt;= this.get_Components.Item[v])
    {
        return this.get_Components.Item[v] &lt; this.ComponentCount;

    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.EdmondsKarpMaximumFlowAlgorithm`2.Augment(`0,`0)">
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
      <requires csharp="(object)sink != null" vb="((Object)sink) &lt;&gt; Nothing">(object)sink != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphAugmentorAlgorithmBase`3.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,`2,QuickGraph.VertexFactory{`0},QuickGraph.EdgeFactory{`0,`1})">
      <requires csharp="vertexFactory != null" vb="vertexFactory &lt;&gt; Nothing">vertexFactory != null</requires>
      <requires csharp="edgeFactory != null" vb="edgeFactory &lt;&gt; Nothing">edgeFactory != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphAugmentorAlgorithmBase`3.OnSuperSourceAdded(`0)">
      <requires csharp="(object)v != null" vb="((Object)v) &lt;&gt; Nothing">(object)v != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphAugmentorAlgorithmBase`3.OnSuperSinkAdded(`0)">
      <requires csharp="(object)v != null" vb="((Object)v) &lt;&gt; Nothing">(object)v != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphAugmentorAlgorithmBase`3.OnEdgeAdded(`1)">
      <requires csharp="(object)e != null" vb="((Object)e) &lt;&gt; Nothing">(object)e != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.ReversedEdgeAugmentorAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IMutableVertexAndEdgeListGraph{`0,`1},QuickGraph.EdgeFactory{`0,`1})">
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
      <requires csharp="edgeFactory != null" vb="edgeFactory &lt;&gt; Nothing">edgeFactory != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphBalancerAlgorithm`2.#ctor(QuickGraph.IMutableBidirectionalGraph{`0,`1},`0,`0,QuickGraph.VertexFactory{`0},QuickGraph.EdgeFactory{`0,`1})">
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
      <requires csharp="vertexFactory != null" vb="vertexFactory &lt;&gt; Nothing">vertexFactory != null</requires>
      <requires csharp="edgeFactory != null" vb="edgeFactory &lt;&gt; Nothing">edgeFactory != null</requires>
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
      <requires csharp="visitedGraph.ContainsVertex(source)" vb="visitedGraph.ContainsVertex(source)">visitedGraph.ContainsVertex(source)</requires>
      <requires csharp="(object)sink != null" vb="((Object)sink) &lt;&gt; Nothing">(object)sink != null</requires>
      <requires csharp="visitedGraph.ContainsVertex(sink)" vb="visitedGraph.ContainsVertex(sink)">visitedGraph.ContainsVertex(sink)</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphBalancerAlgorithm`2.#ctor(QuickGraph.IMutableBidirectionalGraph{`0,`1},QuickGraph.VertexFactory{`0},QuickGraph.EdgeFactory{`0,`1},`0,`0,System.Collections.Generic.IDictionary{`1,System.Double})">
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
      <requires csharp="vertexFactory != null" vb="vertexFactory &lt;&gt; Nothing">vertexFactory != null</requires>
      <requires csharp="edgeFactory != null" vb="edgeFactory &lt;&gt; Nothing">edgeFactory != null</requires>
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
      <requires csharp="visitedGraph.ContainsVertex(source)" vb="visitedGraph.ContainsVertex(source)">visitedGraph.ContainsVertex(source)</requires>
      <requires csharp="(object)sink != null" vb="((Object)sink) &lt;&gt; Nothing">(object)sink != null</requires>
      <requires csharp="visitedGraph.ContainsVertex(sink)" vb="visitedGraph.ContainsVertex(sink)">visitedGraph.ContainsVertex(sink)</requires>
      <requires csharp="capacities != null" vb="capacities &lt;&gt; Nothing">capacities != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphBalancerAlgorithm`2.OnEdgeAdded(`1)">
      <requires csharp="(object)edge != null" vb="((Object)edge) &lt;&gt; Nothing">(object)edge != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphBalancerAlgorithm`2.OnSurplusVertexAdded(`0)">
      <requires csharp="(object)vertex != null" vb="((Object)vertex) &lt;&gt; Nothing">(object)vertex != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphBalancerAlgorithm`2.OnDeficientVertexAdded(`0)">
      <requires csharp="(object)vertex != null" vb="((Object)vertex) &lt;&gt; Nothing">(object)vertex != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.GraphBalancerAlgorithm`2.GetBalancingIndex(`0)">
      <requires csharp="(object)v != null" vb="((Object)v) &lt;&gt; Nothing">(object)v != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumFlow.MaximumFlowAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IMutableVertexAndEdgeListGraph{`0,`1},System.Func{`1,System.Double},QuickGraph.EdgeFactory{`0,`1})">
      <requires csharp="capacities != null" vb="capacities &lt;&gt; Nothing">capacities != null</requires>
    </member>
    <member name="P:QuickGraph.Algorithms.MaximumFlow.MaximumFlowAlgorithm`2.Source">
      <setter>
        <requires csharp="(object)value != null" vb="((Object)value) &lt;&gt; Nothing">(object)value != null</requires>
      </setter>
    </member>
    <member name="P:QuickGraph.Algorithms.MaximumFlow.MaximumFlowAlgorithm`2.Sink">
      <setter>
        <requires csharp="(object)value != null" vb="((Object)value) &lt;&gt; Nothing">(object)value != null</requires>
      </setter>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.OnTreeEdge(`1)">
      <requires csharp="(object)e != null" vb="((Object)e) &lt;&gt; Nothing">(object)e != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.OnCircuitEdge(`1)">
      <requires csharp="(object)e != null" vb="((Object)e) &lt;&gt; Nothing">(object)e != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.OnVisitEdge(`1)">
      <requires csharp="(object)e != null" vb="((Object)e) &lt;&gt; Nothing">(object)e != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.EulerianTrailAlgorithm`2.Search(`0)">
      <requires csharp="(object)u != null" vb="((Object)u) &lt;&gt; Nothing">(object)u != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.TreeBreadthFirstSearch``2(QuickGraph.IVertexListGraph{``0,``1},``0)">
      <requires csharp="(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass3_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass3_0&lt;TVertex, TEdge&gt;();
    }
    return visitedGraph != null; })()" vb="(() =&gt; {
    QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass3_0&lt;TVertex, TEdge&gt; local_0 = New QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass3_0(Of TVertex, TEdge)();
    return visitedGraph &lt;&gt; Nothing; })()">(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass3_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass3_0&lt;TVertex, TEdge&gt;();
    }
    return visitedGraph != null; })()</requires>
      <requires csharp="(object)root != null" vb="((Object)root) &lt;&gt; Nothing">(object)root != null</requires>
      <requires csharp="visitedGraph.ContainsVertex(root)" vb="visitedGraph.ContainsVertex(root)">visitedGraph.ContainsVertex(root)</requires>
      <ensures csharp="Contract.Result&lt;QuickGraph.TryFunc&lt;TVertex, System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;&gt;() != null" vb="Contract.Result(Of QuickGraph.TryFunc(Of TVertex, System.Collections.Generic.IEnumerable(Of TEdge)))() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.TreeCyclePoppingRandom``2(QuickGraph.IVertexListGraph{``0,``1},``0)">
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
      <requires csharp="(object)root != null" vb="((Object)root) &lt;&gt; Nothing">(object)root != null</requires>
      <requires csharp="visitedGraph.ContainsVertex(root)" vb="visitedGraph.ContainsVertex(root)">visitedGraph.ContainsVertex(root)</requires>
      <ensures csharp="Contract.Result&lt;QuickGraph.TryFunc&lt;TVertex, System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;&gt;() != null" vb="Contract.Result(Of QuickGraph.TryFunc(Of TVertex, System.Collections.Generic.IEnumerable(Of TEdge)))() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.TreeCyclePoppingRandom``2(QuickGraph.IVertexListGraph{``0,``1},``0,QuickGraph.Algorithms.RandomWalks.IMarkovEdgeChain{``0,``1})">
      <requires csharp="(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass6_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass6_0&lt;TVertex, TEdge&gt;();
    }
    return visitedGraph != null; })()" vb="(() =&gt; {
    QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass6_0&lt;TVertex, TEdge&gt; local_0 = New QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass6_0(Of TVertex, TEdge)();
    return visitedGraph &lt;&gt; Nothing; })()">(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass6_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass6_0&lt;TVertex, TEdge&gt;();
    }
    return visitedGraph != null; })()</requires>
      <requires csharp="(object)root != null" vb="((Object)root) &lt;&gt; Nothing">(object)root != null</requires>
      <requires csharp="visitedGraph.ContainsVertex(root)" vb="visitedGraph.ContainsVertex(root)">visitedGraph.ContainsVertex(root)</requires>
      <ensures csharp="Contract.Result&lt;QuickGraph.TryFunc&lt;TVertex, System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;&gt;() != null" vb="Contract.Result(Of QuickGraph.TryFunc(Of TVertex, System.Collections.Generic.IEnumerable(Of TEdge)))() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.ShortestPathsDijkstra``2(QuickGraph.IUndirectedGraph{``0,``1},System.Func{``1,System.Double},``0)">
      <requires csharp="(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass7_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass7_0&lt;TVertex, TEdge&gt;();
    }
    return visitedGraph != null; })()" vb="(() =&gt; {
    QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass7_0&lt;TVertex, TEdge&gt; local_0 = New QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass7_0(Of TVertex, TEdge)();
    return visitedGraph &lt;&gt; Nothing; })()">(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass7_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass7_0&lt;TVertex, TEdge&gt;();
    }
    return visitedGraph != null; })()</requires>
      <requires csharp="edgeWeights != null" vb="edgeWeights &lt;&gt; Nothing">edgeWeights != null</requires>
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.ShortestPathsAStar``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1},System.Func{``1,System.Double},System.Func{``0,System.Double},``0)">
      <requires csharp="(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass8_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass8_0&lt;TVertex, TEdge&gt;();
    }
    return visitedGraph != null; })()" vb="(() =&gt; {
    QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass8_0&lt;TVertex, TEdge&gt; local_0 = New QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass8_0(Of TVertex, TEdge)();
    return visitedGraph &lt;&gt; Nothing; })()">(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass8_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass8_0&lt;TVertex, TEdge&gt;();
    }
    return visitedGraph != null; })()</requires>
      <requires csharp="edgeWeights != null" vb="edgeWeights &lt;&gt; Nothing">edgeWeights != null</requires>
      <requires csharp="costHeuristic != null" vb="costHeuristic &lt;&gt; Nothing">costHeuristic != null</requires>
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.ShortestPathsDijkstra``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1},System.Func{``1,System.Double},``0)">
      <requires csharp="(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass9_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass9_0&lt;TVertex, TEdge&gt;();
    }
    return visitedGraph != null; })()" vb="(() =&gt; {
    QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass9_0&lt;TVertex, TEdge&gt; local_0 = New QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass9_0(Of TVertex, TEdge)();
    return visitedGraph &lt;&gt; Nothing; })()">(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass9_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass9_0&lt;TVertex, TEdge&gt;();
    }
    return visitedGraph != null; })()</requires>
      <requires csharp="edgeWeights != null" vb="edgeWeights &lt;&gt; Nothing">edgeWeights != null</requires>
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.ShortestPathsBellmanFord``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1},System.Func{``1,System.Double},``0)">
      <requires csharp="(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass10_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass10_0&lt;TVertex, TEdge&gt;();
    }
    return visitedGraph != null; })()" vb="(() =&gt; {
    QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass10_0&lt;TVertex, TEdge&gt; local_0 = New QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass10_0(Of TVertex, TEdge)();
    return visitedGraph &lt;&gt; Nothing; })()">(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass10_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass10_0&lt;TVertex, TEdge&gt;();
    }
    return visitedGraph != null; })()</requires>
      <requires csharp="edgeWeights != null" vb="edgeWeights &lt;&gt; Nothing">edgeWeights != null</requires>
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.ShortestPathsDag``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1},System.Func{``1,System.Double},``0)">
      <requires csharp="(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass11_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass11_0&lt;TVertex, TEdge&gt;();
    }
    return visitedGraph != null; })()" vb="(() =&gt; {
    QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass11_0&lt;TVertex, TEdge&gt; local_0 = New QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass11_0(Of TVertex, TEdge)();
    return visitedGraph &lt;&gt; Nothing; })()">(() =&gt; {
    {
        QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass11_0&lt;TVertex, TEdge&gt; local_0 = new QuickGraph.Algorithms.AlgorithmExtensions.&lt;&gt;c__DisplayClass11_0&lt;TVertex, TEdge&gt;();
    }
    return visitedGraph != null; })()</requires>
      <requires csharp="edgeWeights != null" vb="edgeWeights &lt;&gt; Nothing">edgeWeights != null</requires>
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.SourceFirstTopologicalSort``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1})">
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.SourceFirstTopologicalSort``2(QuickGraph.IVertexAndEdgeListGraph{``0,``1},System.Collections.Generic.IList{``0})">
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
      <requires csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.CondensateEdges``2(QuickGraph.IBidirectionalGraph{``0,``1},QuickGraph.VertexPredicate{``0})">
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
      <requires csharp="vertexPredicate != null" vb="vertexPredicate &lt;&gt; Nothing">vertexPredicate != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.AlgorithmExtensions.ComputeDisjointSet``2(QuickGraph.IUndirectedGraph{``0,``1})">
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.MaximumBipartiteMatchingAlgorithm`2.#ctor(QuickGraph.IMutableVertexAndEdgeListGraph{`0,`1},System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0},QuickGraph.VertexFactory{`0},QuickGraph.EdgeFactory{`0,`1})">
      <requires csharp="vertexFactory != null" vb="vertexFactory &lt;&gt; Nothing">vertexFactory != null</requires>
      <requires csharp="edgeFactory != null" vb="edgeFactory &lt;&gt; Nothing">edgeFactory != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.OnInitializeVertex(`0)">
      <requires csharp="(object)v != null" vb="((Object)v) &lt;&gt; Nothing">(object)v != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.OnStartVertex(`0)">
      <requires csharp="(object)v != null" vb="((Object)v) &lt;&gt; Nothing">(object)v != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.OnVertexMaxDepthReached(`0)">
      <requires csharp="(object)v != null" vb="((Object)v) &lt;&gt; Nothing">(object)v != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.Visit(`0)">
      <requires csharp="(object)root != null" vb="((Object)root) &lt;&gt; Nothing">(object)root != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.SearchFrame.#ctor(`0,System.Collections.Generic.IEnumerator{`1},System.Int32)">
      <requires csharp="(object)vertex != null" vb="((Object)vertex) &lt;&gt; Nothing">(object)vertex != null</requires>
      <requires csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
      <requires csharp="depth &gt;= 0" vb="depth &gt;= 0">depth &gt;= 0</requires>
    </member>
    <member name="P:QuickGraph.Algorithms.Search.UndirectedDepthFirstSearchAlgorithm`2.MaxDepth">
      <setter>
        <requires csharp="value &gt; 0" vb="value &gt; 0">value &gt; 0</requires>
      </setter>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm`2.Visit(`0)">
      <requires csharp="(object)root != null" vb="((Object)root) &lt;&gt; Nothing">(object)root != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm`2.SearchFrame.#ctor(`0,System.Collections.Generic.IEnumerator{`1},System.Int32)">
      <requires csharp="(object)vertex != null" vb="((Object)vertex) &lt;&gt; Nothing">(object)vertex != null</requires>
      <requires csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
      <requires csharp="depth &gt;= 0" vb="depth &gt;= 0">depth &gt;= 0</requires>
    </member>
    <member name="P:QuickGraph.Algorithms.Search.DepthFirstSearchAlgorithm`2.MaxDepth">
      <setter>
        <requires csharp="value &gt; 0" vb="value &gt; 0">value &gt; 0</requires>
      </setter>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.BidirectionalDepthFirstSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IBidirectionalGraph{`0,`1},System.Collections.Generic.IDictionary{`0,QuickGraph.GraphColor})">
      <requires csharp="colors != null" vb="colors &lt;&gt; Nothing">colors != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.BidirectionalDepthFirstSearchAlgorithm`2.Visit(`0,System.Int32)">
      <requires csharp="(object)u != null" vb="((Object)u) &lt;&gt; Nothing">(object)u != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.BestFirstFrontierSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IBidirectionalIncidenceGraph{`0,`1},System.Func{`1,System.Double},QuickGraph.Algorithms.IDistanceRelaxer)">
      <requires csharp="edgeWeights != null" vb="edgeWeights &lt;&gt; Nothing">edgeWeights != null</requires>
      <requires csharp="distanceRelaxer != null" vb="distanceRelaxer &lt;&gt; Nothing">distanceRelaxer != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.UndirectedBreadthFirstSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IUndirectedGraph{`0,`1},QuickGraph.Collections.IQueue{`0},System.Collections.Generic.IDictionary{`0,QuickGraph.GraphColor})">
      <requires csharp="vertexQueue != null" vb="vertexQueue &lt;&gt; Nothing">vertexQueue != null</requires>
      <requires csharp="vertexColors != null" vb="vertexColors &lt;&gt; Nothing">vertexColors != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.EdgeDepthFirstSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IEdgeListAndIncidenceGraph{`0,`1},System.Collections.Generic.IDictionary{`1,QuickGraph.GraphColor})">
      <requires csharp="colors != null" vb="colors &lt;&gt; Nothing">colors != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.Search.BreadthFirstSearchAlgorithm`2.#ctor(QuickGraph.Algorithms.Services.IAlgorithmComponent,QuickGraph.IVertexListGraph{`0,`1},QuickGraph.Collections.IQueue{`0},System.Collections.Generic.IDictionary{`0,QuickGraph.GraphColor},System.Func{System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`1}})">
      <requires csharp="vertexQueue != null" vb="vertexQueue &lt;&gt; Nothing">vertexQueue != null</requires>
      <requires csharp="vertexColors != null" vb="vertexColors &lt;&gt; Nothing">vertexColors != null</requires>
      <requires csharp="outEdgeEnumerator != null" vb="outEdgeEnumerator &lt;&gt; Nothing">outEdgeEnumerator != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RootedSearchAlgorithmBase`2.SetGoalVertex(`0)">
      <requires csharp="(object)goalVertex != null" vb="((Object)goalVertex) &lt;&gt; Nothing">(object)goalVertex != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RootedSearchAlgorithmBase`2.OnGoalVertexChanged(System.EventArgs)">
      <requires csharp="e != null" vb="e &lt;&gt; Nothing">e != null</requires>
    </member>
    <member name="M:QuickGraph.Algorithms.RootedSearchAlgorithmBase`2.Compute(`0,`0)">
      <requires csharp="(object)root != null" vb="((Object)root) &lt;&gt; Nothing">(object)root != null</requires>
      <requires csharp="(object)goal != null" vb="((Object)goal) &lt;&gt; Nothing">(object)goal != null</requires>
    </member>
    <member name="M:QuickGraph.DelegateUndirectedGraph`2.#ctor(System.Collections.Generic.IEnumerable{`0},QuickGraph.TryFunc{`0,System.Collections.Generic.IEnumerable{`1}},System.Boolean)">
      <requires csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
      <requires csharp="System.Linq.Enumerable.All&lt;TVertex&gt;(vertices, delegate (TVertex v) {
    decimal&lt;TEdge&gt; local_0;
    return tryGetAdjacentEdges(v, ref local_0);

})" vb="System.Linq.Enumerable.All(vertices, delegate (v As TVertex) {
    decimal&lt;TEdge&gt; local_0;
    Return tryGetAdjacentEdges(v, &amp;local_0)
})">System.Linq.Enumerable.All&lt;TVertex&gt;(vertices, delegate (TVertex v) {
    decimal&lt;TEdge&gt; local_0;
    return tryGetAdjacentEdges(v, ref local_0);

})</requires>
    </member>
    <member name="M:QuickGraph.DelegateUndirectedGraph`2.ContainsEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;bool&gt;() == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))" vb="Contract.Result(Of Boolean )() = System.Diagnostics.Contracts.Contract.Exists(Me.Edges, (e As TEdge) =&gt; e.Equals(((Object)edge)))">result == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))</ensures>
    </member>
    <member name="P:QuickGraph.DelegateUndirectedGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.VertexCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.VertexCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.VertexCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.DelegateUndirectedGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Vertices); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Vertices); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Vertices); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.DelegateUndirectedGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TVertex&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TVertex))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.DelegateUndirectedGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.EdgeCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.EdgeCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.EdgeCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.DelegateUndirectedGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Edges); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Edges); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Edges); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.DelegateUndirectedGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        push Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;();
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))();
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__5_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__5_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push result;
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()</ensures>
      </getter>
    </member>
    <member name="T:QuickGraph.UndirectedGraph`2">
      <invariant>this.edgeCount &gt;= 0</invariant>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.#ctor(System.Boolean,QuickGraph.EdgeEqualityComparer{`0,`1},System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <requires csharp="edgeEqualityComparer != null" vb="edgeEqualityComparer &lt;&gt; Nothing">edgeEqualityComparer != null</requires>
      <requires csharp="vertexComparer != null" vb="vertexComparer &lt;&gt; Nothing">vertexComparer != null</requires>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.OnVertexAdded(`0)">
      <requires csharp="(object)args != null" vb="((Object)args) &lt;&gt; Nothing">(object)args != null</requires>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.AddVertexRange(System.Collections.Generic.IEnumerable{`0})">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="(() =&gt; {
    {
        push vertices;
        push decimal.&lt;&gt;9__4_0;
        if (dup == default(decimal))
        {
            pop;
            push (decimal v) =&gt; (object)v != null;
            &lt;&gt;9__4_0 = dup;
        }
    }
    return decimal.All&lt;decimal&gt;(pop, pop); })()" vb="(() =&gt; {
    push vertices;
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__4_0;
    If dup = Nothing Then
    pop
    push (v As TVertex) =&gt; ((Object)v) &lt;&gt; Nothing;
    &lt;&gt;9__4_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push vertices;
        push decimal.&lt;&gt;9__4_0;
        if (dup == default(decimal))
        {
            pop;
            push (decimal v) =&gt; (object)v != null;
            &lt;&gt;9__4_0 = dup;
        }
    }
    return decimal.All&lt;decimal&gt;(pop, pop); })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="decimal.All&lt;decimal&gt;(vertices, (decimal v) =&gt; this.ContainsVertex(v))" vb="System.Linq.Enumerable.All(vertices, (v As TVertex) =&gt; Me.ContainsVertex(v))">decimal.All&lt;decimal&gt;(vertices, (decimal v) =&gt; this.ContainsVertex(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="this.VertexCount == Contract.Old(this.VertexCount) + Contract.Result&lt;int&gt;()" vb="Me.VertexCount = Contract.Old(Me.VertexCount) + Contract.Result(Of Integer )()">this.VertexCount == old(this.VertexCount) + result</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.AddVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="Contract.Result&lt;bool&gt;() == Contract.Old(!this.ContainsVertex(v))" vb="Contract.Result(Of Boolean )() = Contract.Old(Not Me.ContainsVertex(v))">result == old(!this.ContainsVertex(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="this.VertexCount == Contract.Old(this.VertexCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.VertexCount = Contract.Old(Me.VertexCount) + (Contract.Result(Of Boolean )() ? 1 : 0)">this.VertexCount == old(this.VertexCount) + (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.OnVertexRemoved(`0)">
      <requires csharp="(object)args != null" vb="((Object)args) &lt;&gt; Nothing">(object)args != null</requires>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.RemoveVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="Contract.Result&lt;bool&gt;() == Contract.Old(this.ContainsVertex(v))" vb="Contract.Result(Of Boolean )() = Contract.Old(Me.ContainsVertex(v))">result == old(this.ContainsVertex(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="!this.ContainsVertex(v)" vb="Not Me.ContainsVertex(v)">!this.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="this.VertexCount == Contract.Old(this.VertexCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.VertexCount = Contract.Old(Me.VertexCount) - (Contract.Result(Of Boolean )() ? 1 : 0)">this.VertexCount == old(this.VertexCount) - (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.RemoveVertexIf(QuickGraph.VertexPredicate{`0})">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return pred != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return pred &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return pred != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(this.Vertices, (decimal v) =&gt; pred(v)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(Me.Vertices, (v As TVertex) =&gt; pred(v)))">result == old(decimal.Count&lt;decimal&gt;(this.Vertices, (decimal v) =&gt; pred(v)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="decimal.All&lt;decimal&gt;(this.Vertices, (decimal v) =&gt; !pred(v))" vb="System.Linq.Enumerable.All(Me.Vertices, (v As TVertex) =&gt; Not pred(v))">decimal.All&lt;decimal&gt;(this.Vertices, (decimal v) =&gt; !pred(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="this.VertexCount == Contract.Old(this.VertexCount) - Contract.Result&lt;int&gt;()" vb="Me.VertexCount = Contract.Old(Me.VertexCount) - Contract.Result(Of Integer )()">this.VertexCount == old(this.VertexCount) - result</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.RemoveAdjacentEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableUndirectedGraph`2.RemoveAdjacentEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)vertex != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableUndirectedGraph`2.RemoveAdjacentEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableUndirectedGraph" csharp="predicate != null" vb="predicate &lt;&gt; Nothing">predicate != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableUndirectedGraph`2.RemoveAdjacentEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableUndirectedGraph" csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(this.AdjacentEdges(vertex), (decimal e) =&gt; predicate(e)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(Me.AdjacentEdges(vertex), (e As TEdge) =&gt; predicate(e)))">result == old(decimal.Count&lt;decimal&gt;(this.AdjacentEdges(vertex), (decimal e) =&gt; predicate(e)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableUndirectedGraph`2.RemoveAdjacentEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableUndirectedGraph" csharp="decimal.All&lt;decimal&gt;(this.AdjacentEdges(vertex), (decimal v) =&gt; !predicate(v))" vb="System.Linq.Enumerable.All(Me.AdjacentEdges(vertex), (v As TEdge) =&gt; Not predicate(v))">decimal.All&lt;decimal&gt;(this.AdjacentEdges(vertex), (decimal v) =&gt; !predicate(v))</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.ClearAdjacentEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableUndirectedGraph`2.ClearAdjacentEdges(`0)" inheritedFromTypeName="IMutableUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableUndirectedGraph`2.ClearAdjacentEdges(`0)" inheritedFromTypeName="IMutableUndirectedGraph" csharp="this.AdjacentDegree(vertex) == 0" vb="Me.AdjacentDegree(vertex) = 0">this.AdjacentDegree(vertex) == 0</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.TryGetEdge(`0,`0,`1@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.ContainsEdge(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;bool&gt;() == decimal.Any&lt;decimal&gt;(this.AdjacentEdges(source), delegate (decimal e) {
    if (!e.Target.Equals((decimal)target))
    {
        return e.Source.Equals((decimal)target);

    }
    return true;

})" vb="Contract.Result(Of Boolean )() = System.Linq.Enumerable.Any(Me.AdjacentEdges(source), delegate (e As TEdge) {
    If Not e.Target.Equals(((Object)target)) Then
    Return e.Source.Equals(((Object)target))
    Return True
})">result == decimal.Any&lt;decimal&gt;(this.AdjacentEdges(source), delegate (decimal e) {
    if (!e.Target.Equals((decimal)target))
    {
        return e.Source.Equals((decimal)target);

    }
    return true;

})</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.AdjacentEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)Contract.Result&lt;decimal&gt;() != null" vb="((Object)Contract.Result(Of TEdge)()) &lt;&gt; Nothing">(object)result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;decimal&gt;().Source.Equals((object)v) || Contract.Result&lt;decimal&gt;().Target.Equals((object)v)" vb="Contract.Result(Of TEdge)().Source.Equals(((Object)v)) OrElse Contract.Result(Of TEdge)().Target.Equals(((Object)v))">result.Source.Equals((object)v) || result.Target.Equals((object)v)</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.ContainsVertex(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()</requires>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.AddVerticesAndEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="this.ContainsEdge(edge)" vb="Me.ContainsEdge(edge)">this.ContainsEdge(edge)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="this.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.Old(!this.ContainsEdge(edge))" vb="Me.AllowParallelEdges OrElse Contract.Result(Of Boolean )() = Contract.Old(Not Me.ContainsEdge(edge))">this.AllowParallelEdges || result == old(!this.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + (Contract.Result(Of Boolean )() ? 1 : 0)">this.EdgeCount == old(this.EdgeCount) + (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return edges != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return edges &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return edges != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__1_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__1_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()" vb="(() =&gt; {
    If Not System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType Then
    push edges;
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__1_0;
    If dup = Nothing Then
    pop
    push (edge As TEdge) =&gt; ((Object)edge) &lt;&gt; Nothing;
    &lt;&gt;9__1_0 = dup
    push System.Linq.Enumerable.All(pop, pop);
    else    push 1;
    return pop &lt;&gt; 0; })()">(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__1_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__1_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + Contract.Result&lt;int&gt;()" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + Contract.Result(Of Integer )()">this.EdgeCount == old(this.EdgeCount) + result</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.AddEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.ContainsVertex(edge.Source)" vb="Me.ContainsVertex(edge.Source)">this.ContainsVertex(edge.Source)</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.ContainsVertex(edge.Target)" vb="Me.ContainsVertex(edge.Target)">this.ContainsVertex(edge.Target)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.ContainsEdge(edge)" vb="Me.ContainsEdge(edge)">this.ContainsEdge(edge)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.Old(!this.ContainsEdge(edge))" vb="Me.AllowParallelEdges OrElse Contract.Result(Of Boolean )() = Contract.Old(Not Me.ContainsEdge(edge))">this.AllowParallelEdges || result == old(!this.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + (Contract.Result(Of Boolean )() ? 1 : 0)">this.EdgeCount == old(this.EdgeCount) + (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__4_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__4_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()" vb="(() =&gt; {
    If Not System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType Then
    push edges;
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__4_0;
    If dup = Nothing Then
    pop
    push (edge As TEdge) =&gt; ((Object)edge) &lt;&gt; Nothing;
    &lt;&gt;9__4_0 = dup
    push System.Linq.Enumerable.All(pop, pop);
    else    push 1;
    return pop &lt;&gt; 0; })()">(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__4_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__4_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if (this.ContainsVertex(edge.Source))
    {
        return this.ContainsVertex(edge.Target);

    }
    return false;

})" vb="System.Linq.Enumerable.All(edges, delegate (edge As TEdge) {
    If Me.ContainsVertex(edge.Source) Then
    Return Me.ContainsVertex(edge.Target)
    Return False
})">decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if (this.ContainsVertex(edge.Source))
    {
        return this.ContainsVertex(edge.Target);

    }
    return false;

})</requires>
      <ensures description="all edge from edges belong to the graph" inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="decimal.All&lt;decimal&gt;(edges, (decimal edge) =&gt; this.ContainsEdge(edge))" vb="System.Linq.Enumerable.All(edges, (edge As TEdge) =&gt; Me.ContainsEdge(edge))">decimal.All&lt;decimal&gt;(edges, (decimal edge) =&gt; this.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(edges, (decimal edge) =&gt; !this.ContainsEdge(edge)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(edges, (edge As TEdge) =&gt; Not Me.ContainsEdge(edge)))">result == old(decimal.Count&lt;decimal&gt;(edges, (decimal edge) =&gt; !this.ContainsEdge(edge)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + Contract.Result&lt;int&gt;()" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + Contract.Result(Of Integer )()">this.EdgeCount == old(this.EdgeCount) + result</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.RemoveEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="Contract.Result&lt;bool&gt;() == Contract.Old(this.ContainsEdge(edge))" vb="Contract.Result(Of Boolean )() = Contract.Old(Me.ContainsEdge(edge))">result == old(this.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="!this.ContainsEdge(edge)" vb="Not Me.ContainsEdge(edge)">!this.ContainsEdge(edge)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) - (Contract.Result(Of Boolean )() ? 1 : 0)">this.EdgeCount == old(this.EdgeCount) - (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return predicate != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return predicate &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return predicate != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(this.Edges, (decimal e) =&gt; predicate(e)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(Me.Edges, (e As TEdge) =&gt; predicate(e)))">result == old(decimal.Count&lt;decimal&gt;(this.Edges, (decimal e) =&gt; predicate(e)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="decimal.All&lt;decimal&gt;(this.Edges, (decimal e) =&gt; !predicate(e))" vb="System.Linq.Enumerable.All(Me.Edges, (e As TEdge) =&gt; Not predicate(e))">decimal.All&lt;decimal&gt;(this.Edges, (decimal e) =&gt; !predicate(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) - Contract.Result&lt;int&gt;()" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) - Contract.Result(Of Integer )()">this.EdgeCount == old(this.EdgeCount) - result</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.ContainsEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;bool&gt;() == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))" vb="Contract.Result(Of Boolean )() = System.Diagnostics.Contracts.Contract.Exists(Me.Edges, (e As TEdge) =&gt; e.Equals(((Object)edge)))">result == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.ContainsEdgeBetweenVertices(System.Collections.Generic.IEnumerable{`1},`1)">
      <requires csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
      <requires csharp="(object)edge != null" vb="((Object)edge) &lt;&gt; Nothing">(object)edge != null</requires>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.AdjacentEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)v != null" vb="((Object)v) &lt;&gt; Nothing">(object)v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="decimal.All&lt;TEdge&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;(), delegate (TEdge edge) {
    if ((decimal)edge != default(decimal))
    {
        if (this.ContainsEdge(edge.Source, edge.Target))
        {
            if (!edge.Source.Equals((decimal)v))
            {
                return edge.Target.Equals((decimal)v);

            }
            return true;

        }
    }
    return false;

})" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))(), delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    If Me.ContainsEdge(edge.Source, edge.Target) Then
    If Not edge.Source.Equals(((Object)v)) Then
    Return edge.Target.Equals(((Object)v))
    Return True
    Return False
})">decimal.All&lt;TEdge&gt;(result, delegate (TEdge edge) {
    if ((decimal)edge != default(decimal))
    {
        if (this.ContainsEdge(edge.Source, edge.Target))
        {
            if (!edge.Source.Equals((decimal)v))
            {
                return edge.Target.Equals((decimal)v);

            }
            return true;

        }
    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.AdjacentDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.AdjacentEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.AdjacentEdges(v))">result == decimal.Count&lt;decimal&gt;(this.AdjacentEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.UndirectedGraph`2.IsAdjacentEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;bool&gt;() == this.AdjacentDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.AdjacentDegree(v) = 0">result == this.AdjacentDegree(v) == 0</ensures>
    </member>
    <member name="P:QuickGraph.UndirectedGraph`2.EdgeEqualityComparer">
      <getter>
        <ensures csharp="Contract.Result&lt;QuickGraph.EdgeEqualityComparer&lt;TVertex, TEdge&gt;&gt;() != null" vb="Contract.Result(Of QuickGraph.EdgeEqualityComparer(Of TVertex, TEdge))() &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.get_EdgeEqualityComparer" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;QuickGraph.EdgeEqualityComparer&lt;TVertex, TEdge&gt;&gt;() != null" vb="Contract.Result(Of QuickGraph.EdgeEqualityComparer(Of TVertex, TEdge))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.UndirectedGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.VertexCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.VertexCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.VertexCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.UndirectedGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Vertices); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Vertices); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Vertices); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.UndirectedGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TVertex&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TVertex))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.UndirectedGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.EdgeCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.EdgeCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.EdgeCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.UndirectedGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Edges); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Edges); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Edges); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.UndirectedGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        push Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;();
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))();
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__5_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__5_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push result;
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.#ctor(QuickGraph.IBidirectionalGraph{`0,`1})">
      <requires csharp="originalGraph != null" vb="originalGraph &lt;&gt; Nothing">originalGraph != null</requires>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.ContainsVertex(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()</requires>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.ContainsEdge(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.TryGetEdge(`0,`0,QuickGraph.SReversedEdge{`0,`1}@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{QuickGraph.SReversedEdge{`0,`1}}@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.IsOutEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;bool&gt;() == this.OutDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.OutDegree(v) = 0">result == this.OutDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.OutDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.OutEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.OutEdges(v))">result == decimal.Count&lt;decimal&gt;(this.OutEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.InEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="decimal.All&lt;decimal&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;(), delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))(), delegate (edge As QuickGraph.SReversedEdge(Of Decimal, Decimal)) {
    If ((Object)edge) &lt;&gt; Nothing Then
    Return edge.Target.Equals(((Object)v))
    Return False
})">decimal.All&lt;decimal&gt;(result, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.InEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="index &gt;= 0 &amp;&amp; index &lt; this.InDegree(v)" vb="index &gt;= 0 AndAlso index &lt; Me.InDegree(v)">index &gt;= 0 &amp;&amp; index &lt; this.InDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;decimal&gt;().Equals((object)decimal.ElementAt&lt;decimal&gt;(this.InEdges(v), index))" vb="Contract.Result(Of QuickGraph.SReversedEdge(Of Decimal, Decimal))().Equals(((Object)System.Linq.Enumerable.ElementAt(Me.InEdges(v), index)))">result.Equals((object)decimal.ElementAt&lt;decimal&gt;(this.InEdges(v), index))</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.IsInEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;bool&gt;() == this.InDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.InDegree(v) = 0">result == this.InDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.InDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.InEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.InEdges(v))">result == decimal.Count&lt;decimal&gt;(this.InEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.OutEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.All&lt;decimal&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;(), (decimal e) =&gt; e.Source.Equals((decimal)v))" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))(), (e As QuickGraph.SReversedEdge(Of Decimal, Decimal)) =&gt; e.Source.Equals(((Object)v)))">decimal.All&lt;decimal&gt;(result, (decimal e) =&gt; e.Source.Equals((decimal)v))</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{QuickGraph.SReversedEdge{`0,`1}}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;bool&gt;() == this.ContainsVertex(v)" vb="Contract.Result(Of Boolean )() = Me.ContainsVertex(v)">result == this.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="!Contract.Result&lt;bool&gt;() || edges != null" vb="Not Contract.Result(Of Boolean )() OrElse edges &lt;&gt; Nothing">!result || edges != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="!Contract.Result&lt;bool&gt;() || decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})" vb="Not Contract.Result(Of Boolean )() OrElse System.Linq.Enumerable.All(edges, delegate (edge As QuickGraph.SReversedEdge(Of Decimal, Decimal)) {
    If ((Object)edge) &lt;&gt; Nothing Then
    Return edge.Target.Equals(((Object)v))
    Return False
})">!result || decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{QuickGraph.SReversedEdge{`0,`1}}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(!Contract.Result&lt;bool&gt;() || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0" vb="(Contract.Result(Of Boolean )() AndAlso Not (edges &lt;&gt; Nothing AndAlso System.Linq.Enumerable.All(edges, (e As QuickGraph.SReversedEdge(Of Decimal, Decimal)) =&gt; e.Source.Equals(((Object)v))))) &lt;&gt; 0">(!result || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.OutEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)" vb="index &gt;= 0 AndAlso index &lt; Me.OutDegree(v)">index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)Contract.Result&lt;decimal&gt;())" vb="System.Linq.Enumerable.ElementAt(Me.OutEdges(v), index).Equals(((Object)Contract.Result(Of QuickGraph.SReversedEdge(Of Decimal, Decimal))()))">decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)result)</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.ContainsEdge(QuickGraph.SReversedEdge{`0,`1})">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;bool&gt;() == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))" vb="Contract.Result(Of Boolean )() = System.Diagnostics.Contracts.Contract.Exists(Me.Edges, (e As QuickGraph.SReversedEdge(Of Decimal, Decimal)) =&gt; e.Equals(((Object)edge)))">result == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))</ensures>
    </member>
    <member name="M:QuickGraph.ReversedBidirectionalGraph`2.Degree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;int&gt;() == this.InDegree(v) + this.OutDegree(v)" vb="Contract.Result(Of Integer )() = Me.InDegree(v) + Me.OutDegree(v)">result == this.InDegree(v) + this.OutDegree(v)</ensures>
    </member>
    <member name="P:QuickGraph.ReversedBidirectionalGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.VertexCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.VertexCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.VertexCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ReversedBidirectionalGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Vertices); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Vertices); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Vertices); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ReversedBidirectionalGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TVertex&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TVertex))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ReversedBidirectionalGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;QuickGraph.SReversedEdge&lt;TVertex, TEdge&gt;&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of QuickGraph.SReversedEdge(Of TVertex, TEdge)))() &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        push Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;QuickGraph.SReversedEdge&lt;TVertex, TEdge&gt;&gt;&gt;();
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (QuickGraph.SReversedEdge&lt;TVertex, TEdge&gt; e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;QuickGraph.SReversedEdge&lt;TVertex, TEdge&gt;&gt;(pop, pop); })()" vb="(() =&gt; {
    push Contract.Result(Of System.Collections.Generic.IEnumerable(Of QuickGraph.SReversedEdge(Of TVertex, TEdge)))();
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__5_0;
    If dup = Nothing Then
    pop
    push (e As QuickGraph.SReversedEdge(Of TVertex, TEdge)) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__5_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push result;
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (QuickGraph.SReversedEdge&lt;TVertex, TEdge&gt; e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;QuickGraph.SReversedEdge&lt;TVertex, TEdge&gt;&gt;(pop, pop); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ReversedBidirectionalGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.EdgeCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.EdgeCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.EdgeCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ReversedBidirectionalGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Edges); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Edges); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Edges); })()</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciQueue`2.#ctor(System.Int32,System.Collections.Generic.IEnumerable{`0},System.Func{`0,`1},System.Func{`1,`1,System.Int32})">
      <requires csharp="valueCount &gt;= 0" vb="valueCount &gt;= 0">valueCount &gt;= 0</requires>
      <requires csharp="(!(valueCount != default(int)) || values != default(System.Collections.Generic.IEnumerable&lt;TVertex&gt;) &amp;&amp; valueCount == System.Linq.Enumerable.Count&lt;TVertex&gt;(values)) != 0" vb="(valueCount &lt;&gt; Nothing AndAlso Not (values &lt;&gt; Nothing AndAlso valueCount = System.Linq.Enumerable.Count(values))) &lt;&gt; 0">(!(valueCount != default(int)) || values != default(System.Collections.Generic.IEnumerable&lt;TVertex&gt;) &amp;&amp; valueCount == System.Linq.Enumerable.Count&lt;TVertex&gt;(values)) != 0</requires>
      <requires csharp="distances != null" vb="distances &lt;&gt; Nothing">distances != null</requires>
      <requires csharp="distanceComparison != null" vb="distanceComparison &lt;&gt; Nothing">distanceComparison != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciQueue`2.#ctor(System.Collections.Generic.Dictionary{`0,`1},System.Func{`1,`1,System.Int32})">
      <requires csharp="values != null" vb="values &lt;&gt; Nothing">values != null</requires>
      <requires csharp="distanceComparison != null" vb="distanceComparison &lt;&gt; Nothing">distanceComparison != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciQueue`2.Contains(`0)">
      <pure />
    </member>
    <member name="M:QuickGraph.Collections.FibonacciQueue`2.ToArray">
      <pure />
    </member>
    <member name="P:QuickGraph.Collections.FibonacciQueue`2.Count">
      <getter>
        <pure />
      </getter>
    </member>
    <member name="M:QuickGraph.Collections.VertexEdgeDictionary`2.QuickGraph#Collections#IVertexEdgeDictionary{TVertex@TEdge}#Clone">
      <ensures inheritedFrom="M:QuickGraph.Collections.IVertexEdgeDictionary`2.Clone" inheritedFromTypeName="IVertexEdgeDictionary" csharp="Contract.Result&lt;QuickGraph.Collections.IVertexEdgeDictionary&lt;TVertex, TEdge&gt;&gt;() != null" vb="Contract.Result(Of QuickGraph.Collections.IVertexEdgeDictionary(Of TVertex, TEdge))() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:QuickGraph.Collections.BinaryHeap`2.#ctor(System.Int32,System.Func{`0,`0,System.Int32})">
      <requires csharp="capacity &gt;= 0" vb="capacity &gt;= 0">capacity &gt;= 0</requires>
      <requires csharp="priorityComparison != null" vb="priorityComparison &lt;&gt; Nothing">priorityComparison != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.BinaryHeap`2.Less(System.Int32,System.Int32)">
      <pure />
      <requires csharp="i &gt;= 0 &amp; i &lt; this.count &amp; j &gt;= 0 &amp; j &lt; this.count &amp; i != j" vb="i &gt;= 0 And i &lt; Me.count And j &gt;= 0 And j &lt; Me.count And i &lt;&gt; j">i &gt;= 0 &amp; i &lt; this.count &amp; j &gt;= 0 &amp; j &lt; this.count &amp; i != j</requires>
    </member>
    <member name="M:QuickGraph.Collections.BinaryHeap`2.Swap(System.Int32,System.Int32)">
      <requires csharp="(i &gt;= 0 ? i &lt; this.count : !true ? j &gt;= 0 ? j &lt; this.count : !true : !true) &amp;&amp; !(i == j)" vb="(i &gt;= 0 ? i &lt; Me.count : Not True ? j &gt;= 0 ? j &lt; Me.count : Not True : Not True) AndAlso Not i = j">(i &gt;= 0 ? i &lt; this.count : !true ? j &gt;= 0 ? j &lt; this.count : !true : !true) &amp;&amp; !(i == j)</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeapLinkedList`2.MergeLists(QuickGraph.Collections.FibonacciHeapLinkedList{`0,`1})">
      <requires csharp="list != null" vb="list &lt;&gt; Nothing">list != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeapLinkedList`2.AddLast(QuickGraph.Collections.FibonacciHeapCell{`0,`1})">
      <requires csharp="node != null" vb="node &lt;&gt; Nothing">node != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeapLinkedList`2.Remove(QuickGraph.Collections.FibonacciHeapCell{`0,`1})">
      <requires csharp="node != null" vb="node &lt;&gt; Nothing">node != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeap`2.Delete(QuickGraph.Collections.FibonacciHeapCell{`0,`1})">
      <requires csharp="node != null" vb="node &lt;&gt; Nothing">node != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeap`2.ChangeKey(QuickGraph.Collections.FibonacciHeapCell{`0,`1},`0)">
      <requires csharp="node != null" vb="node &lt;&gt; Nothing">node != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeap`2.ChangeKeyInternal(QuickGraph.Collections.FibonacciHeapCell{`0,`1},`0,System.Boolean)">
      <requires csharp="node != null" vb="node &lt;&gt; Nothing">node != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeap`2.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
      <requires csharp="values != null" vb="values &lt;&gt; Nothing">values != null</requires>
      <requires csharp="converter != null" vb="converter &lt;&gt; Nothing">converter != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.FibonacciHeap`2.Merge(QuickGraph.Collections.FibonacciHeap{`0,`1})">
      <requires csharp="other != null" vb="other &lt;&gt; Nothing">other != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.EdgeList`2.QuickGraph#Collections#IEdgeList{TVertex@TEdge}#Clone">
      <ensures inheritedFrom="M:QuickGraph.Collections.IEdgeList`2.Clone" inheritedFromTypeName="IEdgeList" csharp="Contract.Result&lt;QuickGraph.Collections.IEdgeList&lt;TVertex, TEdge&gt;&gt;() != null" vb="Contract.Result(Of QuickGraph.Collections.IEdgeList(Of TVertex, TEdge))() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:QuickGraph.Collections.Contracts.IDisjointSetContract`1">
      <invariant>0 &lt;= ithis.SetCount</invariant>
      <invariant>ithis.SetCount &lt;= ithis.ElementCount</invariant>
    </member>
    <member name="T:QuickGraph.Collections.SoftHeap`2">
      <invariant>this.count &gt; -1</invariant>
      <invariant>this.header != null</invariant>
      <invariant>this.tail != null</invariant>
    </member>
    <member name="M:QuickGraph.Collections.SoftHeap`2.#ctor(System.Double,`0,System.Func{`0,`0,System.Int32})">
      <requires csharp="comparison != null" vb="comparison &lt;&gt; Nothing">comparison != null</requires>
      <requires csharp="0.0 &lt; maximumErrorRate &amp;&amp; !!(maximumErrorRate &lt;= 0.5)" vb="0 &lt; maximumErrorRate AndAlso Not !(maximumErrorRate &lt;= 0.5)">0.0 &lt; maximumErrorRate &amp;&amp; !!(maximumErrorRate &lt;= 0.5)</requires>
    </member>
    <member name="M:QuickGraph.Collections.SoftHeap`2.Add(`0,`1)">
      <requires csharp="this.Comparison(key, this.KeyMaxValue) &lt; 0" vb="Me.Comparison(key, Me.KeyMaxValue) &lt; 0">this.Comparison(key, this.KeyMaxValue) &lt; 0</requires>
    </member>
    <member name="M:QuickGraph.Collections.SoftHeap`2.Meld(QuickGraph.Collections.SoftHeap{`0,`1}.Node)">
      <requires csharp="q != null" vb="q &lt;&gt; Nothing">q != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.SoftHeap`2.FixMinLinst(QuickGraph.Collections.SoftHeap{`0,`1}.Head)">
      <requires csharp="h != null" vb="h &lt;&gt; Nothing">h != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.SoftHeap`2.Shift(QuickGraph.Collections.SoftHeap{`0,`1}.Node)">
      <requires csharp="v != null" vb="v &lt;&gt; Nothing">v != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.SoftHeap`2.Enumerator.#ctor(QuickGraph.Collections.SoftHeap{`0,`1})">
      <requires csharp="owner != null" vb="owner &lt;&gt; Nothing">owner != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.BinaryQueue`2.#ctor(System.Func{`0,`1},System.Func{`1,`1,System.Int32})">
      <requires csharp="distances != null" vb="distances &lt;&gt; Nothing">distances != null</requires>
      <requires csharp="distanceComparison != null" vb="distanceComparison &lt;&gt; Nothing">distanceComparison != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.#ctor(System.Int32)">
      <requires csharp="elementCapacity &gt;= 0 &amp;&amp; elementCapacity &lt; int.MaxValue" vb="elementCapacity &gt;= 0 AndAlso elementCapacity &lt; int.MaxValue">elementCapacity &gt;= 0 &amp;&amp; elementCapacity &lt; int.MaxValue</requires>
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.Contains(`0)">
      <pure />
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.Union(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.Union(`0,`0)" inheritedFromTypeName="IDisjointSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)left != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)left) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)left != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.Union(`0,`0)" inheritedFromTypeName="IDisjointSet" csharp="this.Contains(left)" vb="Me.Contains(left)">this.Contains(left)</requires>
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.Union(`0,`0)" inheritedFromTypeName="IDisjointSet" csharp="(object)right != null" vb="((Object)right) &lt;&gt; Nothing">(object)right != null</requires>
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.Union(`0,`0)" inheritedFromTypeName="IDisjointSet" csharp="this.Contains(right)" vb="Me.Contains(right)">this.Contains(right)</requires>
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.FindSet(`0)">
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.FindSet(`0)" inheritedFromTypeName="IDisjointSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)value != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)value) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)value != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.FindSet(`0)" inheritedFromTypeName="IDisjointSet" csharp="this.Contains(value)" vb="Me.Contains(value)">this.Contains(value)</requires>
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.AreInSameSet(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.AreInSameSet(`0,`0)" inheritedFromTypeName="IDisjointSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)left != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)left) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)left != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.AreInSameSet(`0,`0)" inheritedFromTypeName="IDisjointSet" csharp="(object)right != null" vb="((Object)right) &lt;&gt; Nothing">(object)right != null</requires>
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.AreInSameSet(`0,`0)" inheritedFromTypeName="IDisjointSet" csharp="this.Contains(left)" vb="Me.Contains(left)">this.Contains(left)</requires>
      <requires inheritedFrom="M:QuickGraph.Collections.IDisjointSet`1.AreInSameSet(`0,`0)" inheritedFromTypeName="IDisjointSet" csharp="this.Contains(right)" vb="Me.Contains(right)">this.Contains(right)</requires>
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.FindNoCompression(QuickGraph.Collections.ForestDisjointSet{`0}.Element)">
      <pure />
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <ensures csharp="Contract.Result&lt;QuickGraph.Collections.ForestDisjointSet&lt;T&gt;.Element&gt;() != null" vb="Contract.Result(Of QuickGraph.Collections.ForestDisjointSet(Of T).Element)() &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.CompressPath(QuickGraph.Collections.ForestDisjointSet{`0}.Element,QuickGraph.Collections.ForestDisjointSet{`0}.Element)">
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="root != null" vb="root &lt;&gt; Nothing">root != null</requires>
    </member>
    <member name="M:QuickGraph.Collections.ForestDisjointSet`1.Union(QuickGraph.Collections.ForestDisjointSet{`0}.Element,QuickGraph.Collections.ForestDisjointSet{`0}.Element)">
      <requires csharp="left != null" vb="left &lt;&gt; Nothing">left != null</requires>
      <requires csharp="right != null" vb="right &lt;&gt; Nothing">right != null</requires>
      <ensures csharp="Contract.Result&lt;bool&gt;() ? Contract.Old(this.SetCount) - 1 == this.SetCount : Contract.Old(this.SetCount) == this.SetCount" vb="Contract.Result(Of Boolean )() ? Contract.Old(Me.SetCount) - 1 = Me.SetCount : Contract.Old(Me.SetCount) = Me.SetCount">result ? old(this.SetCount) - 1 == this.SetCount : old(this.SetCount) == this.SetCount</ensures>
      <ensures csharp="this.FindNoCompression(left) == this.FindNoCompression(right)" vb="Me.FindNoCompression(left) = Me.FindNoCompression(right)">this.FindNoCompression(left) == this.FindNoCompression(right)</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.#ctor(System.Boolean,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <requires csharp="vertexComparer != null" vb="vertexComparer &lt;&gt; Nothing">vertexComparer != null</requires>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.#ctor(System.Boolean,System.Int32,System.Int32,System.Func{System.Int32,QuickGraph.Collections.IVertexEdgeDictionary{`0,`1}})">
      <requires csharp="vertexEdgesDictionaryFactory != null" vb="vertexEdgesDictionaryFactory &lt;&gt; Nothing">vertexEdgesDictionaryFactory != null</requires>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.ContainsVertex(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()</requires>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.IsOutEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;bool&gt;() == this.OutDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.OutDegree(v) = 0">result == this.OutDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.OutDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.OutEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.OutEdges(v))">result == decimal.Count&lt;decimal&gt;(this.OutEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.OutEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.All&lt;decimal&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;(), (decimal e) =&gt; e.Source.Equals((decimal)v))" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))(), (e As TEdge) =&gt; e.Source.Equals(((Object)v)))">decimal.All&lt;decimal&gt;(result, (decimal e) =&gt; e.Source.Equals((decimal)v))</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(!Contract.Result&lt;bool&gt;() || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0" vb="(Contract.Result(Of Boolean )() AndAlso Not (edges &lt;&gt; Nothing AndAlso System.Linq.Enumerable.All(edges, (e As TEdge) =&gt; e.Source.Equals(((Object)v))))) &lt;&gt; 0">(!result || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.OutEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)" vb="index &gt;= 0 AndAlso index &lt; Me.OutDegree(v)">index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)Contract.Result&lt;decimal&gt;())" vb="System.Linq.Enumerable.ElementAt(Me.OutEdges(v), index).Equals(((Object)Contract.Result(Of TEdge)()))">decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)result)</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.ContainsEdge(`0,`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.ContainsEdge(`1)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;bool&gt;() == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))" vb="Contract.Result(Of Boolean )() = System.Diagnostics.Contracts.Contract.Exists(Me.Edges, (e As TEdge) =&gt; e.Equals(((Object)edge)))">result == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.TryGetEdge(`0,`0,`1@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.AddVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="Contract.Result&lt;bool&gt;() == Contract.Old(!this.ContainsVertex(v))" vb="Contract.Result(Of Boolean )() = Contract.Old(Not Me.ContainsVertex(v))">result == old(!this.ContainsVertex(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="this.VertexCount == Contract.Old(this.VertexCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.VertexCount = Contract.Old(Me.VertexCount) + (Contract.Result(Of Boolean )() ? 1 : 0)">this.VertexCount == old(this.VertexCount) + (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.AddVertexRange(System.Collections.Generic.IEnumerable{`0})">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="(() =&gt; {
    {
        push vertices;
        push decimal.&lt;&gt;9__4_0;
        if (dup == default(decimal))
        {
            pop;
            push (decimal v) =&gt; (object)v != null;
            &lt;&gt;9__4_0 = dup;
        }
    }
    return decimal.All&lt;decimal&gt;(pop, pop); })()" vb="(() =&gt; {
    push vertices;
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__4_0;
    If dup = Nothing Then
    pop
    push (v As TVertex) =&gt; ((Object)v) &lt;&gt; Nothing;
    &lt;&gt;9__4_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push vertices;
        push decimal.&lt;&gt;9__4_0;
        if (dup == default(decimal))
        {
            pop;
            push (decimal v) =&gt; (object)v != null;
            &lt;&gt;9__4_0 = dup;
        }
    }
    return decimal.All&lt;decimal&gt;(pop, pop); })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="decimal.All&lt;decimal&gt;(vertices, (decimal v) =&gt; this.ContainsVertex(v))" vb="System.Linq.Enumerable.All(vertices, (v As TVertex) =&gt; Me.ContainsVertex(v))">decimal.All&lt;decimal&gt;(vertices, (decimal v) =&gt; this.ContainsVertex(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.AddVertexRange(System.Collections.Generic.IEnumerable{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="this.VertexCount == Contract.Old(this.VertexCount) + Contract.Result&lt;int&gt;()" vb="Me.VertexCount = Contract.Old(Me.VertexCount) + Contract.Result(Of Integer )()">this.VertexCount == old(this.VertexCount) + result</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.OnVertexAdded(`0)">
      <requires csharp="(object)args != null" vb="((Object)args) &lt;&gt; Nothing">(object)args != null</requires>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.RemoveVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="Contract.Result&lt;bool&gt;() == Contract.Old(this.ContainsVertex(v))" vb="Contract.Result(Of Boolean )() = Contract.Old(Me.ContainsVertex(v))">result == old(this.ContainsVertex(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="!this.ContainsVertex(v)" vb="Not Me.ContainsVertex(v)">!this.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertex(`0)" inheritedFromTypeName="IMutableVertexSet" csharp="this.VertexCount == Contract.Old(this.VertexCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.VertexCount = Contract.Old(Me.VertexCount) - (Contract.Result(Of Boolean )() ? 1 : 0)">this.VertexCount == old(this.VertexCount) - (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.OnVertexRemoved(`0)">
      <requires csharp="(object)args != null" vb="((Object)args) &lt;&gt; Nothing">(object)args != null</requires>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.RemoveVertexIf(QuickGraph.VertexPredicate{`0})">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return pred != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return pred &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return pred != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(this.Vertices, (decimal v) =&gt; pred(v)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(Me.Vertices, (v As TVertex) =&gt; pred(v)))">result == old(decimal.Count&lt;decimal&gt;(this.Vertices, (decimal v) =&gt; pred(v)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="decimal.All&lt;decimal&gt;(this.Vertices, (decimal v) =&gt; !pred(v))" vb="System.Linq.Enumerable.All(Me.Vertices, (v As TVertex) =&gt; Not pred(v))">decimal.All&lt;decimal&gt;(this.Vertices, (decimal v) =&gt; !pred(v))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexSet`1.RemoveVertexIf(QuickGraph.VertexPredicate{`0})" inheritedFromTypeName="IMutableVertexSet" csharp="this.VertexCount == Contract.Old(this.VertexCount) - Contract.Result&lt;int&gt;()" vb="Me.VertexCount = Contract.Old(Me.VertexCount) - Contract.Result(Of Integer )()">this.VertexCount == old(this.VertexCount) - result</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.AddVerticesAndEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="this.ContainsEdge(edge)" vb="Me.ContainsEdge(edge)">this.ContainsEdge(edge)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="this.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.Old(!this.ContainsEdge(edge))" vb="Me.AllowParallelEdges OrElse Contract.Result(Of Boolean )() = Contract.Old(Not Me.ContainsEdge(edge))">this.AllowParallelEdges || result == old(!this.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableVertexAndEdgeSet`2.AddVerticesAndEdge(`1)" inheritedFromTypeName="IMutableVertexAndEdgeSet" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + (Contract.Result(Of Boolean )() ? 1 : 0)">this.EdgeCount == old(this.EdgeCount) + (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__4_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__4_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()" vb="(() =&gt; {
    If Not System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType Then
    push edges;
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__4_0;
    If dup = Nothing Then
    pop
    push (edge As TEdge) =&gt; ((Object)edge) &lt;&gt; Nothing;
    &lt;&gt;9__4_0 = dup
    push System.Linq.Enumerable.All(pop, pop);
    else    push 1;
    return pop &lt;&gt; 0; })()">(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__4_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__4_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if (this.ContainsVertex(edge.Source))
    {
        return this.ContainsVertex(edge.Target);

    }
    return false;

})" vb="System.Linq.Enumerable.All(edges, delegate (edge As TEdge) {
    If Me.ContainsVertex(edge.Source) Then
    Return Me.ContainsVertex(edge.Target)
    Return False
})">decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if (this.ContainsVertex(edge.Source))
    {
        return this.ContainsVertex(edge.Target);

    }
    return false;

})</requires>
      <ensures description="all edge from edges belong to the graph" inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="decimal.All&lt;decimal&gt;(edges, (decimal edge) =&gt; this.ContainsEdge(edge))" vb="System.Linq.Enumerable.All(edges, (edge As TEdge) =&gt; Me.ContainsEdge(edge))">decimal.All&lt;decimal&gt;(edges, (decimal edge) =&gt; this.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(edges, (decimal edge) =&gt; !this.ContainsEdge(edge)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(edges, (edge As TEdge) =&gt; Not Me.ContainsEdge(edge)))">result == old(decimal.Count&lt;decimal&gt;(edges, (decimal edge) =&gt; !this.ContainsEdge(edge)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + Contract.Result&lt;int&gt;()" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + Contract.Result(Of Integer )()">this.EdgeCount == old(this.EdgeCount) + result</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.RemoveEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="Contract.Result&lt;bool&gt;() == Contract.Old(this.ContainsEdge(edge))" vb="Contract.Result(Of Boolean )() = Contract.Old(Me.ContainsEdge(edge))">result == old(this.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="!this.ContainsEdge(edge)" vb="Not Me.ContainsEdge(edge)">!this.ContainsEdge(edge)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) - (Contract.Result(Of Boolean )() ? 1 : 0)">this.EdgeCount == old(this.EdgeCount) - (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return predicate != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return predicate &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return predicate != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(this.Edges, (decimal e) =&gt; predicate(e)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(Me.Edges, (e As TEdge) =&gt; predicate(e)))">result == old(decimal.Count&lt;decimal&gt;(this.Edges, (decimal e) =&gt; predicate(e)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="decimal.All&lt;decimal&gt;(this.Edges, (decimal e) =&gt; !predicate(e))" vb="System.Linq.Enumerable.All(Me.Edges, (e As TEdge) =&gt; Not predicate(e))">decimal.All&lt;decimal&gt;(this.Edges, (decimal e) =&gt; !predicate(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) - Contract.Result&lt;int&gt;()" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) - Contract.Result(Of Integer )()">this.EdgeCount == old(this.EdgeCount) - result</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.ClearOutEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.ClearOutEdges(`0)" inheritedFromTypeName="IMutableIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.ClearOutEdges(`0)" inheritedFromTypeName="IMutableIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.ClearOutEdges(`0)" inheritedFromTypeName="IMutableIncidenceGraph" csharp="this.OutDegree(v) == 0" vb="Me.OutDegree(v) = 0">this.OutDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph" csharp="predicate != null" vb="predicate &lt;&gt; Nothing">predicate != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph" csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(this.OutEdges(v), (decimal ve) =&gt; predicate(ve)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(Me.OutEdges(v), (ve As TEdge) =&gt; predicate(ve)))">result == old(decimal.Count&lt;decimal&gt;(this.OutEdges(v), (decimal ve) =&gt; predicate(ve)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableIncidenceGraph`2.RemoveOutEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableIncidenceGraph" csharp="decimal.All&lt;decimal&gt;(this.OutEdges(v), (decimal ve) =&gt; !predicate(ve))" vb="System.Linq.Enumerable.All(Me.OutEdges(v), (ve As TEdge) =&gt; Not predicate(ve))">decimal.All&lt;decimal&gt;(this.OutEdges(v), (decimal ve) =&gt; !predicate(ve))</ensures>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.#ctor(QuickGraph.Collections.IVertexEdgeDictionary{`0,`1},System.Int32,System.Int32,System.Boolean)">
      <requires csharp="vertexEdges != null" vb="vertexEdges &lt;&gt; Nothing">vertexEdges != null</requires>
      <requires csharp="edgeCount &gt;= 0" vb="edgeCount &gt;= 0">edgeCount &gt;= 0</requires>
    </member>
    <member name="M:QuickGraph.AdjacencyGraph`2.Clone">
      <pure />
    </member>
    <member name="P:QuickGraph.AdjacencyGraph`2.AllowParallelEdges">
      <getter>
        <pure />
      </getter>
    </member>
    <member name="P:QuickGraph.AdjacencyGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.VertexCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.VertexCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.VertexCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.AdjacencyGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Vertices); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Vertices); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Vertices); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.AdjacencyGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TVertex&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TVertex))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.DelegateVertexAndEdgeListGraph`2.#ctor(System.Collections.Generic.IEnumerable{`0},QuickGraph.TryFunc{`0,System.Collections.Generic.IEnumerable{`1}})">
      <requires csharp="vertices != null" vb="vertices &lt;&gt; Nothing">vertices != null</requires>
      <requires csharp="System.Linq.Enumerable.All&lt;TVertex&gt;(vertices, delegate (TVertex v) {
    decimal&lt;TEdge&gt; local_0;
    return tryGetOutEdges(v, ref local_0);

})" vb="System.Linq.Enumerable.All(vertices, delegate (v As TVertex) {
    decimal&lt;TEdge&gt; local_0;
    Return tryGetOutEdges(v, &amp;local_0)
})">System.Linq.Enumerable.All&lt;TVertex&gt;(vertices, delegate (TVertex v) {
    decimal&lt;TEdge&gt; local_0;
    return tryGetOutEdges(v, ref local_0);

})</requires>
    </member>
    <member name="M:QuickGraph.DelegateVertexAndEdgeListGraph`2.ContainsEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;bool&gt;() == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))" vb="Contract.Result(Of Boolean )() = System.Diagnostics.Contracts.Contract.Exists(Me.Edges, (e As TEdge) =&gt; e.Equals(((Object)edge)))">result == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))</ensures>
    </member>
    <member name="P:QuickGraph.DelegateVertexAndEdgeListGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.VertexCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.VertexCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.VertexCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.DelegateVertexAndEdgeListGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Vertices); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Vertices); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Vertices); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.DelegateVertexAndEdgeListGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TVertex&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TVertex))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.DelegateVertexAndEdgeListGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.EdgeCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.EdgeCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.EdgeCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.DelegateVertexAndEdgeListGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Edges); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Edges); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Edges); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.DelegateVertexAndEdgeListGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        push Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;();
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))();
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__5_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__5_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push result;
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.STaggedEdge`2.#ctor(`0,`0,`1)">
      <requires csharp="(object)source != null" vb="((Object)source) &lt;&gt; Nothing">(object)source != null</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
    </member>
    <member name="P:QuickGraph.STaggedEdge`2.Source">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Source" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.STaggedEdge`2.Target">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdge`1.get_Target" inheritedFromTypeName="IEdge" csharp="(object)Contract.Result&lt;TVertex&gt;() != null" vb="((Object)Contract.Result(Of TVertex)()) &lt;&gt; Nothing">(object)result != null</ensures>
      </getter>
    </member>
    <member name="T:QuickGraph.Contracts.IUndirectedEdgeContract`1">
      <invariant>Comparer&lt;TVertex&gt;.Default.Compare(ithis.Source, ithis.Target) &lt;= 0</invariant>
    </member>
    <member name="T:QuickGraph.Contracts.IEdgeContract`1">
      <invariant>ithis.Source != null</invariant>
      <invariant>ithis.Target != null</invariant>
    </member>
    <member name="M:QuickGraph.Contracts.GraphContract.VertexCountEqual``1(QuickGraph.IVertexSet{``0},QuickGraph.IVertexSet{``0})">
      <pure />
      <requires csharp="left != null" vb="left &lt;&gt; Nothing">left != null</requires>
      <requires csharp="right != null" vb="right &lt;&gt; Nothing">right != null</requires>
    </member>
    <member name="M:QuickGraph.Contracts.GraphContract.EdgeCountEqual``2(QuickGraph.IEdgeListGraph{``0,``1},QuickGraph.IEdgeListGraph{``0,``1})">
      <pure />
      <requires csharp="left != null" vb="left &lt;&gt; Nothing">left != null</requires>
      <requires csharp="right != null" vb="right &lt;&gt; Nothing">right != null</requires>
    </member>
    <member name="M:QuickGraph.Contracts.GraphContract.InVertexSet``1(QuickGraph.IVertexSet{``0},``0)">
      <pure />
      <requires csharp="g != null" vb="g &lt;&gt; Nothing">g != null</requires>
      <requires csharp="(object)v != null" vb="((Object)v) &lt;&gt; Nothing">(object)v != null</requires>
    </member>
    <member name="M:QuickGraph.Contracts.GraphContract.InVertexSet``2(QuickGraph.IEdgeListGraph{``0,``1},``1)">
      <pure />
      <requires csharp="g != null" vb="g &lt;&gt; Nothing">g != null</requires>
      <requires csharp="(object)e != null" vb="((Object)e) &lt;&gt; Nothing">(object)e != null</requires>
    </member>
    <member name="M:QuickGraph.Contracts.GraphContract.InEdgeSet``2(QuickGraph.IEdgeListGraph{``0,``1},``1)">
      <pure />
      <requires csharp="g != null" vb="g &lt;&gt; Nothing">g != null</requires>
      <requires csharp="(object)e != null" vb="((Object)e) &lt;&gt; Nothing">(object)e != null</requires>
    </member>
    <member name="M:QuickGraph.VertexEventArgs`1.#ctor(`0)">
      <requires csharp="(object)vertex != null" vb="((Object)vertex) &lt;&gt; Nothing">(object)vertex != null</requires>
    </member>
    <member name="M:QuickGraph.DelegateImplicitUndirectedGraph`2.#ctor(QuickGraph.TryFunc{`0,System.Collections.Generic.IEnumerable{`1}},System.Boolean)">
      <requires csharp="tryGetAdjacenyEdges != null" vb="tryGetAdjacenyEdges &lt;&gt; Nothing">tryGetAdjacenyEdges != null</requires>
    </member>
    <member name="M:QuickGraph.DelegateImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;bool&gt;() == this.AdjacentDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.AdjacentDegree(v) = 0">result == this.AdjacentDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.DelegateImplicitUndirectedGraph`2.AdjacentDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.AdjacentEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.AdjacentEdges(v))">result == decimal.Count&lt;decimal&gt;(this.AdjacentEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.DelegateImplicitUndirectedGraph`2.AdjacentEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)v != null" vb="((Object)v) &lt;&gt; Nothing">(object)v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="decimal.All&lt;TEdge&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;(), delegate (TEdge edge) {
    if ((decimal)edge != default(decimal))
    {
        if (this.ContainsEdge(edge.Source, edge.Target))
        {
            if (!edge.Source.Equals((decimal)v))
            {
                return edge.Target.Equals((decimal)v);

            }
            return true;

        }
    }
    return false;

})" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))(), delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    If Me.ContainsEdge(edge.Source, edge.Target) Then
    If Not edge.Source.Equals(((Object)v)) Then
    Return edge.Target.Equals(((Object)v))
    Return True
    Return False
})">decimal.All&lt;TEdge&gt;(result, delegate (TEdge edge) {
    if ((decimal)edge != default(decimal))
    {
        if (this.ContainsEdge(edge.Source, edge.Target))
        {
            if (!edge.Source.Equals((decimal)v))
            {
                return edge.Target.Equals((decimal)v);

            }
            return true;

        }
    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.DelegateImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)Contract.Result&lt;decimal&gt;() != null" vb="((Object)Contract.Result(Of TEdge)()) &lt;&gt; Nothing">(object)result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;decimal&gt;().Source.Equals((object)v) || Contract.Result&lt;decimal&gt;().Target.Equals((object)v)" vb="Contract.Result(Of TEdge)().Source.Equals(((Object)v)) OrElse Contract.Result(Of TEdge)().Target.Equals(((Object)v))">result.Source.Equals((object)v) || result.Target.Equals((object)v)</ensures>
    </member>
    <member name="M:QuickGraph.DelegateImplicitUndirectedGraph`2.ContainsVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()</requires>
    </member>
    <member name="M:QuickGraph.DelegateImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
    </member>
    <member name="M:QuickGraph.DelegateImplicitUndirectedGraph`2.ContainsEdge(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;bool&gt;() == decimal.Any&lt;decimal&gt;(this.AdjacentEdges(source), delegate (decimal e) {
    if (!e.Target.Equals((decimal)target))
    {
        return e.Source.Equals((decimal)target);

    }
    return true;

})" vb="Contract.Result(Of Boolean )() = System.Linq.Enumerable.Any(Me.AdjacentEdges(source), delegate (e As TEdge) {
    If Not e.Target.Equals(((Object)target)) Then
    Return e.Source.Equals(((Object)target))
    Return True
})">result == decimal.Any&lt;decimal&gt;(this.AdjacentEdges(source), delegate (decimal e) {
    if (!e.Target.Equals((decimal)target))
    {
        return e.Source.Equals((decimal)target);

    }
    return true;

})</ensures>
    </member>
    <member name="P:QuickGraph.DelegateImplicitUndirectedGraph`2.EdgeEqualityComparer">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.get_EdgeEqualityComparer" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;QuickGraph.EdgeEqualityComparer&lt;TVertex, TEdge&gt;&gt;() != null" vb="Contract.Result(Of QuickGraph.EdgeEqualityComparer(Of TVertex, TEdge))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)">
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)">
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.EdgeListGraph`2.ContainsEdge(`1)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;bool&gt;() == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))" vb="Contract.Result(Of Boolean )() = System.Diagnostics.Contracts.Contract.Exists(Me.Edges, (e As TEdge) =&gt; e.Equals(((Object)edge)))">result == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))</ensures>
    </member>
    <member name="M:QuickGraph.EdgeListGraph`2.AddEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.ContainsVertex(edge.Source)" vb="Me.ContainsVertex(edge.Source)">this.ContainsVertex(edge.Source)</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.ContainsVertex(edge.Target)" vb="Me.ContainsVertex(edge.Target)">this.ContainsVertex(edge.Target)</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.ContainsEdge(edge)" vb="Me.ContainsEdge(edge)">this.ContainsEdge(edge)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.AllowParallelEdges || Contract.Result&lt;bool&gt;() == Contract.Old(!this.ContainsEdge(edge))" vb="Me.AllowParallelEdges OrElse Contract.Result(Of Boolean )() = Contract.Old(Not Me.ContainsEdge(edge))">this.AllowParallelEdges || result == old(!this.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + (Contract.Result(Of Boolean )() ? 1 : 0)">this.EdgeCount == old(this.EdgeCount) + (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.EdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__4_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__4_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()" vb="(() =&gt; {
    If Not System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(TEdge)).IsValueType Then
    push edges;
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__4_0;
    If dup = Nothing Then
    pop
    push (edge As TEdge) =&gt; ((Object)edge) &lt;&gt; Nothing;
    &lt;&gt;9__4_0 = dup
    push System.Linq.Enumerable.All(pop, pop);
    else    push 1;
    return pop &lt;&gt; 0; })()">(() =&gt; {
    {
        if (!decimal.GetTypeInfo(typeof(decimal)).IsValueType)
        {
            push edges;
            push decimal.&lt;&gt;9__4_0;
            if (dup == default(decimal))
            {
                pop;
                push (decimal edge) =&gt; (object)edge != null;
                &lt;&gt;9__4_0 = dup;
            }
            push decimal.All&lt;decimal&gt;(pop, pop);
        }
        else
        {
            push 1;
        }
    }
    return pop != 0; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if (this.ContainsVertex(edge.Source))
    {
        return this.ContainsVertex(edge.Target);

    }
    return false;

})" vb="System.Linq.Enumerable.All(edges, delegate (edge As TEdge) {
    If Me.ContainsVertex(edge.Source) Then
    Return Me.ContainsVertex(edge.Target)
    Return False
})">decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if (this.ContainsVertex(edge.Source))
    {
        return this.ContainsVertex(edge.Target);

    }
    return false;

})</requires>
      <ensures description="all edge from edges belong to the graph" inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="decimal.All&lt;decimal&gt;(edges, (decimal edge) =&gt; this.ContainsEdge(edge))" vb="System.Linq.Enumerable.All(edges, (edge As TEdge) =&gt; Me.ContainsEdge(edge))">decimal.All&lt;decimal&gt;(edges, (decimal edge) =&gt; this.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(edges, (decimal edge) =&gt; !this.ContainsEdge(edge)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(edges, (edge As TEdge) =&gt; Not Me.ContainsEdge(edge)))">result == old(decimal.Count&lt;decimal&gt;(edges, (decimal edge) =&gt; !this.ContainsEdge(edge)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.AddEdgeRange(System.Collections.Generic.IEnumerable{`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) + Contract.Result&lt;int&gt;()" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) + Contract.Result(Of Integer )()">this.EdgeCount == old(this.EdgeCount) + result</ensures>
    </member>
    <member name="M:QuickGraph.EdgeListGraph`2.RemoveEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="Contract.Result&lt;bool&gt;() == Contract.Old(this.ContainsEdge(edge))" vb="Contract.Result(Of Boolean )() = Contract.Old(Me.ContainsEdge(edge))">result == old(this.ContainsEdge(edge))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="!this.ContainsEdge(edge)" vb="Not Me.ContainsEdge(edge)">!this.ContainsEdge(edge)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdge(`1)" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) - (Contract.Result&lt;bool&gt;() ? 1 : 0)" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) - (Contract.Result(Of Boolean )() ? 1 : 0)">this.EdgeCount == old(this.EdgeCount) - (result ? 1 : 0)</ensures>
    </member>
    <member name="M:QuickGraph.EdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})">
      <requires inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return predicate != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return predicate &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return predicate != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(this.Edges, (decimal e) =&gt; predicate(e)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(Me.Edges, (e As TEdge) =&gt; predicate(e)))">result == old(decimal.Count&lt;decimal&gt;(this.Edges, (decimal e) =&gt; predicate(e)))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="decimal.All&lt;decimal&gt;(this.Edges, (decimal e) =&gt; !predicate(e))" vb="System.Linq.Enumerable.All(Me.Edges, (e As TEdge) =&gt; Not predicate(e))">decimal.All&lt;decimal&gt;(this.Edges, (decimal e) =&gt; !predicate(e))</ensures>
      <ensures inheritedFrom="M:QuickGraph.IMutableEdgeListGraph`2.RemoveEdgeIf(QuickGraph.EdgePredicate{`0,`1})" inheritedFromTypeName="IMutableEdgeListGraph" csharp="this.EdgeCount == Contract.Old(this.EdgeCount) - Contract.Result&lt;int&gt;()" vb="Me.EdgeCount = Contract.Old(Me.EdgeCount) - Contract.Result(Of Integer )()">this.EdgeCount == old(this.EdgeCount) - result</ensures>
    </member>
    <member name="M:QuickGraph.EdgeListGraph`2.#ctor(System.Boolean,System.Boolean,QuickGraph.Collections.EdgeEdgeDictionary{`0,`1})">
      <requires csharp="edges != null" vb="edges &lt;&gt; Nothing">edges != null</requires>
    </member>
    <member name="M:QuickGraph.EdgeListGraph`2.ContainsVertex(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()</requires>
    </member>
    <member name="P:QuickGraph.EdgeListGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.EdgeCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.EdgeCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.EdgeCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.EdgeListGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Edges); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Edges); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Edges); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.EdgeListGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        push Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;();
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))();
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__5_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__5_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push result;
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.EdgeListGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.VertexCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.VertexCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.VertexCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.EdgeListGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Vertices); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Vertices); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Vertices); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.EdgeListGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TVertex&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TVertex))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.#ctor(QuickGraph.IUndirectedGraph{`0,`1})">
      <requires csharp="graph != null" vb="graph &lt;&gt; Nothing">graph != null</requires>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.AdjacentEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)v != null" vb="((Object)v) &lt;&gt; Nothing">(object)v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="decimal.All&lt;TEdge&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;(), delegate (TEdge edge) {
    if ((decimal)edge != default(decimal))
    {
        if (this.ContainsEdge(edge.Source, edge.Target))
        {
            if (!edge.Source.Equals((decimal)v))
            {
                return edge.Target.Equals((decimal)v);

            }
            return true;

        }
    }
    return false;

})" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))(), delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    If Me.ContainsEdge(edge.Source, edge.Target) Then
    If Not edge.Source.Equals(((Object)v)) Then
    Return edge.Target.Equals(((Object)v))
    Return True
    Return False
})">decimal.All&lt;TEdge&gt;(result, delegate (TEdge edge) {
    if ((decimal)edge != default(decimal))
    {
        if (this.ContainsEdge(edge.Source, edge.Target))
        {
            if (!edge.Source.Equals((decimal)v))
            {
                return edge.Target.Equals((decimal)v);

            }
            return true;

        }
    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.AdjacentDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.AdjacentEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.AdjacentEdges(v))">result == decimal.Count&lt;decimal&gt;(this.AdjacentEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;bool&gt;() == this.AdjacentDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.AdjacentDegree(v) = 0">result == this.AdjacentDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.AdjacentEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)Contract.Result&lt;decimal&gt;() != null" vb="((Object)Contract.Result(Of TEdge)()) &lt;&gt; Nothing">(object)result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;decimal&gt;().Source.Equals((object)v) || Contract.Result&lt;decimal&gt;().Target.Equals((object)v)" vb="Contract.Result(Of TEdge)().Source.Equals(((Object)v)) OrElse Contract.Result(Of TEdge)().Target.Equals(((Object)v))">result.Source.Equals((object)v) || result.Target.Equals((object)v)</ensures>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.TryGetEdge(`0,`0,`1@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.ContainsEdge(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;bool&gt;() == decimal.Any&lt;decimal&gt;(this.AdjacentEdges(source), delegate (decimal e) {
    if (!e.Target.Equals((decimal)target))
    {
        return e.Source.Equals((decimal)target);

    }
    return true;

})" vb="Contract.Result(Of Boolean )() = System.Linq.Enumerable.Any(Me.AdjacentEdges(source), delegate (e As TEdge) {
    If Not e.Target.Equals(((Object)target)) Then
    Return e.Source.Equals(((Object)target))
    Return True
})">result == decimal.Any&lt;decimal&gt;(this.AdjacentEdges(source), delegate (decimal e) {
    if (!e.Target.Equals((decimal)target))
    {
        return e.Source.Equals((decimal)target);

    }
    return true;

})</ensures>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.ContainsVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()</requires>
    </member>
    <member name="M:QuickGraph.ArrayUndirectedGraph`2.ContainsEdge(`1)">
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;bool&gt;() == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))" vb="Contract.Result(Of Boolean )() = System.Diagnostics.Contracts.Contract.Exists(Me.Edges, (e As TEdge) =&gt; e.Equals(((Object)edge)))">result == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))</ensures>
    </member>
    <member name="P:QuickGraph.ArrayUndirectedGraph`2.EdgeEqualityComparer">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.get_EdgeEqualityComparer" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;QuickGraph.EdgeEqualityComparer&lt;TVertex, TEdge&gt;&gt;() != null" vb="Contract.Result(Of QuickGraph.EdgeEqualityComparer(Of TVertex, TEdge))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayUndirectedGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.EdgeCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.EdgeCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.EdgeCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayUndirectedGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Edges); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Edges); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Edges); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayUndirectedGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        push Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;();
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))();
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__5_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__5_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push result;
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayUndirectedGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.VertexCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.VertexCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.VertexCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayUndirectedGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Vertices); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Vertices); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Vertices); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.ArrayUndirectedGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TVertex&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TVertex))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredGraph`3.#ctor(`2,QuickGraph.VertexPredicate{`0},QuickGraph.EdgePredicate{`0,`1})">
      <requires csharp="(object)baseGraph != null" vb="((Object)baseGraph) &lt;&gt; Nothing">(object)baseGraph != null</requires>
      <requires csharp="vertexPredicate != null" vb="vertexPredicate &lt;&gt; Nothing">vertexPredicate != null</requires>
      <requires csharp="edgePredicate != null" vb="edgePredicate &lt;&gt; Nothing">edgePredicate != null</requires>
    </member>
    <member name="M:QuickGraph.Predicates.InDictionaryVertexPredicate`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
      <requires csharp="dictionary != null" vb="dictionary &lt;&gt; Nothing">dictionary != null</requires>
    </member>
    <member name="M:QuickGraph.Predicates.InDictionaryVertexPredicate`2.Test(`0)">
      <pure />
      <requires csharp="(object)v != null" vb="((Object)v) &lt;&gt; Nothing">(object)v != null</requires>
    </member>
    <member name="M:QuickGraph.Predicates.ResidualEdgePredicate`2.#ctor(System.Collections.Generic.IDictionary{`1,System.Double})">
      <requires csharp="residualCapacities != null" vb="residualCapacities &lt;&gt; Nothing">residualCapacities != null</requires>
    </member>
    <member name="M:QuickGraph.Predicates.ResidualEdgePredicate`2.Test(`1)">
      <requires csharp="(object)e != null" vb="((Object)e) &lt;&gt; Nothing">(object)e != null</requires>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredIncidenceGraph`3.ContainsEdge(`0,`0)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredIncidenceGraph`3.TryGetEdge(`0,`0,`1@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredIncidenceGraph`3.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.Predicates.SinkVertexPredicate`2.#ctor(QuickGraph.IIncidenceGraph{`0,`1})">
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredVertexListGraph`3.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.VertexCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.VertexCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.VertexCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredVertexListGraph`3.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Vertices); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Vertices); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Vertices); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredVertexListGraph`3.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TVertex&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TVertex))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredImplicitGraph`3.IsOutEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;bool&gt;() == this.OutDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.OutDegree(v) = 0">result == this.OutDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredImplicitGraph`3.OutDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.OutEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.OutEdges(v))">result == decimal.Count&lt;decimal&gt;(this.OutEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredImplicitGraph`3.OutEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.All&lt;decimal&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;(), (decimal e) =&gt; e.Source.Equals((decimal)v))" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))(), (e As TEdge) =&gt; e.Source.Equals(((Object)v)))">decimal.All&lt;decimal&gt;(result, (decimal e) =&gt; e.Source.Equals((decimal)v))</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredImplicitGraph`3.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(!Contract.Result&lt;bool&gt;() || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0" vb="(Contract.Result(Of Boolean )() AndAlso Not (edges &lt;&gt; Nothing AndAlso System.Linq.Enumerable.All(edges, (e As TEdge) =&gt; e.Source.Equals(((Object)v))))) &lt;&gt; 0">(!result || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredImplicitGraph`3.OutEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)" vb="index &gt;= 0 AndAlso index &lt; Me.OutDegree(v)">index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)Contract.Result&lt;decimal&gt;())" vb="System.Linq.Enumerable.ElementAt(Me.OutEdges(v), index).Equals(((Object)Contract.Result(Of TEdge)()))">decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)result)</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.ReversedResidualEdgePredicate`2.#ctor(System.Collections.Generic.IDictionary{`1,System.Double},System.Collections.Generic.IDictionary{`1,`1})">
      <requires csharp="residualCapacities != null" vb="residualCapacities &lt;&gt; Nothing">residualCapacities != null</requires>
      <requires csharp="reversedEdges != null" vb="reversedEdges &lt;&gt; Nothing">reversedEdges != null</requires>
    </member>
    <member name="M:QuickGraph.Predicates.ReversedResidualEdgePredicate`2.Test(`1)">
      <requires csharp="(object)e != null" vb="((Object)e) &lt;&gt; Nothing">(object)e != null</requires>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredImplicitVertexSet`3.ContainsVertex(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()</requires>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredEdgeListGraph`3.FilterEdge(`1)">
      <pure />
    </member>
    <member name="M:QuickGraph.Predicates.FilteredEdgeListGraph`3.ContainsEdge(`1)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;bool&gt;() == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))" vb="Contract.Result(Of Boolean )() = System.Diagnostics.Contracts.Contract.Exists(Me.Edges, (e As TEdge) =&gt; e.Equals(((Object)edge)))">result == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))</ensures>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredEdgeListGraph`3.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.VertexCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.VertexCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.VertexCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredEdgeListGraph`3.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Vertices); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Vertices); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Vertices); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredEdgeListGraph`3.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TVertex&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TVertex))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredEdgeListGraph`3.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.EdgeCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.EdgeCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.EdgeCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredEdgeListGraph`3.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Edges); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Edges); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Edges); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredEdgeListGraph`3.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        push Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;();
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))();
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__5_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__5_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push result;
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredUndirectedGraph`3.AdjacentEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)v != null" vb="((Object)v) &lt;&gt; Nothing">(object)v != null</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdges(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="decimal.All&lt;TEdge&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;(), delegate (TEdge edge) {
    if ((decimal)edge != default(decimal))
    {
        if (this.ContainsEdge(edge.Source, edge.Target))
        {
            if (!edge.Source.Equals((decimal)v))
            {
                return edge.Target.Equals((decimal)v);

            }
            return true;

        }
    }
    return false;

})" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))(), delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    If Me.ContainsEdge(edge.Source, edge.Target) Then
    If Not edge.Source.Equals(((Object)v)) Then
    Return edge.Target.Equals(((Object)v))
    Return True
    Return False
})">decimal.All&lt;TEdge&gt;(result, delegate (TEdge edge) {
    if ((decimal)edge != default(decimal))
    {
        if (this.ContainsEdge(edge.Source, edge.Target))
        {
            if (!edge.Source.Equals((decimal)v))
            {
                return edge.Target.Equals((decimal)v);

            }
            return true;

        }
    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredUndirectedGraph`3.AdjacentDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentDegree(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.AdjacentEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.AdjacentEdges(v))">result == decimal.Count&lt;decimal&gt;(this.AdjacentEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredUndirectedGraph`3.IsAdjacentEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.IsAdjacentEdgesEmpty(`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;bool&gt;() == this.AdjacentDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.AdjacentDegree(v) = 0">result == this.AdjacentDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredUndirectedGraph`3.AdjacentEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)Contract.Result&lt;decimal&gt;() != null" vb="((Object)Contract.Result(Of TEdge)()) &lt;&gt; Nothing">(object)result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.AdjacentEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;decimal&gt;().Source.Equals((object)v) || Contract.Result&lt;decimal&gt;().Target.Equals((object)v)" vb="Contract.Result(Of TEdge)().Source.Equals(((Object)v)) OrElse Contract.Result(Of TEdge)().Target.Equals(((Object)v))">result.Source.Equals((object)v) || result.Target.Equals((object)v)</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredUndirectedGraph`3.TryGetEdge(`0,`0,`1@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredUndirectedGraph`3.ContainsEdge(`0,`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;bool&gt;() == decimal.Any&lt;decimal&gt;(this.AdjacentEdges(source), delegate (decimal e) {
    if (!e.Target.Equals((decimal)target))
    {
        return e.Source.Equals((decimal)target);

    }
    return true;

})" vb="Contract.Result(Of Boolean )() = System.Linq.Enumerable.Any(Me.AdjacentEdges(source), delegate (e As TEdge) {
    If Not e.Target.Equals(((Object)target)) Then
    Return e.Source.Equals(((Object)target))
    Return True
})">result == decimal.Any&lt;decimal&gt;(this.AdjacentEdges(source), delegate (decimal e) {
    if (!e.Target.Equals((decimal)target))
    {
        return e.Source.Equals((decimal)target);

    }
    return true;

})</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredUndirectedGraph`3.ContainsEdge(`1)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;bool&gt;() == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))" vb="Contract.Result(Of Boolean )() = System.Diagnostics.Contracts.Contract.Exists(Me.Edges, (e As TEdge) =&gt; e.Equals(((Object)edge)))">result == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredUndirectedGraph`3.ContainsVertex(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()</requires>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredUndirectedGraph`3.EdgeEqualityComparer">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IImplicitUndirectedGraph`2.get_EdgeEqualityComparer" inheritedFromTypeName="IImplicitUndirectedGraph" csharp="Contract.Result&lt;QuickGraph.EdgeEqualityComparer&lt;TVertex, TEdge&gt;&gt;() != null" vb="Contract.Result(Of QuickGraph.EdgeEqualityComparer(Of TVertex, TEdge))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredUndirectedGraph`3.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.EdgeCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.EdgeCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.EdgeCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredUndirectedGraph`3.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Edges); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Edges); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Edges); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredUndirectedGraph`3.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        push Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;();
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))();
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__5_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__5_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push result;
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredUndirectedGraph`3.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.VertexCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.VertexCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.VertexCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredUndirectedGraph`3.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Vertices); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Vertices); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Vertices); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredUndirectedGraph`3.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TVertex&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TVertex))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredBidirectionalGraph`3.IsInEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;bool&gt;() == this.InDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.InDegree(v) = 0">result == this.InDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredBidirectionalGraph`3.InDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.InEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.InEdges(v))">result == decimal.Count&lt;decimal&gt;(this.InEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredBidirectionalGraph`3.InEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="decimal.All&lt;decimal&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;(), delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))(), delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    Return edge.Target.Equals(((Object)v))
    Return False
})">decimal.All&lt;decimal&gt;(result, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredBidirectionalGraph`3.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;bool&gt;() == this.ContainsVertex(v)" vb="Contract.Result(Of Boolean )() = Me.ContainsVertex(v)">result == this.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="!Contract.Result&lt;bool&gt;() || edges != null" vb="Not Contract.Result(Of Boolean )() OrElse edges &lt;&gt; Nothing">!result || edges != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="!Contract.Result&lt;bool&gt;() || decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})" vb="Not Contract.Result(Of Boolean )() OrElse System.Linq.Enumerable.All(edges, delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    Return edge.Target.Equals(((Object)v))
    Return False
})">!result || decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredBidirectionalGraph`3.Degree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;int&gt;() == this.InDegree(v) + this.OutDegree(v)" vb="Contract.Result(Of Integer )() = Me.InDegree(v) + Me.OutDegree(v)">result == this.InDegree(v) + this.OutDegree(v)</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredBidirectionalGraph`3.ContainsEdge(`1)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;bool&gt;() == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))" vb="Contract.Result(Of Boolean )() = System.Diagnostics.Contracts.Contract.Exists(Me.Edges, (e As TEdge) =&gt; e.Equals(((Object)edge)))">result == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))</ensures>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredBidirectionalGraph`3.InEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="index &gt;= 0 &amp;&amp; index &lt; this.InDegree(v)" vb="index &gt;= 0 AndAlso index &lt; Me.InDegree(v)">index &gt;= 0 &amp;&amp; index &lt; this.InDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;decimal&gt;().Equals((object)decimal.ElementAt&lt;decimal&gt;(this.InEdges(v), index))" vb="Contract.Result(Of TEdge)().Equals(((Object)System.Linq.Enumerable.ElementAt(Me.InEdges(v), index)))">result.Equals((object)decimal.ElementAt&lt;decimal&gt;(this.InEdges(v), index))</ensures>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredBidirectionalGraph`3.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.EdgeCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.EdgeCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.EdgeCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredBidirectionalGraph`3.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Edges); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Edges); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Edges); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredBidirectionalGraph`3.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        push Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;();
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))();
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__5_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__5_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push result;
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Predicates.FilteredVertexAndEdgeListGraph`3.ContainsEdge(`1)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;bool&gt;() == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))" vb="Contract.Result(Of Boolean )() = System.Diagnostics.Contracts.Contract.Exists(Me.Edges, (e As TEdge) =&gt; e.Equals(((Object)edge)))">result == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))</ensures>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredVertexAndEdgeListGraph`3.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.EdgeCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.EdgeCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.EdgeCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredVertexAndEdgeListGraph`3.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Edges); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Edges); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Edges); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.Predicates.FilteredVertexAndEdgeListGraph`3.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        push Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;();
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))();
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__5_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__5_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push result;
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.Predicates.IsolatedVertexPredicate`2.#ctor(QuickGraph.IBidirectionalGraph{`0,`1})">
      <requires csharp="visitedGraph != null" vb="visitedGraph &lt;&gt; Nothing">visitedGraph != null</requires>
    </member>
    <member name="M:QuickGraph.Predicates.IsolatedVertexPredicate`2.Test(`0)">
      <pure />
      <requires csharp="(object)v != null" vb="((Object)v) &lt;&gt; Nothing">(object)v != null</requires>
    </member>
    <member name="M:QuickGraph.DelegateImplicitGraph`2.#ctor(QuickGraph.TryFunc{`0,System.Collections.Generic.IEnumerable{`1}})">
      <requires csharp="tryGetOutEdges != null" vb="tryGetOutEdges &lt;&gt; Nothing">tryGetOutEdges != null</requires>
    </member>
    <member name="M:QuickGraph.DelegateImplicitGraph`2.IsOutEdgesEmpty(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;bool&gt;() == this.OutDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.OutDegree(v) = 0">result == this.OutDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.DelegateImplicitGraph`2.OutDegree(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.OutEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.OutEdges(v))">result == decimal.Count&lt;decimal&gt;(this.OutEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.DelegateImplicitGraph`2.OutEdges(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.All&lt;decimal&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;(), (decimal e) =&gt; e.Source.Equals((decimal)v))" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))(), (e As TEdge) =&gt; e.Source.Equals(((Object)v)))">decimal.All&lt;decimal&gt;(result, (decimal e) =&gt; e.Source.Equals((decimal)v))</ensures>
    </member>
    <member name="M:QuickGraph.DelegateImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(!Contract.Result&lt;bool&gt;() || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0" vb="(Contract.Result(Of Boolean )() AndAlso Not (edges &lt;&gt; Nothing AndAlso System.Linq.Enumerable.All(edges, (e As TEdge) =&gt; e.Source.Equals(((Object)v))))) &lt;&gt; 0">(!result || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0</ensures>
    </member>
    <member name="M:QuickGraph.DelegateImplicitGraph`2.OutEdge(`0,System.Int32)">
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)" vb="index &gt;= 0 AndAlso index &lt; Me.OutDegree(v)">index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)Contract.Result&lt;decimal&gt;())" vb="System.Linq.Enumerable.ElementAt(Me.OutEdges(v), index).Equals(((Object)Contract.Result(Of TEdge)()))">decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)result)</ensures>
    </member>
    <member name="M:QuickGraph.DelegateImplicitGraph`2.ContainsVertex(`0)">
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()</requires>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.#ctor(QuickGraph.IVertexAndEdgeListGraph{`0,`1})">
      <requires csharp="baseGraph != null" vb="baseGraph &lt;&gt; Nothing">baseGraph != null</requires>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.IsInEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.IsInEdgesEmpty(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;bool&gt;() == this.InDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.InDegree(v) = 0">result == this.InDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.InDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InDegree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.InEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.InEdges(v))">result == decimal.Count&lt;decimal&gt;(this.InEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.InEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdges(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="decimal.All&lt;decimal&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;(), delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))(), delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    Return edge.Target.Equals(((Object)v))
    Return False
})">decimal.All&lt;decimal&gt;(result, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;bool&gt;() == this.ContainsVertex(v)" vb="Contract.Result(Of Boolean )() = Me.ContainsVertex(v)">result == this.ContainsVertex(v)</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="!Contract.Result&lt;bool&gt;() || edges != null" vb="Not Contract.Result(Of Boolean )() OrElse edges &lt;&gt; Nothing">!result || edges != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.TryGetInEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="!Contract.Result&lt;bool&gt;() || decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})" vb="Not Contract.Result(Of Boolean )() OrElse System.Linq.Enumerable.All(edges, delegate (edge As TEdge) {
    If ((Object)edge) &lt;&gt; Nothing Then
    Return edge.Target.Equals(((Object)v))
    Return False
})">!result || decimal.All&lt;decimal&gt;(edges, delegate (decimal edge) {
    if ((decimal)edge != default(decimal))
    {
        return edge.Target.Equals((decimal)v);

    }
    return false;

})</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.InEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="index &gt;= 0 &amp;&amp; index &lt; this.InDegree(v)" vb="index &gt;= 0 AndAlso index &lt; Me.InDegree(v)">index &gt;= 0 &amp;&amp; index &lt; this.InDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.InEdge(`0,System.Int32)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;decimal&gt;().Equals((object)decimal.ElementAt&lt;decimal&gt;(this.InEdges(v), index))" vb="Contract.Result(Of TEdge)().Equals(((Object)System.Linq.Enumerable.ElementAt(Me.InEdges(v), index)))">result.Equals((object)decimal.ElementAt&lt;decimal&gt;(this.InEdges(v), index))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.Degree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IBidirectionalIncidenceGraph`2.Degree(`0)" inheritedFromTypeName="IBidirectionalIncidenceGraph" csharp="Contract.Result&lt;int&gt;() == this.InDegree(v) + this.OutDegree(v)" vb="Contract.Result(Of Integer )() = Me.InDegree(v) + Me.OutDegree(v)">result == this.InDegree(v) + this.OutDegree(v)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.ContainsEdge(`0,`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.ContainsEdge(`0,`0)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdges(`0,`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.TryGetEdge(`0,`0,`1@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)source) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)source != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="(object)target != null" vb="((Object)target) &lt;&gt; Nothing">(object)target != null</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(source)" vb="Me.ContainsVertex(source)">this.ContainsVertex(source)</requires>
      <requires inheritedFrom="M:QuickGraph.IIncidenceGraph`2.TryGetEdge(`0,`0,`1@)" inheritedFromTypeName="IIncidenceGraph" csharp="this.ContainsVertex(target)" vb="Me.ContainsVertex(target)">this.ContainsVertex(target)</requires>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.IsOutEdgesEmpty(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.IsOutEdgesEmpty(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;bool&gt;() == this.OutDegree(v) == 0" vb="Contract.Result(Of Boolean )() = Me.OutDegree(v) = 0">result == this.OutDegree(v) == 0</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.OutDegree(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutDegree(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.OutEdges(v))" vb="Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.OutEdges(v))">result == decimal.Count&lt;decimal&gt;(this.OutEdges(v))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.OutEdges(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))() &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdges(`0)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.All&lt;decimal&gt;(Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;decimal&gt;&gt;(), (decimal e) =&gt; e.Source.Equals((decimal)v))" vb="System.Linq.Enumerable.All(Contract.Result(Of System.Collections.Generic.IEnumerable(Of Decimal))(), (e As TEdge) =&gt; e.Source.Equals(((Object)v)))">decimal.All&lt;decimal&gt;(result, (decimal e) =&gt; e.Source.Equals((decimal)v))</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)v != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.TryGetOutEdges(`0,System.Collections.Generic.IEnumerable{`1}@)" inheritedFromTypeName="IImplicitGraph" csharp="(!Contract.Result&lt;bool&gt;() || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0" vb="(Contract.Result(Of Boolean )() AndAlso Not (edges &lt;&gt; Nothing AndAlso System.Linq.Enumerable.All(edges, (e As TEdge) =&gt; e.Source.Equals(((Object)v))))) &lt;&gt; 0">(!result || edges != default(decimal) &amp;&amp; decimal.All&lt;decimal&gt;(edges, (decimal e) =&gt; e.Source.Equals((decimal)v))) != 0</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.OutEdge(`0,System.Int32)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)v) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)v != null; })()</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="this.ContainsVertex(v)" vb="Me.ContainsVertex(v)">this.ContainsVertex(v)</requires>
      <requires inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)" vb="index &gt;= 0 AndAlso index &lt; Me.OutDegree(v)">index &gt;= 0 &amp;&amp; index &lt; this.OutDegree(v)</requires>
      <ensures inheritedFrom="M:QuickGraph.IImplicitGraph`2.OutEdge(`0,System.Int32)" inheritedFromTypeName="IImplicitGraph" csharp="decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)Contract.Result&lt;decimal&gt;())" vb="System.Linq.Enumerable.ElementAt(Me.OutEdges(v), index).Equals(((Object)Contract.Result(Of TEdge)()))">decimal.ElementAt&lt;decimal&gt;(this.OutEdges(v), index).Equals((object)result)</ensures>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.ContainsVertex(`0)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IImplicitVertexSet`1.ContainsVertex(`0)" inheritedFromTypeName="IImplicitVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()</requires>
    </member>
    <member name="M:QuickGraph.BidirectionAdapterGraph`2.ContainsEdge(`1)">
      <pure />
      <requires inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)edge) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)edge != null; })()</requires>
      <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.ContainsEdge(`1)" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;bool&gt;() == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))" vb="Contract.Result(Of Boolean )() = System.Diagnostics.Contracts.Contract.Exists(Me.Edges, (e As TEdge) =&gt; e.Equals(((Object)edge)))">result == decimal.Exists&lt;decimal&gt;(this.Edges, (decimal e) =&gt; e.Equals((decimal)edge))</ensures>
    </member>
    <member name="P:QuickGraph.BidirectionAdapterGraph`2.IsVerticesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_IsVerticesEmpty" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.VertexCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.VertexCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.VertexCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionAdapterGraph`2.VertexCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_VertexCount" inheritedFromTypeName="IVertexSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Vertices); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Vertices); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Vertices); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionAdapterGraph`2.Vertices">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IVertexSet`1.get_Vertices" inheritedFromTypeName="IVertexSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TVertex&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TVertex))() &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionAdapterGraph`2.IsEdgesEmpty">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_IsEdgesEmpty" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;bool&gt;() == this.EdgeCount == 0; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Boolean )() = Me.EdgeCount = 0; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == this.EdgeCount == 0; })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionAdapterGraph`2.EdgeCount">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_EdgeCount" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return Contract.Result&lt;int&gt;() == decimal.Count&lt;decimal&gt;(this.Edges); })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return Contract.Result(Of Integer )() = System.Linq.Enumerable.Count(Me.Edges); })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return result == decimal.Count&lt;decimal&gt;(this.Edges); })()</ensures>
      </getter>
    </member>
    <member name="P:QuickGraph.BidirectionAdapterGraph`2.Edges">
      <getter>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;() != null" vb="Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))() &lt;&gt; Nothing">result != null</ensures>
        <ensures inheritedFrom="M:QuickGraph.IEdgeSet`2.get_Edges" inheritedFromTypeName="IEdgeSet" csharp="(() =&gt; {
    {
        push Contract.Result&lt;System.Collections.Generic.IEnumerable&lt;TEdge&gt;&gt;();
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()" vb="(() =&gt; {
    push Contract.Result(Of System.Collections.Generic.IEnumerable(Of TEdge))();
    push Microsoft.Cci.DummyTypeReference.&lt;&gt;9__5_0;
    If dup = Nothing Then
    pop
    push (e As TEdge) =&gt; ((Object)e) &lt;&gt; Nothing;
    &lt;&gt;9__5_0 = dup
    return System.Linq.Enumerable.All(pop, pop); })()">(() =&gt; {
    {
        push result;
        push decimal.&lt;&gt;9__5_0;
        if (dup == default(decimal))
        {
            pop;
            push (TEdge e) =&gt; (object)e != null;
            &lt;&gt;9__5_0 = dup;
        }
    }
    return decimal.All&lt;TEdge&gt;(pop, pop); })()</ensures>
      </getter>
    </member>
    <member name="M:QuickGraph.TaggedEquatableEdge`2.#ctor(`0,`0,`1)">
      <ensures csharp="object.Equals((object)this.Tag, (object)tag)" vb="System.Object.Equals(((Object)Me.Tag), ((Object)tag))">object.Equals((object)this.Tag, (object)tag)</ensures>
    </member>
    <member name="M:QuickGraph.IMutableUndirectedGraph`2.RemoveAdjacentEdgeIf(`0,QuickGraph.EdgePredicate{`0,`1})">
      <requires csharp="(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_1 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_1 = this;
    }
    return (object)vertex != null; })()</requires>
      <requires csharp="predicate != null" vb="predicate &lt;&gt; Nothing">predicate != null</requires>
      <ensures csharp="Contract.Result&lt;int&gt;() == Contract.Old(decimal.Count&lt;decimal&gt;(this.AdjacentEdges(vertex), (decimal e) =&gt; predicate(e)))" vb="Contract.Result(Of Integer )() = Contract.Old(System.Linq.Enumerable.Count(Me.AdjacentEdges(vertex), (e As TEdge) =&gt; predicate(e)))">result == old(decimal.Count&lt;decimal&gt;(this.AdjacentEdges(vertex), (decimal e) =&gt; predicate(e)))</ensures>
      <ensures csharp="decimal.All&lt;decimal&gt;(this.AdjacentEdges(vertex), (decimal v) =&gt; !predicate(v))" vb="System.Linq.Enumerable.All(Me.AdjacentEdges(vertex), (v As TEdge) =&gt; Not predicate(v))">decimal.All&lt;decimal&gt;(this.AdjacentEdges(vertex), (decimal v) =&gt; !predicate(v))</ensures>
    </member>
    <member name="M:QuickGraph.IMutableUndirectedGraph`2.ClearAdjacentEdges(`0)">
      <requires csharp="(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()" vb="(() =&gt; {
    decimal local_0 = Me;
    return ((Object)vertex) &lt;&gt; Nothing; })()">(() =&gt; {
    {
        decimal local_0 = this;
    }
    return (object)vertex != null; })()</requires>
      <ensures csharp="this.AdjacentDegree(vertex) == 0" vb="Me.AdjacentDegree(vertex) = 0">this.AdjacentDegree(vertex) == 0</ensures>
    </member>
  </members>
</doc>