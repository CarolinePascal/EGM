using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Windows.Forms;
using abb.egm;
using OxyPlot;
using CsvHelper;

//////////////////////////////////////////////////////////////////////////
// Sample program using protobuf-csharp-port 
// (http://code.google.com/p/protobuf-csharp-port/wiki/GettingStarted)
//
// 1) Download protobuf-csharp binaries from https://code.google.com/p/protobuf-csharp-port/
// 2) Unpack the zip file
// 3) Copy the egm.proto file to a sub catalogue where protobuf-csharp was un-zipped, e.g. ~\protobuf-csharp\tools\egm
// 4) Generate an egm C# file from the egm.proto file by typing in a windows console: protogen .\egm\egm.proto --proto_path=.\egm
// 5) Create a C# console application in Visual Studio
// 6) Install Nuget, in Visual Studio, click Tools and then Extension Manager. Goto to Online, find the NuGet Package Manager extension and click Download.
// 7) Install protobuf-csharp via NuGet, select in Visual Studio, Tools Nuget Package Manager and then Package Manager Console and type PM>Install-Package Google.ProtocolBuffers
// 8) Add the generated file egm.cs to the Visual Studio project (add existing item)
// 9) Copy the code below and then compile, link and run.
//////////////////////////////////////////////////////////////////////////

namespace EgmSmallTest
{
    class Program
    {
        // listen on this port for inbound messages
        public static int IpPortNumber = 6510;
        public static double DisplayPeriod = 100;   //In ms
        public static string filePath = "C:/Users/carol/Desktop/Stage_1/plot.py";
        public static string python = "c:/users/carol/appdata/local/programs/python/python36-32/python.exe";
        public static int Plot = 1000;

        static void Main(string[] args)
        {
            Sensor s = new Sensor();
            s.Start();

            Console.WriteLine("Press any key to Exit");
            Console.ReadLine();
        }
    }

    public class Sensor
    {
        private Thread _sensorThread = null;
        private UdpClient _udpServer = null;
        private bool _exitThread = false;
        private uint _seqNumber = 0;
        private int _distanceSquare;
        private int _xStartPoint;
        private int _yStartPoint;
        private float _x;
        private float _y;
        private float _z;
        private int _robotX;
        private int _robotY;
        private int _robotZ;

        //public double Height { get; set; }

        // Set the measurements for the square and initialize the start points
        public Sensor()
        {
            _distanceSquare = 200;
            _xStartPoint = 400;
            _yStartPoint = -300;
            _x = 400;
            _y = -300;
            _z = 100;
            _robotX = 0;
            _robotY = 0;
            _robotZ = 0;
        }

        public StringBuilder PlotInit()
        {
            var text = new StringBuilder();
            text.AppendLine("#Plot Python Essai");
            text.AppendLine("import matplotlib.pyplot as plt");
            text.AppendLine("from mpl_toolkits.mplot3d import Axes3D");
            text.AppendLine(" ");
            text.AppendLine("X=[]");
            text.AppendLine("Y=[]");
            text.AppendLine("Z=[]");
            text.AppendLine(" ");
            text.AppendLine("fig=plt.figure()");
            text.AppendLine("ax=fig.gca(projection='3d')");

            return (text);

        }

        public void Fill(string x, string y, string z, StringBuilder text)
        {
            var newLine = string.Format("X.append({0})", x);
            text.AppendLine(newLine);
            newLine = string.Format("Y.append({0})", y);
            text.AppendLine(newLine);
            newLine = string.Format("Z.append({0})", z);
            text.AppendLine(newLine);
        }

        public void Plot(StringBuilder text)
        {
            text.AppendLine("ax.plot(X,Y,Z)");
            text.AppendLine("plt.axis('equal')");
            text.AppendLine("plt.show()");
            File.WriteAllText(Program.filePath, text.ToString());

            ProcessStartInfo start = new ProcessStartInfo();
            string cmd = Program.python;
            string args = Program.filePath;

            start.FileName = cmd;
            start.Arguments = args;
            start.UseShellExecute = false;// Do not use OS shell
            start.CreateNoWindow = true; // We don't need new window
            start.RedirectStandardOutput = true;// Any output, generated by application will be redirected back
            start.RedirectStandardError = true; // Any error in standard output will be redirected back (for example exceptions)

            Process process = Process.Start(start);
        }

        public void SensorThread()
        {
            // create an udp client and listen on any address and the port _ipPortNumber
            _udpServer = new UdpClient(Program.IpPortNumber);
            var remoteEP = new IPEndPoint(IPAddress.Any, Program.IpPortNumber);
            Console.WriteLine("Connexion avec le client - Adresse IP : " + remoteEP.Address + " - Port : " + remoteEP.Port);// The IPAdress is created by the program

            int timer = 0;  //Timer
            int timerRef = (int)DateTime.Now.Ticks;   //Timer reference

            StringBuilder text = PlotInit();

            int Count = 0;  //Number of positions recoded and ploted

            while (_exitThread == false && Count<=Program.Plot)
            {
                Count++;

                // get the message from robot
                var data = _udpServer.Receive(ref remoteEP);

                if (data != null)
                {
                    // de-serialize inbound message from robot using Google Protocol Buffer 
                    EgmRobot robot = EgmRobot.CreateBuilder().MergeFrom(data).Build();

                    // display inbound message
                    timer = DisplayInboundMessage(robot);

                    // Get the robots X-position
                    _robotX = Convert.ToInt32((robot.FeedBack.Cartesian.Pos.X));
                    // Get the robots Y-position
                    _robotY = Convert.ToInt32((robot.FeedBack.Cartesian.Pos.Y));
                    // Get the robots Z-position
                    _robotZ = Convert.ToInt32((robot.FeedBack.Cartesian.Pos.Z));

                    //Display robot position

                    if (timer - timerRef >= Program.DisplayPeriod)   //So non permanent latencies can be managed 
                    {
                        Console.WriteLine("Position du Robot :" + Environment.NewLine
                           + "- Position X : " + -_robotX + Environment.NewLine
                           + "- Position Y : " + -_robotY + Environment.NewLine
                           + "- Position Z : " + -_robotZ);
                        timerRef = timer;
                    }

                    Fill(_robotX.ToString(), _robotY.ToString(), _robotZ.ToString(), text);

                    // Put the signal value acquisition here !

                    // create a new outbound sensor message
                    EgmSensor.Builder sensor = EgmSensor.CreateBuilder();
                    CreateSensorMessage(sensor);

                    using (MemoryStream memoryStream = new MemoryStream())
                    {
                        EgmSensor sensorMessage = sensor.Build();
                        sensorMessage.WriteTo(memoryStream);

                        // send the UDP message to the robot
                        int bytesSent = _udpServer.Send(memoryStream.ToArray(),
                                                       (int)memoryStream.Length, remoteEP);
                        if (bytesSent < 0)
                        {
                            Console.WriteLine("Error send to robot");
                        }
                    }
                }
            }

            Plot(text);

        }



        // Display message from robot
        int DisplayInboundMessage(EgmRobot robot)
        {
            int time = 0;
            if (robot.HasHeader && robot.Header.HasSeqno && robot.Header.HasTm)
            {
                time = (int)robot.Header.Tm;
                //Console.WriteLine("Seq={0} tm={1}", robot.Header.Seqno.ToString(), robot.Header.Tm.ToString()); //Uncomment to display


            }
            else
            {
                //Console.WriteLine("No header in robot message");  //Uncomment to display
            }
            return (time);
        }

        private int n = 0;

        //////////////////////////////////////////////////////////////////////////
        // Create a sensor message to send to the robot
        void CreateSensorMessage(EgmSensor.Builder sensor)
        {
            n++;
            // create a header
            EgmHeader.Builder hdr = new EgmHeader.Builder();
            hdr.SetSeqno(_seqNumber++)
               //Timestamp in milliseconds (can be used for monitoring delays)
               .SetTm((uint)DateTime.Now.Ticks)
               //Sent by sensor, MSGTYPE_DATA if sent from robot controller
               .SetMtype(EgmHeader.Types.MessageType.MSGTYPE_CORRECTION);   //What are the main differencies between those messages types ?

            sensor.SetHeader(hdr);

            // create some sensor data
            EgmPlanned.Builder planned = new EgmPlanned.Builder();
            EgmPose.Builder pos = new EgmPose.Builder();
            EgmQuaternion.Builder pq = new EgmQuaternion.Builder();
            EgmCartesian.Builder pc = new EgmCartesian.Builder();

            _x = 400; //Modify for viable movement (The square leads to a singularity)
            _y = Y_Path(ref _y,(float)0.2); //Some value
            _z = 100 + 100*(float)Math.Sin(n/50); //Some other value
            Console.WriteLine(_z);
            Console.WriteLine(_y);
            

            pc.SetX(_x)
              .SetY(_y)
              .SetZ(_z);

            pq.SetU0(0.0)   //To check, but seems to be vertical
              .SetU1(0.0)
              .SetU2(0.0)
              .SetU3(0.0);

            pos.SetPos(pc)  //pose definition
                .SetOrient(pq);

            // bind pos object to planned
            planned.SetCartesian(pos);
            // bind planned to sensor object 
            sensor.SetPlanned(planned);

            return;
        }

        // Start a thread to listen on inbound messages
        public void Start()
        {
            _sensorThread = new Thread(new ThreadStart(SensorThread));  //Multitasking <3
            _sensorThread.Start();
        }

        // Stop and exit thread
        public void Stop()
        {
            _exitThread = true;
            _sensorThread.Abort();  //Stops the thread
        }

        public float Y_Path(ref float target, float corr)
        {
            target = target + corr;
            return (target);
        }

        ////Set the Y-positions for the square
        //public float Y_Values_Square()
        //{
        //    if (_robotX == _xStartPoint + _distanceSquare && _robotY == _yStartPoint)
        //    {
        //        _y = _yStartPoint - _distanceSquare;

        //    }
        //    else if (_robotX == _xStartPoint && _robotY == _yStartPoint - _distanceSquare && _y == _yStartPoint - _distanceSquare)
        //    {
        //        _y = _y + _distanceSquare;

        //    }
        //    return _y;
        //}
        ////public double Variable { get; set; }
        //public static double Variable { get; set; }

        //// Set the X-positions for the square
        //public float X_Values_Square()
        //{
        //    if (_robotX == _xStartPoint && _robotY == _yStartPoint && _x == _xStartPoint)
        //    {
        //        _x = _x + _distanceSquare;
        //    }

        //    else if (_robotX == _xStartPoint + _distanceSquare && _robotY == _yStartPoint - _distanceSquare && _x == _xStartPoint + _distanceSquare)
        //    {
        //        _x = _x - _distanceSquare;
        //    }
        //    return _x;
        //}
    }
}


